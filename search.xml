<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Mathematical Introduction to Logic -- Chapter 0</title>
    <url>//48e9c4af/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span></p>
<p>这是一个关于数理逻辑的读书笔记或者学习总结, 书名是A Mathematical
Introduction to Logic, 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>本文是Chapter 0, 点击<a href="/edd6b774">这里进入目录</a></p>
<p>第0章介绍一些集合论的基础概念, 这些概念是后面所有章节的基石.
我基本是把干货抄录在这里以便跳转</p>
<span id="more"></span>
<p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
<p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
<h2 id="Chapter0">Chapter Zero: Useful Facts about Sets</h2>
<h3 id="Set"><span class="math inline">\(\DEFi\)</span> Set 集合</h3>
<p>A <strong>set</strong> is a collection of things.</p>
<h3 id="SetEquality"><span class="math inline">\(\DEF\)</span> Set
Equality, <span class="math inline">\(A=B\)</span>, 集合相等</h3>
<p>If <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are sets such that for every object
t,</p>
<p><span class="math display">\[
t \in A \quad \text{iff} \quad t \in B
\]</span></p>
<p>then <span class="math inline">\(A=B\)</span></p>
<h3 id="Adjoin"><span class="math inline">\(\DEF\)</span> Adjoining one
extra object to a set, <span class="math inline">\(A;t\)</span>
添加元素</h3>
<p>Let <span class="math inline">\(A;t\)</span> be the set whose members
are (i) the members of A, plus (ii) the (possibly new) member t. We have
<span class="math display">\[A;t = A \cup {t}\]</span> using notation
defined later. and <span class="math display">\[
t \in A \quad\text{iff}\quad A;t=A
\]</span></p>
<h3 id="EmptySet"><span class="math inline">\(\DEF\)</span> Empty <span class="math inline">\(\varnothing\)</span> and Nonempty Set
空集和非空集</h3>
<p><em>Empty set</em> <span class="math inline">\(\varnothing\)</span>
is the set which has no members at all. Any other set is said to be
<em>nonempty</em>.</p>
<h3 id="Singleton"><span class="math inline">\(\DEF\)</span> Singleton
Set 单元素集</h3>
<p>For any object <span class="math inline">\(x\)</span>, there is the
<em>Singleton Set</em> <span class="math inline">\({x}\)</span> whose
only member is <span class="math inline">\(x\)</span>.</p>
<h3 id="Subset"><span class="math inline">\(\DEF\)</span> Subset
子集</h3>
<p>If <span class="math inline">\(A\)</span> is a set all of whose
members are also members of B, then A is a subset of B, abbreviated
<span class="math inline">\(A \subseteq B\)</span>.</p>
<h3 id="PowerSet"><span class="math inline">\(\DEF\)</span> Power set
幂集</h3>
<p>The <em>power set</em> <span class="math inline">\({\cal P}
A\)</span> of <span class="math inline">\(A\)</span> is a set whose
members are the <a href="#Subset">subsets</a> of A. Thus</p>
<p><span class="math display">\[ {\cal P} A = \{x|x \subseteq
A\}\]</span></p>
<h3 id="Union"><span class="math inline">\(\DEF\)</span> Union 并集</h3>
<p>The union of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, <span class="math inline">\(A \cup
B\)</span>, is the set of all things that are members of A or B (or
both).</p>
<p>If <span class="math inline">\(A\)</span> is a set whose members are
themselves sets. <span class="math display">\[
\bigcup A=\{x|\text{x belongs to some member of} A\}
\]</span></p>
<h3 id="Intersection"><span class="math inline">\(\DEF\)</span>
Inter-section 交集</h3>
<p>Intersection of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, <span class="math inline">\(A \cap
B\)</span>, is the set of all things that are members of both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<p>If <span class="math inline">\(A\)</span> is a set whose members are
themselves sets. <span class="math display">\[
\bigcap A=\{x|\text{x belongs to all members of} A\}
\]</span></p>
<h3 id="Disjoint"><span class="math inline">\(\DEF\)</span> Disjoint
不相交</h3>
<p>Sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are disjoint iff their <a href="#Intersection">intersection</a> is empty.</p>
<h3 id="PairwiseDisjoint"><span class="math inline">\(\DEF\)</span>
Pairwise Disjoint 两两不相交</h3>
<p>A collection of sets is pairwise disjoint iff any two members of the
collection are <a href="#disjoint">disjoint</a>.</p>
<h3 id="Pair"><span class="math inline">\(\DEF\)</span> Ordered Pair
有序对</h3>
<p>The ordered pair <span class="math inline">\(\langle x,y
\rangle\)</span> of objects <span class="math inline">\(x\)</span> and
<span class="math inline">\(y\)</span> is a <a href="#Set">set</a>:
<span class="math display">\[
\langle x,y \rangle = \{\{x\},\{x,y\}\}.
\]</span></p>
<h3 id="Triple"><span class="math inline">\(\DEF\)</span> Ordered Triple
有序三元组</h3>
<p>The ordered triples is a <a href="#Pair">pair</a>: <span class="math display">\[
\langle x,y,z \rangle = \langle\langle x,y\rangle,z \rangle.
\]</span></p>
<h3 id="NTuples"><span class="math inline">\(\DEF\)</span> N-tuples
有序n元组</h3>
<p>The n-tuples is defined recursively as a <a href="#Pair">pair</a>:
<span class="math display">\[
\langle x_1,\ldots,x_{n+1} \rangle = \langle\langle
x_1,\ldots,x_n\rangle,x_{n+1} \rangle.
\]</span></p>
<h3 id="String"><span class="math inline">\(\DEF\)</span> finite
sequence (or string) 有限序列(或者串)</h3>
<p><span class="math inline">\(S\)</span> is a <em>finite sequence</em>
(or <em>string</em>) of members of A iff some positive integer n, we
have <a href="#NTuples">n-tuples</a> <span class="math inline">\(S=\langle x_1,\ldots,x_{n+1} \rangle\)</span>,
where each <span class="math inline">\(x_i \in A\)</span>.</p>
<h3 id="Segment"><span class="math inline">\(\DEF\)</span> Segment
段</h3>
<p>A <em>segment</em> of the finite sequence <span class="math inline">\(S=\langle x_1,\ldots,x_{n+1} \rangle\)</span> is a
<a href="#String">finite sequence</a> <span class="math display">\[
S=\langle x_k, x_{k+1},\ldots,x_{m-1}, x_m
\rangle,\qquad\text{where}\quad 1 \le k \le m \le n.
\]</span></p>
<h3 id="InitialSegment"><span class="math inline">\(\DEF\)</span>
initial segment 初始段</h3>
<p>A segment is an <em>initial segment</em> iff <span class="math inline">\(k=1\)</span>.</p>
<h3 id="Proper"><span class="math inline">\(\DEF\)</span> proper
真子段</h3>
<p>A segment is proper iff it is different from <a href="#Segment"><span class="math inline">\(S\)</span></a></p>
<h3 id="LEMMA0A">LEMMA 0A 引理0A</h3>
<p>Assume that <span class="math inline">\(S=\langle x_1,\ldots,x_m
\rangle = \langle y_1,\ldots,y_m,\ldots,y_{m+k} \rangle\)</span>. Then
<span class="math inline">\(x_1 = \langle y_1,\ldots,y_{k+1}
\rangle\)</span>.</p>
<h3 id="CartesianProduct"><span class="math inline">\(\DEF\)</span>
Cartesian product 笛卡尔积</h3>
<p>The <em>Cartesian product</em> of sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, <span class="math inline">\(A \times
B\)</span>, is the set of all <a href="#Pair">pairs</a> <span class="math inline">\(\langle x,y \rangle\)</span> for which <span class="math inline">\(x \in A\)</span> and <span class="math inline">\(y
\in B\)</span>.</p>
<h3 id="CartesianExponent"><span class="math inline">\(\DEF\)</span>
Cartesian exponent 笛卡尔幂</h3>
<p><span class="math inline">\(A^n\)</span> is the set of all <a href="#NTuples">n-tuples</a> of members of A. For example. <span class="math inline">\(A^3 = (A \times A) \times A\)</span>.</p>
<h3 id="Relation"><span class="math inline">\(\DEF\)</span> Relation
关系</h3>
<p>A <em>relation</em> <span class="math inline">\(R\)</span> is a set
of ordered pairs.</p>
<h3 id="Domain"><span class="math inline">\(\DEF\)</span> Domain
定义域</h3>
<p>The <em>domain</em> of <a href="#Relation">relation</a> <span class="math inline">\(R\)</span> (written dom <span class="math inline">\(R\)</span>) is the set of all objects <span class="math inline">\(x\)</span> such that <span class="math inline">\(\langle x,y \rangle \in R\)</span> for some <span class="math inline">\(y\)</span>.</p>
<h3 id="Range"><span class="math inline">\(\DEF\)</span> Range 值域</h3>
<p>The <em>range</em> of <a href="#Relation">relation</a> <span class="math inline">\(R\)</span> (written ran <span class="math inline">\(R\)</span>) is the set of all objects <span class="math inline">\(y\)</span> such that <span class="math inline">\(\langle x,y \rangle \in R\)</span> for some <span class="math inline">\(x\)</span>.</p>
<h3 id="Field"><span class="math inline">\(\DEF\)</span> Field 域</h3>
<p>The union of <a href="#Domain">dom <span class="math inline">\(R\)</span></a> and <a href="#Range">ran <span class="math inline">\(R\)</span></a> is the field of <span class="math inline">\(R\)</span> <em>field</em> of <span class="math inline">\(R\)</span>, fld <span class="math inline">\(R\)</span>.</p>
<h3 id="NaryRelation"><span class="math inline">\(\DEF\)</span> N-ary
relation n元关系</h3>
<p>An <em>n-ary relation</em> on <span class="math inline">\(A\)</span>
is a <a href="#Subset">subset</a> of <a href="#CartesianExponent"><span class="math inline">\(A^n\)</span></a>. A <em>1-ary (unary)</em>
relation on A is simply a subset of A.</p>
<h3 id="Restriction"><span class="math inline">\(\DEF\)</span>
Restriction of <span class="math inline">\(R\)</span> to <span class="math inline">\(B\)</span> 关系<span class="math inline">\(R\)</span>对集合<span class="math inline">\(B\)</span>的限制</h3>
<p>For an n-ary relation <span class="math inline">\(R\)</span> on <span class="math inline">\(A\)</span> and subset <span class="math inline">\(B\)</span> of <span class="math inline">\(A\)</span>, the restriction of <span class="math inline">\(R\)</span> to <span class="math inline">\(B\)</span> is the <a href="#Intersection">intersection</a> <span class="math inline">\(R \cap
B^n\)</span>.</p>
<h3 id="Function"><span class="math inline">\(\DEF\)</span> Function
函数</h3>
<p>A <em>function</em> is a <a href="#Relation">relation</a> <span class="math inline">\(F\)</span>, with the property of being
single-valued: For each <span class="math inline">\(x\)</span> in dom
<span class="math inline">\(F\)</span> there is only one <span class="math inline">\(y\)</span> such that <span class="math inline">\(\langle x,y \rangle \in F\)</span>. This unique
<span class="math inline">\(y\)</span> is said to be value <span class="math inline">\(F(x)\)</span> that <span class="math inline">\(F\)</span> assumes at <span class="math inline">\(x\)</span>.</p>
<h3 id="CompositionOfFunctions"><span class="math inline">\(\DEF\)</span> Composition of functions
复合函数</h3>
<p><span class="math inline">\(f \circ g\)</span> is the <a href="#Function">function</a> whose value at <span class="math inline">\(x\)</span> is <span class="math inline">\(f(g(x))\)</span>.</p>
<h3 id="MapInto"><span class="math inline">\(\DEF\)</span> <span class="math inline">\(F\)</span> Map <span class="math inline">\(A\)</span> into <span class="math inline">\(B\)</span> <span class="math inline">\(F\)</span>把<span class="math inline">\(A\)</span>映射到<span class="math inline">\(B\)</span>中</h3>
<p>We say that <em><span class="math inline">\(F\)</span> Map <span class="math inline">\(A\)</span> into <span class="math inline">\(B\)</span></em> and write <span class="math display">\[F:A\rightarrow B\]</span> to mean that <span class="math inline">\(F\)</span> is a <a href="#Function">function</a>,
<a href="#Domain">dom</a> <span class="math inline">\(F=A\)</span>, and
<a href="#Range">ran</a> <a href="#Subset"><span class="math inline">\(F
\subseteq B\)</span></a>.</p>
<h3 id="MapOnto"><span class="math inline">\(\DEF\)</span> <span class="math inline">\(F\)</span> Map <span class="math inline">\(A\)</span> onto <span class="math inline">\(B\)</span> <span class="math inline">\(F\)</span>把<span class="math inline">\(A\)</span>映射到<span class="math inline">\(B\)</span>上</h3>
<p>If <a href="#MapInto"><span class="math inline">\(F\)</span> maps
<span class="math inline">\(A\)</span> into <span class="math inline">\(B\)</span></a>, and ran <span class="math inline">\(F=B\)</span>, then we say <em><span class="math inline">\(F\)</span> map <span class="math inline">\(A\)</span> onto <span class="math inline">\(B\)</span></em>.</p>
<h3 id="OneToOne"><span class="math inline">\(\DEF\)</span> One-to-one
一对一</h3>
<p>A <a href="#Function">function</a> <span class="math inline">\(F\)</span> is <em>one-to-one</em> iff for each
<span class="math inline">\(y\)</span> in ran <span class="math inline">\(F\)</span> there is only one <span class="math inline">\(x\)</span> such that <span class="math inline">\(\langle x,y \rangle \in F\)</span>.</p>
<h3 id="Multivariate"><span class="math inline">\(\DEF\)</span>
Multivariate Function 多变量函数</h3>
<p>If the <a href="#Pair">pair</a> <span class="math inline">\(\langle
x,y \rangle\)</span> is in dom <span class="math inline">\(F\)</span>,
then we let <span class="math inline">\(F(x,y) = F(\langle x,y
\rangle)\)</span>. This notation is extended to <a href="#NTuples">n-tuples</a>; <span class="math inline">\(F(x_1,\ldots,x_n)=F(\langle x_1,\ldots,x_n
\rangle)\)</span>.</p>
<h3 id="Operation"><span class="math inline">\(\DEF\)</span> n-ary
operation on <span class="math inline">\(A\)</span> 集合<span class="math inline">\(A\)</span>上的n元运算</h3>
<p>An <em>n-ary operation on <span class="math inline">\(A\)</span></em>
is a <a href="#Function">function</a> mapping <a href="#CartesianExponent"><span class="math inline">\(A^n\)</span></a>
<a href="#MapInto">into</a> <span class="math inline">\(A\)</span>.</p>
<h3 id="Closed"><span class="math inline">\(\DEF\)</span> <span class="math inline">\(A\)</span> is Closed under <span class="math inline">\(f\)</span> 集合<span class="math inline">\(A\)</span>在函数<span class="math inline">\(f\)</span>作用下是封闭的</h3>
<p>We say set A is <em>closed</em> under an function f, if <span class="math inline">\(f(a_1,\ldots,a_n) \in A\)</span> whenever each
<span class="math inline">\(a_i\)</span> is in <span class="math inline">\(A\)</span>.</p>
<h3 id="RestrictionOfOperation"><span class="math inline">\(\DEF\)</span> Restriction of operation
运算对集合的限制</h3>
<p>If <span class="math inline">\(f\)</span> is an <a href="#Operation">n-ary operationi on <span class="math inline">\(A\)</span></a>, then the <em>restriction</em> of
<span class="math inline">\(f\)</span> to a subset <span class="math inline">\(B\)</span> of <span class="math inline">\(A\)</span> is the function <span class="math inline">\(g\)</span> with domain <span class="math inline">\(B^n\)</span> which agrees with <span class="math inline">\(f\)</span> at each point of <span class="math inline">\(B^n\)</span>. Thus, <span class="math display">\[g=f \cap (B^n \times A).\]</span> This g will be
an a-ary operation on <span class="math inline">\(B\)</span> iff <span class="math inline">\(B\)</span> is <a href="#Closed">closed</a> under
<span class="math inline">\(f\)</span>. In this case, <span class="math inline">\(g=f\cap B^{n+1}\)</span>, in agreement with our
definition of the <a href="#Restriction">restriction</a> of a
relation.</p>
<h3 id="IdentityFunction"><span class="math inline">\(\DEF\)</span>
Identity function 恒等函数</h3>
<p>The <em>identity function</em> <span class="math inline">\(Id\)</span> on <span class="math inline">\(A\)</span>, is a unary operation on <span class="math inline">\(A\)</span>, given by the equation <span class="math display">\[
Id(x)=x \qquad \text{for}\quad x \in A
\]</span> Thus <span class="math inline">\(Id = \{\langle x,x \rangle|x
\in A\}\)</span></p>
<h3 id="AttributesOfRelation"><span class="math inline">\(\DEFn\)</span>
Attributes of Relation</h3>
<p>For a <a href="#Relation">relation</a> <span class="math inline">\(R\)</span>, we define the following</p>
<ul>
<li><span class="math inline">\(R\)</span> is <span id="Reflexive"><em>reflexive</em></span> on <span class="math inline">\(A\)</span> iff <span class="math inline">\(\langle
x,x \rangle \in R\)</span> for every <span class="math inline">\(x\)</span> in <span class="math inline">\(A\)</span>.</li>
<li><span class="math inline">\(R\)</span> is <span id="Symmetric"><em>symmetric</em></span> iff whenever <span class="math inline">\(\langle x,y \rangle \in R\)</span> then also <span class="math inline">\(\langle y,x \rangle \in R\)</span>.</li>
<li><span class="math inline">\(R\)</span> is <span id="Transitive"><em>transitive</em></span> iff whenever both <span class="math inline">\(\langle x,y \rangle \in R\)</span> and <span class="math inline">\(\langle y,z \rangle \in R\)</span> then also <span class="math inline">\(\langle x,z \rangle \in R\)</span>.</li>
<li><span class="math inline">\(R\)</span> satisfies <span id="Trichotomy"><em>trichotomy</em></span> on A (or is trichotomous) iff
for every x and y in A, exactly one of the tree possibilities, <span class="math inline">\(\langle x,y \rangle \in R\)</span>, <span class="math inline">\(x=y\)</span>, or <span class="math inline">\(\langle y,x \rangle \in R\)</span>, holds.</li>
<li><span class="math inline">\(R\)</span> is <span id="Connex"><em>connex</em></span> iff for all <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> in <span class="math inline">\(A\)</span>, we have <span class="math inline">\(\langle x,y \rangle \in R\)</span> or <span class="math inline">\(\langle y,x \rangle \in R\)</span></li>
<li><span class="math inline">\(R\)</span> is <span id="Anti-symmetric"><em>anti-symmetric</em></span> iff whenever <span class="math inline">\(\langle x,y \rangle \in R\)</span> and <span class="math inline">\(\langle y,x \rangle \in R\)</span>, then <span class="math inline">\(x=y\)</span></li>
<li><span class="math inline">\(R\)</span> is <span id="Anti-reflexive"><em>anti-reflexive</em></span> on <span class="math inline">\(A\)</span>, iff <span class="math inline">\(\langle x,y \rangle \in R\)</span> for every x in
A.</li>
<li><span class="math inline">\(R\)</span> is <span id="Asymmetric"><em>asymmetric</em></span> iff when whenever <span class="math inline">\(\langle x,y \rangle \in R\)</span> then <span class="math inline">\(\langle y,x \rangle \notin R\)</span></li>
</ul>
<h3 id="EquivalenceRelation"><span class="math inline">\(\DEF\)</span>
Equivalence Relation 等价关系</h3>
<p>For a <a href="#Relation">relation</a> <span class="math inline">\(R\)</span>, <span class="math inline">\(R\)</span>
is an <em>equivalence relation</em> on <span class="math inline">\(A\)</span> iff <span class="math inline">\(R\)</span> is a binary relation on A that is <a href="#Reflexive">reflexive</a>, <a href="#Symmetric">symmetric</a> and
<a href="#Transitive">transitive</a> on A</p>
<h3 id="OrderingRelation"><span class="math inline">\(\DEFn\)</span>
Ordering Relation 序关系</h3>
<p>For a <a href="#Relation">relation</a> <span class="math inline">\(R\)</span>,</p>
<ul>
<li><span class="math inline">\(R\)</span> is a <span id="TotalOrdering"><em>non-strict total order</em></span> on <span class="math inline">\(A\)</span> iff <span class="math inline">\(R\)</span> is <a href="#Reflexive">reflexive</a>,
<a href="#Anti-symmetric">anti-symmetric</a>, <a href="#Transitive">transitive</a>, and <a href="#Connex">connex</a> on
<span class="math inline">\(A\)</span>.</li>
<li><span class="math inline">\(R\)</span> is a <span id="StrictTotalOrdering"><em>strict total order</em></span> on <span class="math inline">\(A\)</span> iff <span class="math inline">\(R\)</span> is <a href="#Anti-reflexive">anti-reflexive</a>, <a href="#Asymmetric">asymmetric</a>, <a href="#Tansitive">tansitive</a>
and <a href="#Connex">connex</a> on <span class="math inline">\(A\)</span>.</li>
<li><span class="math inline">\(R\)</span> is a <span id="PartialOrdering"><em>non-strict partial order</em></span> on <span class="math inline">\(A\)</span> iff <span class="math inline">\(R\)</span> is <a href="#Reflexive">reflexive</a>,
<a href="#Anti-symmetric">anti-symmetric</a>, <a href="#Transitive">transitive</a> on <span class="math inline">\(A\)</span>.</li>
<li><span class="math inline">\(R\)</span> is a <span id="StrictPartialOrdering"><em>strict partial order</em></span> on <span class="math inline">\(A\)</span> iff <span class="math inline">\(R\)</span> is <a href="#Anti-reflexive">anti-reflexive</a>, <a href="#Asymmetric">asymmetric</a>, <a href="#Transitive">transitive</a>
on <span class="math inline">\(A\)</span></li>
</ul>
<h3 id="FiniteSet"><span class="math inline">\(\DEF\)</span> Finite Set
有限集</h3>
<p>A set <span class="math inline">\(A\)</span> is <em>finite</em> iff
there is some <a href="#OneToOne">one-to-one</a> function <span class="math inline">\(f\)</span> mapping the set <span class="math inline">\(A\)</span> <a href="#MapOnto">onto</a> <span class="math inline">\(\{0,1,\ldots,n-1\}\)</span> for some natural
number <span class="math inline">\(n\)</span>.</p>
<h3 id="CountableSet"><span class="math inline">\(\DEF\)</span>
countable Set 可数集</h3>
<p>A set <span class="math inline">\(A\)</span> is <em>countable</em>
iff there is some function mapping <span class="math inline">\(A\)</span> <a href="#OneToOne">one-to-one</a> into
<span class="math inline">\(\Bbb N\)</span>.</p>
<h3 id="Theorem0B">Theorem 0B</h3>
<p>Let <span class="math inline">\(A\)</span> be a coutable set. Then
the set of all finite sequences of members of <span class="math inline">\(A\)</span> is also coutable.</p>
<h3 id="Chain"><span class="math inline">\(\DEF\)</span> Chain 链</h3>
<p>Say that a collection <span class="math inline">\(C\)</span> of sets
is a <em>chain</em> iff for any elements <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> of <span class="math inline">\(C\)</span>, either <span class="math inline">\(x
\subseteq y\)</span> or <span class="math inline">\(y \subseteq
x\)</span>.</p>
<p>(From wikipedia) In general, a chain is a <a href="#TotalOrdering">totally ordered</a> subset of a <a href="#PartialOrdering">partially ordered</a> set.</p>
<h3 id="ZornLemma">Zorn's Lemma<span class="math inline">\(_*\)</span></h3>
<p>Let A be a set such that for any <a href="#Chain">chain</a> <span class="math inline">\(C \subseteq A\)</span>, the set <span class="math inline">\(\bigcap C\)</span> is in <span class="math inline">\(A\)</span>. Then there is some element <span class="math inline">\(m \in A\)</span> which is maximal in the sense
that it is not a subset of any other element of <span class="math inline">\(A\)</span>.</p>
<p>(From wikipedia) A partially ordered set containing upper bounds for
every <a href="#Chain">chain</a> (that is, every totally ordered subset)
necessarily contains at least one maximal element.</p>
<h3 id="Equinumerous"><span class="math inline">\(\DEF\)</span>
Equinumerous 等势的</h3>
<p>Say that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equinumerous</em> (written
<span class="math inline">\(A \sim B\)</span>) iff there is a <a href="#OneToOne">one-to-one</a> function mapping <span class="math inline">\(A\)</span> <a href="#MapOnto">onto</a> <span class="math inline">\(B\)</span>.</p>
<h3 id="CardinalNumber">Cardinal Number 基数</h3>
<p>To each set A we can assign a certain object, the <em>cardinal
number</em> (or <em>cardinality</em>) of <span class="math inline">\(A\)</span> (written card <span class="math inline">\(A\)</span>), in such a way that two sets are
asigned the same cardinality iff they are <a href="#Equinumerous">equinumerous</a>: <span class="math display">\[
\text{card}\; A = \text{card}\; B\quad\text{iff}\quad A \sim B
\]</span></p>
<p>点击<a href="/edd6b774">这里进入目录</a></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 1.7</title>
    <url>//78799e4f/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是Chapter 1, Section 1.7, 介绍能行性, 可判定性和可计算性</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<h2 id="chapter-one.-sentential-logic-命题逻辑">Chapter One. Sentential
Logic 命题逻辑 <span id="Chapter1"></span></h2>
<h3 id="compactness-and-effectiveness-紧致性和能行性">1.7 Compactness
and Effectiveness 紧致性和能行性 <span id="Section1.7"></span></h3>
<h4 id="comactness-紧致性">Comactness 紧致性</h4>
<h5 id="compactness-theorem-紧致性定理">Compactness Theorem
紧致性定理</h5>
<p>A set of <a href="/5a484d90#wff">wffs</a> is <a href="/5a484d90#Satisfy">satisfiable</a> iff every <a href="/48e9c4af#FiniteSet">finite</a> <a href="/48e9c4af#Subset">subset</a> is satisfiable.</p>
<h5 id="def-finitely-satisfiable-有限可满足"><span class="math inline">\(\DEF\)</span> Finitely Satisfiable 有限可满足
<span id="FinitelySatisfiable"></span></h5>
<p>We say that <span class="math inline">\(\Sigma\)</span> is
<em>finitely satisfiable</em> iff every <a href="/48e9c4af#FiniteSet">finite</a> <a href="/48e9c4af#Subset">subset</a> of <span class="math inline">\(\sigma\)</span> is satisfiable.</p>
<h5 id="corollary-17a">Corollary 17A <span id="Corollary17A"></span></h5>
<p>If <span class="math inline">\(\Sigma\vDash\tau\)</span>, then there
is a finite <span class="math inline">\(\Sigma_0\subseteq\Sigma\)</span>
such that <span class="math inline">\(\Sigma_0\vDash\tau\)</span>.</p>
<h4 id="effectiveness-and-computability-能行性和可计算性">Effectiveness
and Computability 能行性和可计算性</h4>
<h5 id="defi-effective-procedure-能行的程序"><span class="math inline">\(\DEFi\)</span> effective procedure 能行的程序
<span id="Effective"></span></h5>
<ol type="1">
<li>There must be exact <strong>finite instructions</strong>(i.e. a
program) explaining how the execute the procedure.</li>
<li>The instructions must be <strong>mechanically implemented</strong>.
They must not demand any brilliance or originality. The procedure must
avoid random devices or any such device that can, in practice, only be
approximated.</li>
<li>The procedure must be an algorithm for <strong>determining the
answer</strong>. The procedure produces a "yes" or "no" answer.</li>
</ol>
<h5 id="theorem-17b">Theorem 17B<span class="math inline">\(^*\)</span>
<span id="Theorem17B"></span></h5>
<p>There is an <a href="#Effective">effective</a> procedure that, give
any <a href="/5a484d90#Expression">expression</a> <span class="math inline">\(\varepsilon\)</span>, will decide whether or not
it is a <a href="/5a484d90#wff">wff</a>.</p>
<h5 id="defi-decidable-可判定的"><span class="math inline">\(\DEFi\)</span> Decidable 可判定的
<span id="Decidable"></span></h5>
<p>A set <span class="math inline">\(\Sigma\)</span> of <a href="/5a484d90#Expression">expression</a> is <em>decidable</em> iff
there exists an <a href="#Effective">effective</a> procedure that, given
an expression <span class="math inline">\(\alpha\)</span>, will decide
whether or not <span class="math inline">\(\alpha \in
\Sigma\)</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
可判定主语是集合, 即一个集合是可判定的,
当且仅当有一个能行的程序决定某一个元素是否属于该集合. </font></p>
</div>
<h5 id="theorem-17c">Theorem 17C<span class="math inline">\(^*\)</span>
<span id="Theorem17C"></span></h5>
<p>There is an effective procedure that, given a finite set <a href="/48e9c4af#Adjoin"><span class="math inline">\(\Sigma;\tau\)</span></a> of <a href="/5a484d90#wff">wffs</a>, will decide whether or not <span class="math inline">\(\Sigma\vDash\tau\)</span></p>
<h5 id="corollary-17d">Corollary 17D<span class="math inline">\(^*\)</span> <span id="Corollary17D"></span></h5>
<p>For a finite set <span class="math inline">\(\Sigma\)</span>, the set
of <a href="/5a484d90#Tautology">tautological</a> consequences of <span class="math inline">\(\Sigma\)</span> is <a href="#Decidable">decidable</a>. In particular, the set of tautologies
is decidable.</p>
<h5 id="defi-effectively-enumerable-能行可枚举"><span class="math inline">\(\DEFi\)</span> Effectively Enumerable 能行可枚举
<span id="EffectivelyEnumerable"></span></h5>
<p>Say that a set <span class="math inline">\(A\)</span> of <a href="/5a484d90#Expression">expressions</a> is <em>effectively
enumerable</em> iff there exists an <a href="#Effective">effective
procedure</a> that lists, in some order, the members of <span class="math inline">\(A\)</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
能行可枚举的主语是集合, 即一个集合是能行可枚举的,
当且仅当有一个能行的程序能狗列出(枚举出)该集合所有的元素. </font></p>
</div>
<h5 id="defi-semidecidable-半可判定的"><span class="math inline">\(\DEFi\)</span> Semidecidable 半可判定的
<span id="Semidecidable"></span></h5>
<p>A set A of expressions is <em>Semidecidable</em> iff there exists an
<a href="#Effective">effective procedure</a> that, given any <a href="/5a484d90#Expression">expression</a> <span class="math inline">\(\varepsilon\)</span>, procedures the answer yes
iff <span class="math inline">\(\varepsilon\in A\)</span>.</p>
<p>If <span class="math inline">\(\varepsilon\notin A\)</span>,
procedure might produce the answer "no"; more likely it will go on
forever without producing any answer, but it must not lie to use and
produce the answer "yes".</p>
<h5 id="theorem-17e">Theorem 17E<span class="math inline">\(^*\)</span>
<span id="Theorem17E"></span></h5>
<p>A set is effectively enumerable iff it is <a href="#Semidecidable">semidecidable</a>.</p>
<h5 id="theorem-17f">Theorem 17F<span class="math inline">\(^*\)</span>
<span id="Theorem17F"></span></h5>
<p>A set of expressions is <a href="#Decidable">decidable</a> iff both
it and its complement (relative to the set of all expressions) are <a href="EffectivelyEnumerable">effectively enumerable</a>. This sometimes
called "Kleene's theorem."</p>
<h5 id="theorem-17g">Theorem 17G<span class="math inline">\(^*\)</span>
<span id="Theorem17G"></span></h5>
<p>If <span class="math inline">\(\Sigma\)</span> is <a href="#Decidable">decidable</a> set of wffs, then the set of <a href="/5a484d90#Tautology">tautological</a> consequences of <span class="math inline">\(\Sigma\)</span> is <a href="#EffectivelyEnumerable">effectively enumerable</a>.</p>
<h5 id="defi-effectively-computable-能行可计算的"><span class="math inline">\(\DEFi\)</span> Effectively Computable 能行可计算的
<span id="Computable"></span></h5>
<p>We will say that a <a href="/48e9c4af#Function">function</a> <span class="math inline">\(f\)</span> is <em>effectively computable</em> (or
simply <em>computable</em>) iff there exists an <a href="#Effective">effective procedure</a> that given an input <span class="math inline">\(x\)</span>, will eventually produce the correct
output <span class="math inline">\(f(x)\)</span>.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
能行可计算主语是函数. </font></p>
</div>
<h4 id="exercises-1.7">Exercises 1.7 <span id="Exercises1.7"></span></h4>
<h5 id="problem-1">Problem 1 <span id="Problem1.7-1"></span></h5>
<ol type="1">
<li>Assume that every finite subset of <span class="math inline">\(\Sigma\)</span> is satisfiable. Show that the same
is true of at least one of the sets <span class="math inline">\(\Sigma;\alpha\)</span> and <span class="math inline">\(\Sigma;\lnot\alpha\)</span>. (This is part of the
proof of the compactness theorem.)</li>
</ol>
<p>证明:</p>
<p>假设有两个有限子集<span class="math inline">\(\Sigma_1\subseteq\Sigma\)</span>和<span class="math inline">\(\Sigma_2\subseteq\Sigma\)</span>, 再假设<span class="math inline">\(\Sigma_1;\alpha\)</span>和<span class="math inline">\(\Sigma_2;\lnot\alpha\)</span>都是不可满足的.</p>
<p>那么考虑<span class="math inline">\(\Sigma&#39;=\Sigma_1\cup\Sigma_2\subseteq\Sigma\)</span>,
<span class="math inline">\(\Sigma&#39;\)</span>也是<span class="math inline">\(\Sigma\)</span>的有限子集.
则必然存在一个真值分配<span class="math inline">\(v\)</span>能够满足<span class="math inline">\(\Sigma&#39;\)</span>, 那么</p>
<p>或者<span class="math inline">\(\overline{v}(\alpha)=T\)</span>,
从而<span class="math inline">\(v\)</span>能够满足<span class="math inline">\(\Sigma;\alpha\)</span></p>
<p>或者<span class="math inline">\(\overline{v}(\lnot\alpha)=T\)</span>,
从而<span class="math inline">\(v\)</span>能够满足<span class="math inline">\(\Sigma;\lnot\alpha\)</span></p>
<p>这就产生了矛盾. 所以 <span class="math inline">\(\blacksquare\)</span></p>
<h5 id="problem-2">Problem 2 <span id="Problem1.7-2"></span></h5>
<ol start="2" type="1">
<li>Let <span class="math inline">\(\Delta\)</span> be a sets of wffs
such that (i) every finite subset of <span class="math inline">\(\Delta\)</span> is satisfiable, and (ii) for every
wff <span class="math inline">\(\alpha\)</span>, either <span class="math inline">\(\alpha\in\Delta\)</span> or <span class="math inline">\((\lnot\alpha)\in\Delta\)</span>. Define the truth
assignment <span class="math inline">\(v\)</span>: <span class="math display">\[
v(A)=\left\{
\begin{array}{l}
T\qquad\text{iff}\quad A\in\Delta\\
F\qquad\text{iff}\quad A\notin\Delta
\end{array}
\right.
\]</span> for each sentence symbol <span class="math inline">\(A\)</span>. Show that for every wff <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\overline{v}(\phi)=T\)</span> iff <span class="math inline">\(\phi\in\Delta\)</span>.</li>
</ol>
<p>证明:</p>
<p>若一个合式公式<span class="math inline">\(\phi\)</span>, 满足<span class="math inline">\(\overline{v}(\phi)=T\)</span>当且仅当<span class="math inline">\(\phi\in\Delta\)</span>,
我们称这个合式公式是成立的.</p>
<p>应用数学归纳法.</p>
<p>对于任取的<a href="#SentenceSymbol">命题符号(sentence
symbols)</a><span class="math inline">\(\forall A\)</span>, 根据<a href="/5a484d90#overlinev"><span class="math inline">\(\overline{v}\)</span>的定义</a>,<span class="math inline">\(\overline{v}(A)=v(A)\)</span>, 显然满足<span class="math inline">\(\overline{v}(A)=T\)</span> 当且仅当 <span class="math inline">\(A\in\Delta\)</span>,
所以所有的命题符号都是成立的.</p>
<p>只需要证明若对于两个成立的合式公式 <span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>,
那么下面5个由这两个合式公式构造的合式公式: <span class="math display">\[
\matrix{
    \varepsilon_\lnot(\alpha) = (\lnot\alpha)\cr
    \varepsilon_\land(\alpha,\beta) = (\alpha\land\beta)\cr
    \varepsilon_\lor(\alpha,\beta) = (\alpha\lor\beta)\cr
    \varepsilon_\rightarrow(\alpha,\beta) = (\alpha\rightarrow\beta)\cr
    \varepsilon_\leftrightarrow(\alpha,\beta) =
(\alpha\leftrightarrow\beta)
}
\]</span> 也同样是成立的, 根据归纳原理, 所有的合式公式都是成立的.</p>
<p>首先考察<span class="math inline">\(\lnot\alpha\)</span>.</p>
<ol type="1">
<li>根据<a href="/5a484d90#overlinev"><span class="math inline">\(\overline{v}\)</span>的定义</a>, <span class="math inline">\(\overline{v}(\lnot\alpha)=T\)</span>当且仅当<span class="math inline">\(\overline{v}(\alpha)=F\)</span>.</li>
<li>因为<span class="math inline">\(\alpha\)</span>是成立的, 所以<span class="math inline">\(\overline{v}(\alpha)=F\)</span>当且仅当<span class="math inline">\(\alpha\notin\Delta\)</span>.</li>
<li>根据条件{ii}, <span class="math inline">\(\alpha\notin\Delta\)</span>当且仅当<span class="math inline">\((\lnot\alpha)\in\Delta\)</span></li>
</ol>
<p>所以<span class="math inline">\(\overline{v}(\lnot\alpha)=T\)</span>当且仅当<span class="math inline">\((\lnot\alpha)\in\Delta\)</span>, 因为<span class="math inline">\(\lnot\alpha\)</span>也是成立的.</p>
<p>现在考察双元构造的合式公式<span class="math inline">\(\alpha\boxdot\beta\)</span>, 其中<span class="math inline">\(\boxdot\in\{\land,\lor,\rightarrow,\leftrightarrow\}\)</span>
由于条件(ii)我们可以定义<span class="math inline">\(\lnot?\alpha\)</span>是<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\lnot\alpha\)</span>中在<span class="math inline">\(\Delta\)</span>中的那个, 同样可以定义<span class="math inline">\(\lnot?\beta\)</span>和<span class="math inline">\(\lnot?(\alpha\boxdot\beta)\)</span>.</p>
<p>根据这个定义, 集合<span class="math inline">\(\{\lnot?\alpha,
\lnot?\beta, \lnot?(\alpha\boxdot\beta)\}\subseteq\Delta\)</span>.
根据条件(i), 这个集合是可满足的.</p>
<p>根据<a href="/5a484d90#overlinev"><span class="math inline">\(\overline{v}\)</span>的定义</a>,
对于任意的真值分配<span class="math inline">\(u\)</span>, <span class="math inline">\(\overline{u}(\lnot?(\alpha\boxdot\beta))\)</span>的真值由<span class="math inline">\(\overline{u}(\alpha)\)</span>和<span class="math inline">\(\overline{u}(\beta)\)</span>决定的. 而<span class="math inline">\(\overline{u}(\alpha)\)</span>和<span class="math inline">\(\overline{u}(\beta)\)</span>又是由<span class="math inline">\(\overline{u}(\lnot?\alpha)\)</span>和<span class="math inline">\(\overline{u}(\lnot?\beta)\)</span>决定的.
所以我们得到一个结论:</p>
<p><span class="math display">\[
\begin{align}
\overline{u}(\lnot?\alpha)和\overline{u}(\lnot?\beta)的真值,
可以唯一决定\overline{u}(\lnot?(\alpha\boxdot\beta))的真值.\tag{$\dagger$}
\end{align}
\]</span></p>
<p>由于前面说的集合是可满足的, 所以</p>
<p><span class="math display">\[
\begin{align}
\exists一个真值分配能够在满足\{\lnot?\alpha, \lnot?\beta\}的同时,
也满足\lnot?(\alpha\boxdot\beta) \tag{$\ddagger$}
\end{align}
\]</span></p>
<p>那么综合<span class="math inline">\((\dagger)\)</span>和<span class="math inline">\((\ddagger)\)</span>, <span class="math inline">\(\forall\)</span>真值分配, 只要其满足<span class="math inline">\(\{\lnot?\alpha, \lnot?\beta\}\)</span>,
就一定满足<span class="math inline">\(\overline{u}(\lnot?(\alpha\boxdot\beta))\)</span>.</p>
<p>本题中的真值分配<span class="math inline">\(v\)</span>,
根据前面对<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>的假设, 已知<span class="math inline">\(\overline{v}(\lnot?\alpha)=T\)</span>和<span class="math inline">\(\overline{v}(\lnot?\beta)=T\)</span>,
所以一定有<span class="math inline">\(\overline{v}(\lnot?(\alpha\boxdot\beta))=T\)</span>.
因而有:</p>
<ul>
<li>或者当<span class="math inline">\((\alpha\boxdot\beta)\in\Delta\)</span>, 有<span class="math inline">\(\overline{v}(\alpha\boxdot\beta)=T\)</span></li>
<li>或者当<span class="math inline">\(\lnot(\alpha\boxdot\beta)\in\Delta\)</span>,
有<span class="math inline">\(\overline{v}(\lnot(\alpha\boxdot\beta))=T\)</span>.
根据<span class="math inline">\(\overline{v}(\lnot\alpha)\)</span>的定义, <span class="math inline">\(\overline{v}(\alpha\boxdot\beta)=F\)</span>.</li>
</ul>
<p>换句话说<span class="math inline">\(\overline{v}(\alpha\boxdot\beta)=T\)</span>当且仅当<span class="math inline">\((\alpha\boxdot\beta)\in\Delta\)</span>, 即<span class="math inline">\(\alpha\boxdot\beta\)</span>是成立的. 正毕 <span class="math inline">\(\blacksquare\)</span></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Introduction</title>
    <url>//f4228e25/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是引言(Introduction), 讲述了符号逻辑的概念,
以及提纲挈领的描述一下本书关心的关于符号逻辑的主要问题.</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<p>本书中, 一般用Symbolic Logic即符号逻辑这个词, 跟数理逻辑(Mathematical
Logic)的概念无区别.</p>
<p><span class="math inline">\(\DEFi\)</span><strong>Mathematical
Model(数学模型)<span id="MathematicalModel"></span></strong>是对真实世界上的对象的数学抽象.
选取被研究的真实世界中的对象的某些特性, 用数学模型表达,
而其他特性则被忽略. 使得被建立的数学模型的行为在某些方面(本质的,
被关注的)跟远对象很像, 但其他方面(无关的)又不像.
模型是否符合它意欲达成的目的是依赖于选取原对象那些特征来用模型表达.
例如概率论是真实世界的不确定性的数学模型.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
这个解释及其易懂. 自然数最初是"计数"这个现实需求的数学模型,
欧氏几何就是真实世界的对象的各种形状的数学模型,
拓扑学最初则是忽略形状和大小而只考虑真实世界对象相对位置的一种数学模型.
</font></p>
</div>
<p><span class="math inline">\(\DEFi\)</span><strong>符号逻辑<span id="SymbolicLogic"></span></strong>最初是一种演绎思维(deductive
thought)的<a href="#MathematicalModel">数学模型</a>.
但跟数学其他分支一样, 它已经自我生长,
现在远远超出了它诞生之初的环境.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span></p>
<ol type="1">
<li><font face="楷体">演绎逻辑这个真实世界里的研究对象也是一个比较抽象的对象.
用自然语言对这个对象进行研究就是形式逻辑.
而通过数学建模对其研究就是符号逻辑.</font></li>
<li><font face="楷体"> 一旦模型建立,
数学家可以根据模型的符号系统做各种跟真实世界无关的研究,
最后的研究成果有可能反过来让人们发现真实世界对象的新的特征和规律.
当然也有可能对真实世界没有任何用(或暂时没发现有任何用). </font></li>
</ol>
</div>
<p>通过对真实世界的自然语言表达的逻辑正确的研究, 一个原则被发现:
演绎(deduction)的逻辑正确性取决于演绎的形式而不是演绎的内容.
这个表述是模糊的, 正是这种模糊性激励我们找到一种<a href="#MathematicalModel">数学模型</a>.
这种数学模型的一个主要目标就是给出这个原则的一个精确的版本.
我们最初最关心的关于这个数学模型的问题包括:</p>
<ol type="1">
<li><span id="Q1"></span> What does it mean for one sentence to "follow
logically" from certain others?
什么叫一个命题可以从其他命题"逻辑推出"?</li>
<li><span id="Q2"></span> If a sentence does follow logically from
certain others, what methods of <em>proof</em> might be necessary to
establish this fact? 如果一个命题可以从其他命题逻辑推出是一个事实(fact),
为了建立这个事实, 什么样的证明的方法是必须的?</li>
<li><span id="Q3"></span> Is there a gap between what we can prove in an
axiomatic system(say for the natural numbers) and what is <em>true</em>
about the natural numbers? 以下两种命题是否有区别? a)
那些我们可以在一个公理系统(比如说自然数的公里系统)里证明的命题,
b)关于自然数是"真"的命题</li>
<li><span id="Q4"></span> What is the connection between logic and
computability? 逻辑和可计算性有什么联系.</li>
</ol>
<p>本书事实上给出了两个模型, 命题逻辑(sentential
logic)和一阶逻辑(first-order logic).
前者对真实世界的演绎的那部分简略的(crude)特征的抽象,
因而不足以回答上述所有我们感兴趣的有关演绎的问题.
后者则极好的符合在数学中碰到的所有演绎.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span></p>
<ol type="1">
<li><font face="楷体">看了大半的书, 再回过头来看这个序言,
才感觉自己真正能读懂了.</font></li>
<li><font face="楷体">关于术语的选择对于阅读体验非常重要,
关键性术语应该尽量选择那些跟平时用语有区别的词.
比如英文sentence在这本书的中文版里有些地方被翻译成"命题",
但有些地方(一阶逻辑部分)被翻译成"句子".
明显"命题"是更好的翻译(我怀疑这两个章节不是一个人翻译的).
读到"句子"的时候往往很困惑. 英文其实用sentence不如用proposition,
估计母语是英语的人最初读到sentence的时候也会困惑.
这个笔记里把deduction翻译成"演绎"而不是"推论"或"推理"也是因为这个原因.
</font></li>
<li><font face="楷体">命题逻辑虽然不足以表现数学上有关演绎思想的所有问题,
但实际上是计算机科学的数学基础.</font></li>
</ol>
</div>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Table of Contents</title>
    <url>//edd6b774/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\Indent{\quad\quad}\)</span>
这是一个关于数理逻辑的读书笔记或者学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<span id="more"></span>
<ul>
<li><a href="/f4228e25">Introduction</a></li>
<li><a href="/48e9c4af#Chapter0">Chapter Zero. Useful Facts about
Sets</a></li>
<li><details>
<summary>
<a href="/5a484d90#Chapter1">Chapter One. Sentential Logic</a>
</summary>
<ul>
<li><a href="/5a484d90#Section1.1">Section 1.1 The language of
Sentential Logic</a></li>
<li><a href="/5a484d90#Section1.2">Section 1.2 Truth
Assignments</a></li>
<li><a href="/e170cff5/">Section 1.4 Induction and Recursion</a></li>
<li><a href="/78799e4f#Section1.7">Section 1.7 Compactness and
Effectiveness</a></li>
</ul>
</details></li>
<li><details>
<summary>
<a href="/1eec0e97#Chapter2">Chapter Two. First-Order Logic</a>
</summary>
<ul>
<li><a href="/1eec0e97#Section2.1">Section 2.1 First-Order
Language</a></li>
<li><a href="/a55d499#Section2.2">Section 2.2 Truth and Models</a>
<ul>
<li><details>
<summary>
Section 2.2: Exercises
</summary>
<ul>
<li><a href="/2afc7010">Section 2.2: Problem 1 Solution</a></li>
</ul>
</details></li>
</ul></li>
<li><a href="/e33671ac">Section 2.4 Deductive Calculus</a></li>
</ul>
</details></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 1.4</title>
    <url>//e170cff5/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是Section 1.4,
内容是介绍归纳(Induction)和递归(Recursion)在命题逻辑这个<a href="/f4228e25/#MathematicalModel">数学模型</a>下的精确定义.</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<h2 id="induction-归纳">Induction 归纳 <span id="Induction"></span></h2>
<p>归纳在各个数学分支都在使用的构造方法. 通过对集合<span class="math inline">\(U\)</span>的某些初始元素重复使用几种运算,
可以构造<span class="math inline">\(U\)</span>的一个子集.
这个子集是包含初始元素并且对相应运算是封闭的最小集合.</p>
<p>本节的符号:</p>
<ul>
<li><span class="math inline">\(U\)</span>我们关心的对象的全集.<span id="induction-U"></span></li>
<li>用符号<span class="math inline">\(B\)</span>表示这些初始元素组成的集合.<span id="induction-B"></span></li>
<li>符号<span class="math inline">\(C\)</span>表示这个构造出来的集合.<span id="induction-C"></span></li>
<li>符号<span class="math inline">\(\mathcal{F}\)</span>表示<span class="math inline">\(U\)</span>上n元<a href="/48e9c4af/#Operation">运算</a>的函数类(class).<span class="math inline">\(n\)</span>是正整数, n为1时代表一元运算.
事实上<span class="math inline">\(\mathcal{F}\)</span>可以是any set of
<a href="/48e9c4af/#Relation">relations</a> on <span class="math inline">\(U\)</span><span id="induction-F"></span></li>
<li><span class="math inline">\(S\)</span>是<span class="math inline">\(U\)</span>的一个子集.<span id="induction-S"></span></li>
</ul>
<p><span class="math inline">\(\DEF\)</span> <span class="math inline">\(S\)</span> is <strong>Inductive</strong>(<span class="math inline">\(S\)</span>是归纳的)<span id="inductive"> iff
<span class="math inline">\(B\subseteq S\)</span> and <span class="math inline">\(S\)</span> is <a href="/48e9c4af/#Closed">closed</a> under all <a href="/48e9c4af/#Operation">operations</a> in <span class="math inline">\(\mathcal{F}\)</span>.</span></p>
<p><span class="math inline">\(\DEF\)</span> <span class="math inline">\(C\)</span> is the set <strong>generated
from</strong><span id="generatefrom"> <span class="math inline">\(B\)</span> by the functions in <span class="math inline">\(\mathcal{F}\)</span>. <span class="math inline">\(C\)</span>是由初始集合<span class="math inline">\(B\)</span>通过<span class="math inline">\(\mathcal{F}\)</span>中的函数运算<strong>生成</strong>的集合</span></p>
<p>这个定义可以有两种自上而下和自下而上的等价的定义.</p>
<ul>
<li>From the top down: Let <span class="math inline">\(C^*\)</span> be
<a href="/48e9c4af/#Intersection">intersection</a> of all the <a href="#inductive">inductive</a> <a href="/48e9c4af/#Subset">subsets</a>
of <span class="math inline">\(U\)</span>.</li>
<li>From the bottom up: Let <span class="math inline">\(C_*\)</span>
contain the things that can be reached from B by applying operations in
<span class="math inline">\(\mathcal{F}\)</span> a finite number of
times. Temporarily define a <strong>construction sequence</strong> to be
a <a href="/48e9c4af/#String">finite sequence</a> <span class="math inline">\(\langle x_1,\ldots,x_n\rangle\)</span> of elements
of <span class="math inline">\(U\)</span> such that each member of the
sequence either is in <span class="math inline">\(B\)</span> or results
from earlier members by applying operations in <span class="math inline">\(\mathcal{F}\)</span>. Let <span class="math inline">\(C_n\)</span> be the set of points <span class="math inline">\(x\)</span> such that some construction sequence of
length n ends with <span class="math inline">\(x\)</span>. Then <span class="math inline">\(C_1=B\)</span>, <span class="math display">\[
C1\subseteq C2\subseteq C3\subseteq\cdots,
\]</span> Let <span class="math inline">\(C_*=\bigcup_n C_n\)</span>,
which means let <span class="math inline">\(C_*\)</span> be the set of
all points <span class="math inline">\(x\)</span> such that some
construction sequence ends with <span class="math inline">\(x\)</span>.</li>
</ul>
<p><span class="math inline">\(\sf{I\scriptsize{NDUCTION}}\enspace\sf{P\scriptsize{RINCIPLE}}\quad\)</span>(归纳原则)<span id="InductionPrinciple">
Assume that <span class="math inline">\(C\)</span> is the set <a href="#generatefrom">generated from</a> <span class="math inline">\(B\)</span> by the operations in <span class="math inline">\(\mathcal F\)</span>. If <span class="math inline">\(S\)</span> is a subset of <span class="math inline">\(C\)</span> that includes <span class="math inline">\(B\)</span> and is <a href="/48e9c4af/#Closed">closed</a> under the operations of <span class="math inline">\(\mathcal{F}\)</span> then <span class="math inline">\(S=C\)</span>.</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span>
<font face="楷体">归纳原则: <a href="#generatefrom">生成</a>集是最小的<a href="#inductive">归纳的</a>集合.</font></p>
</div>
<p><span class="math inline">\(\EXAMPLE\)</span>
通过归纳原则可以定义:</p>
<ol type="1">
<li>自然数
<ul>
<li><span class="math inline">\(U\)</span>: real numbers</li>
<li><span class="math inline">\(B\)</span>: <span class="math inline">\(\{0\}\)</span></li>
<li><span class="math inline">\(\mathcal{F}\)</span>: <span class="math inline">\({S}\)</span> where <span class="math inline">\(S(x)=x+1\)</span></li>
</ul></li>
<li>整数
<ul>
<li><span class="math inline">\(U\)</span>: real numbers</li>
<li><span class="math inline">\(B\)</span>: <span class="math inline">\(\{0\}\)</span></li>
<li><span class="math inline">\(\mathcal{F}\)</span>: <span class="math inline">\({S, P}\)</span> where <span class="math inline">\(S(x)=x+1\)</span> and <span class="math inline">\(P(x)=x-1\)</span></li>
</ul></li>
<li>The algebratic functions class:
<ul>
<li><span class="math inline">\(U\)</span>: all functions whose domain
and range are each sets of real numbers.</li>
<li><span class="math inline">\(B\)</span>: contain the <a href="\48e9c4af#IdentityFunction">identity function</a> and all constant
functions.</li>
<li><span class="math inline">\(\mathcal{F}\)</span>: contain the
operations of addition, multiplication, division, and root
extraction.</li>
</ul></li>
<li>The <a href="/5a484d90/#wff">well-formed formulas</a>
<ul>
<li><span class="math inline">\(U\)</span>: all expressions</li>
<li><span class="math inline">\(B\)</span>: the set of <a href="/5a484d90/#SentenceSymbol">sentence symbols</a>.</li>
<li><span class="math inline">\(\mathcal{F}\)</span>: contain the five
<a href="/5a484d90/#formula-building-operations">formula-building
operations</a> on expresssions: <span class="math inline">\(\mathcal{E}_\lnot, \mathcal{E}_\land,
\mathcal{E}_\lor, \mathcal{E}_\to, \text{and }
\mathcal{E}_\leftrightarrow\)</span></li>
</ul></li>
</ol>
<h2 id="recursion-递归">Recursion 递归 <span id="anchor"></span></h2>
<p><span class="math inline">\(\DEF\)</span> Say that <span class="math inline">\(C\)</span> is <strong>freely generated
from</strong> <span id="FreelyGenerate"> <span class="math inline">\(B\)</span> by operations in <span class="math inline">\(\mathcal{F}\)</span> iff in addition to the
requirements for being generated, the <a href="/48e9c4af/#Restriction">restrictions</a> <span class="math inline">\(f_C\)</span> of each <span class="math inline">\(f\)</span> in <span class="math inline">\(\mathcal{F}\)</span> to <span class="math inline">\(C\)</span> meet the following conditions:</span></p>
<ol type="1">
<li><span class="math inline">\(f_C\)</span> of each <span class="math inline">\(f\)</span> in <span class="math inline">\(\mathcal{F}\)</span> are <a href="/48e9c4af/#OneToOne">one-to-one</a></li>
<li>The range of <span class="math inline">\(f_C\)</span> of each <span class="math inline">\(f\)</span> in <span class="math inline">\(\mathcal{F}\)</span>, and the set <span class="math inline">\(B\)</span> are <a href="/48e9c4af/#PairwiseDisjoint">pairwise disjoint</a>.</li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
自由生成这个概念限制很强, 条件一意味着<span class="math inline">\(\mathcal{F}\)</span>中的运算对不同输入不能产生相同输出.
条件二意味着, 没有一个值能够通过两种或以上的运算得出,
初始集合里的值也不能通过运算得到. </font></p>
</div>
<h3 id="sfrscriptsizeecursionenspacesftscriptsizeheoremquad-递归定理"><span class="math inline">\(\sf{R\scriptsize{ECURSION}}\enspace\sf{T\scriptsize{HEOREM}}\quad\)</span>
递归定理<span id="RecursionTheorem"></span></h3>
<p>Assume that the subset <span class="math inline">\(C\)</span> of
<span class="math inline">\(U\)</span> is <a href="#FreelyGenerate">freely generated</a> from <span class="math inline">\(B\)</span> by <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span>, where <span class="math display">\[
\begin{align*}
f:U\times U&amp;\to U, \\
g:U&amp;\to U. \\
\end{align*}
\]</span> Further assume that <span class="math inline">\(V\)</span> is
a set and <span class="math inline">\(F\)</span>, <span class="math inline">\(G\)</span>, and h functions such that <span class="math display">\[
\begin{align*}
h:B&amp;\to V, \\
f:V\times V&amp;\to V, \\
g:V&amp;\to V. \\
\end{align*}
\]</span></p>
<p>Then there is a unique function <span class="math display">\[
\overline{h}:C\to V
\]</span> such that</p>
<ol type="i">
<li>For <span class="math inline">\(x\)</span> in <span class="math inline">\(B\)</span>, <span class="math inline">\(\overline{h}(x)=h(x);\)</span></li>
<li>For <span class="math inline">\(x,y\)</span> in <span class="math inline">\(C\)</span>, <span class="math display">\[
\begin{align*}
\overline{h}(f(x,y)) &amp;= F(\overline{h}(x),\overline{h}(y)), \\
\overline{h}(g(x)) &amp;= G(\overline{h}(x)), \\
\end{align*}
\]</span></li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span></p>
<p>递归定理本质上在讲, 若满足如下条件</p>
<ol type="1">
<li>由<span class="math inline">\(B\)</span>通过<span class="math inline">\(\mathcal{F}\)</span>能够<a href="#FreelyGenerate">自由生成</a>的<span class="math inline">\(C\)</span>.</li>
<li>如果两个集合<span class="math inline">\(U\)</span>和<span class="math inline">\(V\)</span>有结构相同的运算.</li>
<li><span class="math inline">\(U\)</span>的初始子集<span class="math inline">\(B\)</span>能通过<span class="math inline">\(h\)</span>映射到<span class="math inline">\(V\)</span>里</li>
</ol>
<p>那么一定能够把<span class="math inline">\(h\)</span>扩展成一个从<span class="math inline">\(C\)</span>到<span class="math inline">\(V\)</span>中的<a href="/a55d499/#Homomorphism">同态</a><span class="math inline">\(\overline{h}\)</span></p>
</div>
<p><span class="math inline">\(\EXAMPLE\)</span></p>
<ol type="1">
<li>自然数, <span class="math inline">\(B=\{0\}\)</span> with one
operation, the successor operation <span class="math inline">\(S\)</span>. Then <span class="math inline">\(C\)</span> is <a href="#FreelyGenerate">freely
generated</a> from {0} by <span class="math inline">\(S\)</span>.
因此根据<a href="#RecursionTheorem">递归定理</a>对于任意集合<span class="math inline">\(V\)</span>, 任何<span class="math inline">\(a \in
V\)</span>, 以及任何运算<span class="math inline">\(F:V\to V\)</span>.
一定有一个唯一的<span class="math inline">\(\overline{h}:\mathbb{N}\to
V\)</span>, 使得<span class="math inline">\(\overline{h}(0)=a\)</span>并且<span class="math inline">\(\overline{h}(S(x))=F(\overline{h}(x))\)</span>对每一个<span class="math inline">\(x\in\mathbb{N}\)</span>成立.</li>
<li>整数, 有successor和predecessor两个运算, 由于运算的值域有交集,
所以不是<a href="#FreelyGenerate">自由生成</a>的</li>
<li>The algebraic function, 也不是自由生成的.</li>
<li>The wffs, 是自由生成的.</li>
</ol>
<h3 id="sf-uscriptsizeniqueenspace-rscriptsizeeadabilityenspace-tscriptsizeheorem-唯一可读性定理"><span class="math inline">\({\sf U\scriptsize{NIQUE}\enspace
R\scriptsize{EADABILITY}\enspace T\scriptsize{HEOREM}}\)</span>
唯一可读性定理</h3>
<p>The set of wffs is <a href="#FreelyGenerate">freely generated</a>
from the set of <a href="/5a484d90/#SentenceSymbol">sentence symbols</a>
by the <a href="/5a484d90/#formula-building-operations">five
operations</a>.</p>
<p>有个唯一可读性定理和递归定理, 1.2节的真值分配的<a href="\5a484d90#Theorem12A">定理12A</a>不言自明.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
一旦命题符号的真值给定, 所有合式公式都有唯一的真值. </font></p>
</div>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 2.2 -- Problem 1 Solution</title>
    <url>//2afc7010/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize
ROOF}.\quad}\)</span></p>
<p>点击<a href="/edd6b774">这里进入AMIL目录</a></p>
<h5 id="Problem2.2-1">Problem 1</h5>
<p>Show that (a) <span class="math inline">\(\Gamma;\alpha\vDash\varphi\)</span> iff <span class="math inline">\(\Gamma\vDash(\alpha\rightarrow\varphi)\)</span>;
and (b) <span class="math inline">\(\varphi\tauequ\psi\)</span> iff
<span class="math inline">\(\vDash(\varphi\leftrightarrow\psi)\)</span>.</p>
<p><span class="math inline">\(\PROOF\)</span><cr></cr></p>
<span id="more"></span>
<p>(a)<cr> <span class="math display">\[
\begin{array}{lcll}
\Gamma;\alpha\vDash\varphi &amp; \Leftrightarrow &amp;
\forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma;\alpha\land\vDash_{\frak
A}\psi[s]\rightarrow\vDash_{\frak A}\varphi[s]) &amp;
(\text{   definition of }\href{/a55d499#LogicallyImply}{\text{logical
imply}}) \\
&amp; \Leftrightarrow &amp; \left\{\begin{array}{l}
                    \forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma\land\vDash_{\frak
A}\psi[s]\land\nvDash_{\frak A}\alpha[s]\rightarrow\vDash_{\frak
A}\varphi[s]) \\
                    \forall{\frak A}\forall{s}(\vDash_{\frak
A}\alpha[s]\rightarrow\vDash_{\frak A}\varphi[s])
                    \end{array}
                    \right. \\
&amp; \Leftrightarrow &amp; \forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma\land\vDash_{\frak
A}\psi[s]\rightarrow(\nvDash_{\frak A}\alpha[s]\lor\vDash_{\frak
A}\varphi[s]\lor(\vDash_{\frak A}\alpha[s]\land\vDash_{\frak
A}\varphi[s]))) \\
&amp; \Leftrightarrow &amp; \forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma\land\vDash_{\frak
A}\psi[s]\rightarrow\vDash_{\frak A}(\alpha\rightarrow\varphi)[s])
&amp;  (\text{   definition of }
\href{/a55d499#SatisfyConditionalSymbol}{\vDash_{\frak
A}(\alpha\rightarrow\varphi)[s]}) \\
&amp; \Leftrightarrow &amp; \Gamma\vDash(\alpha\rightarrow\varphi) &amp;
(\text{   definition of logical imply})
\end{array}
\]</span></cr></p>
<p>(b)<cr> <span class="math display">\[
\begin{array}{lcll}
\varphi\tauequ\psi &amp; \Leftrightarrow &amp;
\varphi\vDash\psi\land\psi\vDash\varphi \\
&amp; \Leftrightarrow &amp;
\vDash(\varphi\rightarrow\psi)\land\vDash(\psi\rightarrow\varphi) &amp;
(\text{according to (a)}) \\
&amp; \Leftrightarrow &amp; \forall{\frak A}\forall{s}(\vDash_{\frak
A}(\varphi\rightarrow\psi)[s]\land\vDash_{\frak
A}(\psi\rightarrow\varphi)[s]) \\
&amp; \Leftrightarrow &amp; \forall{\frak A}\forall{s}(\vDash_{\frak
A}(\varphi\rightarrow\psi\land\psi\rightarrow\varphi)[s]) \\
&amp; \Leftrightarrow &amp; \vDash(\varphi\leftrightarrow\psi)
\end{array}
\]</span></cr></p>
<p>点击<a href="/edd6b774">这里进入AMIL目录</a></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 1.1/1.2</title>
    <url>//5a484d90/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是Chapter 1, Section 1.1,和 1.2, 介绍命题逻辑的基本概念.</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<h2 id="chapter-one.-sentential-logic-命题逻辑">Chapter One. Sentential
Logic 命题逻辑 <span id="Chapter1"></span></h2>
<h3 id="section-1.1-the-language-of-sentential-logic-命题逻辑的语言">Section
1.1 The language of Sentential Logic 命题逻辑的语言
<span id="Section1.1"></span></h3>
<h4 id="def-symbol"><span class="math inline">\(\DEF\)</span> Symbol
<span id="Symbol"></span></h4>
<p>An pre-defined infinite sequence of distinct objects, and no one of
these symbols is a <a href="/48e9c4af#String">finite sequence</a> of
other symbols.</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 46%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Verbose name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((\)</span></td>
<td>left parenthesis</td>
<td>punctuation</td>
</tr>
<tr class="even">
<td><span class="math inline">\()\)</span></td>
<td>right parenthesis</td>
<td>punctuation</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\lnot\)</span></td>
<td>negation symbol 非</td>
<td>English: not</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\land\)</span></td>
<td>conjunction symbol 合取</td>
<td>English: and</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\lor\)</span></td>
<td>disjunction symbol 析取</td>
<td>English: or</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\to\)</span></td>
<td>conditional symbol 蕴涵</td>
<td>English: if __, then __</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\leftrightarrow\)</span></td>
<td>biconditoinal symbol 等价</td>
<td>English: if and only if</td>
</tr>
<tr class="even">
<td><span class="math inline">\(A_1\)</span></td>
<td>first sentence symbol</td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(A_2\)</span></td>
<td>second sentence symbol</td>
<td></td>
</tr>
<tr class="even">
<td>...</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(A_n\)</span></td>
<td>nth sentence symbol</td>
<td></td>
</tr>
<tr class="even">
<td>...</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><em>sentential connective
symbols</em><span id="SententialConnectiveSymbols"> : <span class="math inline">\(\lnot,\land,\lor,\to,\leftrightarrow\)</span>,
命题链接符号</span></p>
<p><em>logical symbols</em><span id="LogicalSymbol"> : The sentential
connective symbols, together with the parenthese. 逻辑符号</span></p>
<p><em>sentence symbols</em><span id="SentenceSymbol"> : parameters (or
nonlogical symbols), 命题符号, 参数, 或非逻辑符号.</span></p>
<h4 id="def-expression-表达式"><span class="math inline">\(\DEF\)</span>
Expression 表达式 <span id="Expression"></span></h4>
<p>An <em>expression</em> is a <a href="/48e9c4af#String">finite
sequence</a> of <a href="#Symbol">symbols</a>.</p>
<h4 id="def-well-formed-formulas-合式公式"><span class="math inline">\(\DEF\)</span> Well-formed Formulas 合式公式
<span id="wff"></span></h4>
<p>A <em>well-formed formula</em> (or simply <em>formula</em> or
<em>wff</em>) is an expression that can be built up from the sentence
symbols by applying some finite number of times the formula-building
operations<span id="formula-building-operations"> (on expression)
defined by the equations <span class="math display">\[
\matrix{
    \mathcal{E}_\lnot(\alpha) = (\lnot\alpha)\cr
    \mathcal{E}_\land(\alpha,\beta) = (\alpha\land\beta)\cr
    \mathcal{E}_\lor(\alpha,\beta) = (\alpha\lor\beta)\cr
    \mathcal{E}_\rightarrow(\alpha,\beta) = (\alpha\rightarrow\beta)\cr
    \mathcal{E}_\leftrightarrow(\alpha,\beta) =
(\alpha\leftrightarrow\beta)
}
\]</span></span></p>
<h3 id="section-1.2-truth-assignments">Section 1.2 Truth Assignments
<span id="Section1.2"></span></h3>
<h4 id="def-truth-values-真值"><span class="math inline">\(\DEF\)</span>
Truth Values 真值 <span id="TruthValue"></span></h4>
<p>A set of <em>truth values</em> consisting of two distinct points:
<span class="math display">\[
\begin{array}{l}
F,\quad\text{called falsity}, \cr
T,\quad\text{called truth},
\end{array}
\]</span></p>
<h4 id="def-truth-assignment-真值分配"><span class="math inline">\(\DEF\)</span> Truth Assignment 真值分配
<span id="TruthAssignment"></span></h4>
<p>A <em>truth assignement</em> <span class="math inline">\(v\)</span>
for a set <span class="math inline">\(S\)</span> of sentence symbols is
a function <span class="math display">\[
v:S \rightarrow \{F, T\}
\]</span> assigning either <a href="#TruthValue"><span class="math inline">\(T\)</span> or <span class="math inline">\(F\)</span></a> to each symbol in <span class="math inline">\(S\)</span>.</p>
<h4 id="theorem-12a">Theorem 12A <span id="Theorem12A"></span></h4>
<p>Let <span class="math inline">\(S\)</span> be a set of <a href="#SentenceSymbol">sentence symbols</a>, <span class="math inline">\(\overline{S}\)</span> be the set of wffs that can
be built up from <span class="math inline">\(S\)</span> by the five
formula-building operations.</p>
<p>For any <a href="#TruthAssignment">truth assignment</a> <span class="math inline">\(v\)</span> for a set <span class="math inline">\(S\)</span> there is a unique function <span class="math inline">\(\cssId{overlinev}{\overline{v}}:\overline{S}\to\{F,T\}\)</span>
meeting the below conditions 0-5.</p>
<ol start="0" type="1">
<li>For any <span class="math inline">\(A\in S,
\overline{v}(A)=v(A)\)</span>. (Thus <span class="math inline">\(\overline{v}\)</span> is an extension of <span class="math inline">\(v\)</span>.)</li>
</ol>
<p>For any <span class="math inline">\(\alpha,\beta\)</span> in <span class="math inline">\(\overline{S}\)</span>:</p>
<ol type="1">
<li><p><span class="math inline">\(\overline{v}\left(\boldsymbol(\lnot\alpha\boldsymbol)\right)=\left\{
\begin{array}{l} T\quad\text{if}\quad\overline{v}(\alpha)=F,\cr
F\quad\text{otherwise}. \end{array} \right.\)</span></p></li>
<li><p><span class="math inline">\(\overline{v}\left(\boldsymbol(\alpha\land\beta\boldsymbol)\right)=\left\{
\begin{array}{l}
T\quad\text{if}\quad\overline{v}(\alpha)=T\quad\text{and}\quad\overline{v}(\beta)=T,\cr
F\quad\text{otherwise}. \end{array} \right.\)</span></p></li>
<li><p><span class="math inline">\(\overline{v}\left(\boldsymbol(\alpha\lor\beta\boldsymbol)\right)=\left\{
\begin{array}{l}
T\quad\text{if}\quad\overline{v}(\alpha)=T\quad\text{or}\quad\overline{v}(\beta)=T\quad(\text{or
both}),\cr F\quad\text{otherwise}. \end{array} \right.\)</span></p></li>
<li><p><span class="math inline">\(\overline{v}\left(\boldsymbol(\alpha\to\beta\boldsymbol)\right)=\left\{
\begin{array}{l}
T\quad\text{if}\quad\overline{v}(\alpha)=T\quad\text{and}\quad\overline{v}(\beta)=F,\cr
F\quad\text{otherwise}. \end{array} \right.\)</span></p></li>
<li><p><span class="math inline">\(\overline{v}\left(\boldsymbol(\alpha\leftrightarrow\beta\boldsymbol)\right)=\left\{
\begin{array}{l}
T\quad\text{if}\quad\overline{v}(\alpha)=\overline{v}(\beta),\cr
F\quad\text{otherwise}. \end{array} \right.\)</span></p></li>
</ol>
<h4 id="def-satisfy-满足"><span class="math inline">\(\DEF\)</span>
Satisfy 满足 <span id="Satisfy"></span></h4>
<p>We say that a <a href="#TruthAssignment">truth assignment</a> <span class="math inline">\(v\)</span> <em>satisfies</em> <span class="math inline">\(\phi\)</span> iff <span class="math inline">\(\overline{v}(\phi)=T\)</span>.</p>
<h4 id="def-tautologically-imply-重言蕴涵"><span class="math inline">\(\DEF\)</span> Tautologically imply 重言蕴涵
<span id="TautologicallyImply"></span></h4>
<p><span class="math inline">\(\Sigma\)</span> Tautologically implies
<span class="math inline">\(\tau\)</span> (written <span class="math inline">\(\Sigma\vDash\tau)\)</span> iff every <a href="#TruthAssignment">truth assignment</a> for the <a href="Sentence">sentence</a> symbols in <span class="math inline">\(\Sigma\)</span> and <span class="math inline">\(\tau\)</span> that <a href="#Satisfy">satisfies</a> every member of <span class="math inline">\(\Sigma\)</span> also satisfies <span class="math inline">\(\tau\)</span>.</p>
<h4 id="def-tautology-重言式"><span class="math inline">\(\DEF\)</span>
Tautology 重言式 <span id="Tautology"></span></h4>
<p>We say that <span class="math inline">\(\tau\)</span> is a
<em>tautology</em> (written <span class="math inline">\(\vDash\tau\)</span>) iff every <a href="#TruthAssignment">truth assignment</a> (for the sentence symbols
in <span class="math inline">\(\tau\)</span>) satisfies <span class="math inline">\(\tau\)</span> (<a href="#TautologicallyImply"><span class="math inline">\(\varnothing\vDash\tau\)</span></a>).</p>
<h4 id="def-tautologically-equivalent-重言等价"><span class="math inline">\(\DEF\)</span> Tautologically Equivalent 重言等价
<span id="TautologicallyEquivalent"></span></h4>
<p>If <span class="math inline">\(\Sigma\)</span> is <a href="/48e9c4af#Singleton">singleton</a> <span class="math inline">\(\{\sigma\}\)</span>, then we write "<span class="math inline">\(\sigma\vDash\tau\)</span>" in place of "<a href="#TautologicallyImply"><span class="math inline">\(\{\sigma\}\vDash\tau\)</span></a>." If both <span class="math inline">\(\sigma\vDash\tau\)</span> and <span class="math inline">\(\tau\vDash\sigma\)</span>, then <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\tau\)</span> are said to be tautologically
equivalent (written <span class="math inline">\(\sigma\tauequ\tau\)</span>)</p>
<h4 id="def-a-list-of-tautologies-常用重言式列表"><span class="math inline">\(\DEF\)</span> A List of Tautologies 常用重言式列表
<span id="ListOfTautologies"></span></h4>
<ol type="1">
<li><p>Associative and commutative laws for <span class="math inline">\(\land, \lor, \leftrightarrow\)</span>
"析取,合取,和等价"的结合律和交换律</p></li>
<li><p>Distributive laws 分配率: <span class="math display">\[
\begin{array}{l}
((A\land(B\lor C))\leftrightarrow((A\land B)\lor(A\land C))).\cr
((A\lor(B\land C))\leftrightarrow((A\lor B)\land(A\lor C))).
\end{array}
\]</span></p></li>
<li><p>Negation 否定: <span class="math display">\[
\begin{array}{l}
((\lnot(\lnot A))\leftrightarrow A).\cr
((\lnot(A\to B))\leftrightarrow (A\land(\lnot B))).\cr
((\lnot(A\leftrightarrow B))\leftrightarrow ((A\land(\lnot
B))\lor((\lnot A)\land B))).
\end{array}
\]</span></p></li>
</ol>
<p>De Morgan's laws 摩尔定律: <span class="math display">\[
\begin{array}{l}
((\lnot(A\land B))\leftrightarrow ((\lnot A)\lor(\lnot B))).\cr
((\lnot(A\lor B))\leftrightarrow ((\lnot A)\land(\lnot B))).
\end{array}
\]</span></p>
<ol start="4" type="1">
<li>Other</li>
</ol>
<ul>
<li>Excluded middle 排中律: <span class="math inline">\((A\lor(\lnot
A))\)</span></li>
<li>Contradiction 矛盾律: <span class="math inline">\((\lnot(A\land(\lnot A)))\)</span></li>
<li>Contraposition 逆否律: <span class="math inline">\(((A\to
B)\leftrightarrow((\lnot B)\to(\lnot A)))\)</span></li>
<li>Exportation 输出律: <span class="math inline">\((((A\land B)\to
C)\leftrightarrow(A\to(B\to C)))\)</span></li>
</ul>
<p>点击<a href="/edd6b774">这里进入AMIL目录</a></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 2.1</title>
    <url>//1eec0e97/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是Chapter 2, Section 2.1, 介绍一阶逻辑的基本概念</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<h2 id="chapter-two.-first-order-logic-一阶逻辑">Chapter Two.
First-Order Logic 一阶逻辑 <span id="Chapter2"></span></h2>
<h3 id="section-2.1-first-order-language-一阶语言">Section 2.1
First-Order Language 一阶语言 <span id="Section2.1"></span></h3>
<h4 id="def-symbol-符号"><span class="math inline">\(\DEF\)</span>
Symbol 符号 <span id="FirstOrderSymbol"></span></h4>
<p>A. Logical symbols 逻辑符号<span id="FirstOrderLogicalSymbol"></span></p>
<ol start="0" type="1">
<li>Parentheses 括号: <span class="math inline">\((\)</span>,<span class="math inline">\()\)</span>.</li>
<li>Sentential connective symbols
命题链接符号<span id="FirstOrderConnectiveSymbols">: <span class="math inline">\(\rightarrow\)</span>, <span class="math inline">\(\lnot\)</span>.</span></li>
<li>Variables 变量<span id="FirstOrderVariable">(one for each positive
integer <span class="math inline">\(n\)</span>); <span class="math display">\[v_1, v_2, \ldots.\]</span></span></li>
<li>Equality symbol 等于符号(optional): <span class="math inline">\(=\)</span>.</li>
</ol>
<p>B. Parameters 参数<span id="FirstOrderParameter"></span></p>
<ol start="0" type="1">
<li>Quantifier symbol 量词符号<span id="Quantifier">: <span class="math inline">\(\forall\)</span>.</span></li>
<li>Predicate symbols 谓词符号<span id="PredicateSymbol">: For each
positive integer <span class="math inline">\(n\)</span>, some
set(posibly empty) of symbols, called <span class="math inline">\(n\)</span>-place predicate symbols.</span></li>
<li>Constant symbols 常量符号<span id="FirstOrderConstantSymbol">: some
set(possibly empty) of symbols.</span></li>
<li>Function symbols 函数符号<span id="FirstOrderFunctionSymbol">: For
each positive integer <span class="math inline">\(n\)</span>, some
set(possibly empty) of symbols, called <a href="/48e9c4af#Function">n-place function</a> symbols.</span></li>
</ol>
<p><strong>等于符号</strong>是特殊的二元谓词符号,
分类到逻辑符号里而不是参数里是因为这会影响到它在自然语言中的翻译的方式.</p>
<p><strong>常量符号</strong>也可以叫0元函数符号.</p>
<p><strong><span class="math inline">\(n\)</span>元谓词符号</strong>
可以翻译成自然语言的一个谓词, 可以映射为<span class="math inline">\(n\)</span>元<a href="/48e9c4af#Relation">关系</a></p>
<p>具体到一种一阶语言, 一定要指明两点:</p>
<ol type="1">
<li>等于符号是否出现.</li>
<li><a href="#FirstOrderParameter">参数</a>有哪些.</li>
</ol>
<p>一阶语言的例子:</p>
<ol type="1">
<li>纯谓词(pure predicate)语言:</li>
</ol>
<ul>
<li>Equality: No.</li>
<li><span class="math inline">\(n\)</span>-place predicate symbols:
<span class="math inline">\(A^n_1, A^n_2,\ldots.\)</span></li>
<li>Constant symbols: <span class="math inline">\(a_1, a_2,
\ldots.\)</span></li>
<li><a href="/48e9c4af#Function"><span class="math inline">\(n\)</span>-place function</a> symbols: None.</li>
</ul>
<ol start="2" type="1">
<li>集合论(set theory)语言:</li>
</ol>
<ul>
<li>Equality: Yes(usually).</li>
<li>Predicate parameterts: One 2-place predicate symbol <span class="math inline">\(\in\)</span></li>
<li>function symbols: None(or occasionally a constant symbol <span class="math inline">\(\varnothing\)</span>).</li>
</ul>
<ol start="3" type="1">
<li>初等数论(elementary number theory)语言:</li>
</ol>
<ul>
<li>Equality: Yes.</li>
<li>Predicate parameterts: One 2-place predicate symbol <span class="math inline">\(&lt;\)</span></li>
<li>function symbols: The symbol <span class="math inline">\(0\)</span>.</li>
<li>1-place function symbols: <span class="math inline">\(S\)</span>
(for successor).</li>
<li>2-place function symbols: <span class="math inline">\(+\)</span>
(for addition), <span class="math inline">\(\cdot\)</span>(for
multiplication), and <span class="math inline">\(E\)</span> (for
exponentiation)</li>
</ul>
<p><cr></cr></p>
<p>一个被广泛认同的观点是数学可以嵌入到集合论中, 也就是说:</p>
<ol type="1">
<li>数学中的陈述可以被集合论语言表述.</li>
<li>数学的定理, 可以从集合论的公理按照逻辑推导出来.</li>
</ol>
<p>Two patterns:</p>
<ol type="1">
<li>An English sentence which asserts that everything in a certain
category has some property is translated: <span class="math display">\[\forall v(\_\rightarrow\_)\]</span></li>
<li>A sentence which asserts that there is some object or objects in the
category and having the property is translated <span class="math display">\[\exists v(\_\land\_)\]</span></li>
</ol>
<h4 id="def-expression-表达式"><span class="math inline">\(\DEF\)</span>
Expression 表达式 <span id="FirstOrderExpression"></span></h4>
<p>An <em>expression</em> is any finite sequence of <a href="#FirstOrderSymbol">symbols</a>.</p>
<h4 id="def-term-项"><span class="math inline">\(\DEF\)</span> Term 项
<span id="Term"></span></h4>
<p>If we define for each <a href="/48e9c4af#Function"><span class="math inline">\(n\)</span>-place function</a> symbol <span class="math inline">\(f\)</span>, an <span class="math inline">\(n\)</span>-place term-building operation <span class="math inline">\(\cal{F}_f\)</span> on expressions: <span class="math display">\[\cal{F}_f(\varepsilon_1,\ldots,\varepsilon_n)=f\varepsilon_1\cdots\varepsilon_n\]</span>
The set of <em>terms</em> is the set of expressions that can be built up
from the constant symbols and variables by applying(zero or more times)
the <span class="math inline">\(\cal{F}_f\)</span> operations.</p>
<p>The terms are the expression that are transformlated as names of
objects(noun phrases), in contrast to the wffs which are translated as
assertions about the objects. (项翻译成名词性短语来描述某个对象,
合式公式翻译成关于该对象的断言)</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
变量符号, 常量符号本身就是项. 项代表论域里的一个元素.
可以由常量或变量代表. 或由常量或变量经过一定运算得到. </font></p>
</div>
<h4 id="def-atomic-formulas-原子公式"><span class="math inline">\(\DEF\)</span> Atomic Formulas
原子公式<span id="AtomicFormula"></span></h4>
<p>An <em>atomic formula</em> is an expression of the form <span class="math display">\[Pt_1\ldots t_n,\]</span> where <span class="math inline">\(P\)</span> is an <span class="math inline">\(n\)</span>-place <a href="#PredicateSymbol">predicate symbol</a> and <span class="math inline">\(t_1,\ldots,t_n\)</span> are <a href="#Term">terms</a>.</p>
<p>原子公式在一阶逻辑语言里的作用相当于命题逻辑中的<a href="/48e9c4af#SentenceSymbol">命题符号</a></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
原子公式可以翻译成一个陈述句, 名词部分(主语, 宾语)由项表示,
谓语由谓词符号表示. </font></p>
</div>
<h4 id="def-well-formed-formulas-wffs-or-just-formulas-合式公式"><span class="math inline">\(\DEF\)</span> Well-Formed Formulas, (wffs, or just
formulas) 合式公式 <span id="FirstOrderWff"></span></h4>
<p>The set of <em>well-formed formulas</em> (wffs, or just formulas) is
the set of expressions that can be built up from the <a href="#AtomicFormula">atomic formulas</a> by applying (zero or more
times) the operations <span class="math inline">\(\cal{E}_\lnot\)</span>, <span class="math inline">\(\cal{E}_\rightarrow\)</span> and <span class="math inline">\(\cal{Q}_i(i=1,2,\ldots).\)</span> where <span class="math display">\[
\matrix{
    \cal{E}_\lnot(\gamma) = (\lnot\gamma),\cr
    \cal{E}_\rightarrow(\gamma,\delta) = (\gamma\rightarrow\delta),\cr
    \cal{Q}_i(\gamma) = \forall v_i\gamma\cr
}
\]</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
通过量词符号对变量进行限定, 以及通过逻辑符号表示陈述句之间的逻辑关系,
来对演绎思维进行数学建模. </font></p>
</div>
<h4 id="def-occur-free-in-the-wff-自由出现"><span class="math inline">\(\DEF\)</span> occur free in the wff 自由出现
<span id="OccurFree"></span></h4>
<p>Consider any variable <span class="math inline">\(x\)</span>. We
define, for each wff <span class="math inline">\(\alpha\)</span>, what
it means for x to <em>occur free</em> in <span class="math inline">\(\alpha\)</span> by recursion:</p>
<ol type="1">
<li>For <a href="#AtomicFormula">atomic</a> <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(x\)</span> occurs free in <span class="math inline">\(\alpha\)</span> iff <span class="math inline">\(x\)</span> occurs in (i.e., is a symbol of) <span class="math inline">\(\alpha\)</span>.</li>
<li><span class="math inline">\(x\)</span> occurs free in (<span class="math inline">\(\lnot\alpha\)</span>) iff <span class="math inline">\(x\)</span> occurs free in <span class="math inline">\(\alpha\)</span>.</li>
<li><span class="math inline">\(x\)</span> occurs free in (<span class="math inline">\(\alpha\rightarrow\beta\)</span>) iff x occurs free
in <span class="math inline">\(\alpha\)</span> or in <span class="math inline">\(\beta\)</span>.</li>
<li><span class="math inline">\(x\)</span> occurs free in <span class="math inline">\(\forall v_i\alpha\)</span> iff <span class="math inline">\(x\)</span> occurs free in <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(x\neq v_i\)</span>.</li>
</ol>
<p><span class="math inline">\(x\)</span> is a <em>free variable</em> of
<span class="math inline">\(\alpha\)</span>.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
自由变量是没有量词符号限定的变量. </font></p>
</div>
<h4 id="def-sentence-命题"><span class="math inline">\(\DEF\)</span>
Sentence 命题 <span id="FirstOrderSentence"></span></h4>
<p>If no variable occurs free in the <a href="#FirstOrderWff">wff</a>
<span class="math inline">\(\alpha\)</span>, then <span class="math inline">\(\alpha\)</span> is a sentence.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
没有自由变量的合式公式是命题. </font></p>
</div>
<h4 id="on-notation">On Notation <span id="Notation"></span></h4>
<p>We naturally want methos of specifying wffs in more indirect but more
readable ways.</p>
<ul>
<li><span class="math inline">\((\alpha\lor\beta)\)</span> abbreviates
<span class="math inline">\(((\lnot\alpha)\rightarrow\beta)\)</span></li>
<li><span class="math inline">\((\alpha\land\beta)\)</span> abbreviates
<span class="math inline">\(((\lnot(\alpha\rightarrow(\lnot\beta)))\)</span></li>
<li><span class="math inline">\((\alpha\leftrightarrow\beta)\)</span>
abbreviates <span class="math inline">\(((\alpha\rightarrow\beta)\land(\beta\rightarrow\alpha))\)</span></li>
<li><span class="math inline">\(\exists x\alpha\)</span> abbreviates
<span class="math inline">\((\lnot\forall x(\lnot\alpha))\)</span></li>
<li><span class="math inline">\(u=t\)</span> abbreviates <span class="math inline">\(=ut\)</span>. A similar abbreviation applies to
some other 2-predicate and function symbols.</li>
<li><span class="math inline">\(u\neq t\)</span> abbreviates <span class="math inline">\((\lnot=ut)\)</span></li>
</ul>
<p>For parentheses, we omit mention of just as many as we possibly
can.</p>
<ol type="1">
<li>outermost parentheses may be dropped.</li>
<li><span class="math inline">\(\lnot\)</span>, <span class="math inline">\(\forall\)</span>, and <span class="math inline">\(\exists\)</span> apply to as little as
possible.</li>
<li><span class="math inline">\(\land\)</span>, <span class="math inline">\(\lor\)</span> apply to as little as possible,
subject to item 2(2比3优先级高). For example, <span class="math display">\[
\lnot\alpha\land\beta\rightarrow\gamma\quad\text{is}\quad((\lnot\alpha)\land\beta)\rightarrow\gamma
\]</span></li>
<li>When one connective is used repeatedly, the expression is grouped to
the right. For example, <span class="math display">\[\alpha\rightarrow\beta\rightarrow\gamma\quad\text{is}\quad\alpha\rightarrow(\beta\rightarrow\gamma)\]</span></li>
</ol>
<h4 id="exercises-2.1">Exercises 2.1 <span id="Exercises2.1"></span></h4>
<h5 id="problem-1">Problem 1</h5>
<p>Assume that we have a language with the following parameters: <span class="math inline">\(\forall\)</span>, intended to mean "for all
things"; <span class="math inline">\(N\)</span>, intended to mean "is a
number"; <span class="math inline">\(I\)</span> , intended to mean "is
interesting";&lt;, intended to mean "is less than"; and <span class="math inline">\(0\)</span>, a constant symbol intended to denote
zero. Translate into this language the English sentences listed below.
If the English sentence is ambiguous, you will need more than one
translation.</p>
<ol type="a">
<li>Zero is less than any number.</li>
<li>If any number is interesting, then zero is interesting.</li>
<li>No number is less than zero.</li>
<li>Any uninteresting number with the property that all smaller numbers
are interesting certainly is interesting.</li>
<li>There is no number such that all numbers are less than it.</li>
<li>There is no number such that no number is less than it.</li>
</ol>
<p>解:</p>
<ol type="a">
<li><span class="math inline">\(\forall v(Nv\rightarrow
(0&lt;v))\)</span></li>
<li>any number如果意思是有的数是有趣的: <span class="math inline">\(\exists v(Nv\land Iv)\rightarrow I0\)</span>.
如果意思是任意的数都是有趣的: <span class="math inline">\(\forall
v(Nv\rightarrow Iv)\rightarrow I0\)</span></li>
<li><span class="math inline">\(\forall
v(Nv\rightarrow\lnot(v&lt;0))\)</span></li>
<li><span class="math inline">\(\forall v(Nv\land\lnot Iv\land\forall
u(Nu\land u&lt;v\rightarrow Iu)\rightarrow Iv)\)</span></li>
<li><span class="math inline">\(\lnot\exists v(Nv\land \forall
u(Nu\rightarrow u&lt;v))\)</span></li>
<li><span class="math inline">\(\lnot\exists v(Nv\land \lnot\exists
u(Nu\land u&lt;v))\)</span></li>
</ol>
<h5 id="problem-2">Problem 2</h5>
<p>With the same language as in the preceding exercise, translate back
into good English the wff <span class="math display">\[
\forall x(Nx\rightarrow Ix\rightarrow\lnot\forall y(Ny\rightarrow
Iy\rightarrow \lnot x&lt;y)).
\]</span></p>
<p>解: 对任意的有趣的数, 都能找到比它大的有趣的数.
即不存在最大的有趣的数.</p>
<p>这里有个推到有必要记住 <span class="math inline">\(\forall
x(Nx\rightarrow Ix\rightarrow\alpha) = \forall x(Nx \land
Ix\rightarrow\alpha)\)</span></p>
<h5 id="problem-3">Problem 3</h5>
<p>Neither <span class="math inline">\(a\)</span> nor <span class="math inline">\(b\)</span> is a member of every set. (<span class="math inline">\(\forall\)</span>, for all sets; <span class="math inline">\(\in\)</span>, is a member of; <span class="math inline">\(a\)</span>, <span class="math inline">\(a\)</span>; <span class="math inline">\(b\)</span>, <span class="math inline">\(b\)</span>.)</p>
<p>解: <span class="math display">\[
\lnot\forall xa\in x \land \lnot\forall x b\in x
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 2.2 -- Problem 2 Solution</title>
    <url>//d0a95a30/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\PROOF{\sf{P\scriptsize
ROOF}.\quad}\)</span></p>
<p>点击<a href="/edd6b774">这里进入AMIL目录</a></p>
<h5 id="Problem2.2-2">Problem 2</h5>
<p>Show that no one of the following sentences is logically implied by
the other two. (This is done by giving a structure in which the sentence
in question is false, while the other two are true.)</p>
<ol type="a">
<li><span class="math inline">\(\forall{x}\forall{y}\forall{z}(Pxy\rightarrow
Pyz\rightarrow Pxz).\)</span> Recall that by our convention <span class="math inline">\(\alpha\rightarrow\beta\rightarrow\gamma\)</span>
is <span class="math inline">\(\alpha\rightarrow(\beta\rightarrow\gamma).\)</span></li>
<li><span class="math inline">\(\forall{x}\forall{y}(Pxy\rightarrow
Pyx\rightarrow x=y).\)</span></li>
<li><span class="math inline">\(\forall{x}\exists{y}Pxy\rightarrow\exists{y}\forall{x}Pxy.\)</span></li>
</ol>
<span id="more"></span>
<p><span class="math inline">\(\PROOF\)</span></p>
<p>Let above wff in a,b and c be <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span>.</p>
<ul>
<li><span class="math inline">\(\alpha\)</span> is a <a href="\48e9c4af#Transitive">transitive relation</a></li>
<li><span class="math inline">\(\beta\)</span> is a <a href="\48e9c4af#Anti-symmetric">anti-symmetric relation</a></li>
<li><span class="math inline">\(\gamma\)</span> describe a relation in
which if for every element, there is a greater one then there is a
maximal element.</li>
</ul>
<p>Three different structures will be constructed below in which one
sentence in question is false, while the other two are true.</p>
<ol type="1">
<li><p><span class="math inline">\({\frak A} = ({\Bbb
N};\forall,=,\le)\)</span>, in which</p>
<ul>
<li><span class="math inline">\(|{\frak A}| = {\Bbb N}\)</span></li>
<li><span class="math inline">\(P_{\frak A} = \le\)</span></li>
</ul></li>
</ol>
<p>Then obviously <span class="math inline">\(\vDash_{\frak
A}\alpha\)</span>, <span class="math inline">\(\vDash_{\frak
A}\beta\)</span>, but <span class="math inline">\(\nvDash_{\frak
A}\gamma\)</span>. So <span class="math inline">\(\{\alpha,\beta\}\nvDash\gamma\)</span></p>
<ol start="2" type="1">
<li><p>Say that <span class="math inline">\({\frak B}\)</span> is
defined as below:</p>
<ul>
<li><span class="math inline">\(|{\frak B}| = \{a,b\}\)</span></li>
<li><span class="math inline">\(P_{\frak B} = \{\langle
a,a\rangle,\langle a,b\rangle,\langle b,a\rangle,\langle
b,b\rangle\}\)</span></li>
</ul></li>
</ol>
<p>Then obviously <span class="math inline">\(\vDash_{\frak
B}\alpha\)</span>, <span class="math inline">\(\vDash_{\frak
B}\gamma\)</span>. But <span class="math inline">\(\nvDash_{\frak
B}\beta\)</span> because <span class="math inline">\(Pab\)</span>, <span class="math inline">\(Pba\)</span> exists, but <span class="math inline">\(a\neq b\)</span>. So <span class="math inline">\(\{\alpha,\gamma\}\nvDash\beta\)</span>.</p>
<ol start="3" type="1">
<li><p>Say that <span class="math inline">\({\frak C}\)</span> is
defined as below:</p>
<ul>
<li><span class="math inline">\(|{\frak C}| = \{a,b,c\}\)</span></li>
<li><span class="math inline">\(P_{\frak C} = \{\langle
a,b\rangle,\langle b,c\rangle\}\)</span></li>
</ul></li>
</ol>
<p>Then <span class="math inline">\(\vDash_{\frak C}\beta\)</span>,
because there is no <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> such that <span class="math inline">\(Pxy\)</span> and <span class="math inline">\(Pyx\)</span>. <span class="math inline">\(\vDash_{\frak B}\gamma\)</span> because not for
every <span class="math inline">\(x\)</span> there is <span class="math inline">\(y\)</span> such that <span class="math inline">\(Pxy\)</span>. But <span class="math inline">\(\nvDash_{\frak B}\alpha\)</span> because there is
no <span class="math inline">\(Pac\)</span>. <span class="math inline">\(\{\beta,\gamma\}\nvDash\alpha\)</span></p>
<p>In summary, no one of the three sentences in question is logically
implied by the other two.<span class="math inline">\(\dashv\)</span></p>
<p>点击<a href="/edd6b774">这里进入AMIL目录</a></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 2.2</title>
    <url>//a55d499/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是Chapter 2, Section 2.2, 介绍一阶逻辑的真值和模型.</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<h2 id="chapter-two.-first-order-logic-一阶逻辑">Chapter Two.
First-Order Logic 一阶逻辑 <span id="Chapter2"></span></h2>
<h3 id="section-2.2-truth-and-models-真值与模型">Section 2.2 Truth and
Models 真值与模型 <span id="Section2.2"></span></h3>
<h4 id="def-structure-结构"><span class="math inline">\(\DEF\)</span>
Structure 结构 <span id="Structure"></span></h4>
<p>A <em>structure</em> <span class="math inline">\(\frak A\)</span> for
our given first-order language is a <a href="/48e9c4af#Function">function</a> whose domain is the set of <a href="/1eec0e97#FirstOrderParameter">parameters</a> and such that</p>
<ol type="1">
<li><span class="math inline">\(\frak A\)</span> assigns to the
quantifier symbol <span class="math inline">\(\forall\)</span> a
nonempty set <span class="math inline">\(|\frak A|\)</span> called the
<em>universe</em><span id="Universe"> (or domain, 论域) of <span class="math inline">\(\frak A\)</span>.</span></li>
<li><span class="math inline">\(\frak A\)</span> assigns to each <a href="/1eec0e97#PredicateSymbol"><span class="math inline">\(n\)</span>-place predicate symbol</a> <span class="math inline">\(P\)</span> an <a href="/48e9c4af#NaryRelation"><span class="math inline">\(n\)</span>-ary
relation</a> <span class="math inline">\(P^{\frak A}\subseteq|\frak
A|^n\)</span><span id="StructPA">; i.e., <span class="math inline">\(P^{\frak A}\)</span> is a set of <a href="/48e9c4af#NTuples"><span class="math inline">\(n\)</span>-tuples</a> of members of the
universe.</span></li>
<li><span class="math inline">\(\frak A\)</span> assigns to each <a href="/1eec0e97#FirstOrderConstantSymbol">constant symbol</a> <span class="math inline">\(c\)</span> a member <span class="math inline">\(c^{\frak A}\)</span><span id="StructCA"> of the
universe <span class="math inline">\(\frak A\)</span>.</span></li>
<li><span class="math inline">\(\frak A\)</span> assigns to each <a href="/1eec0e97#FirstOrderFunctionSymbol"><span class="math inline">\(n\)</span>-place function symbol</a> <span class="math inline">\(f\)</span> an <a href="/48e9c4af#Operation"><span class="math inline">\(n\)</span>-ary operation</a> <span class="math inline">\(f^{\frak A}\)</span><span id="StructFA"> on <span class="math inline">\(|\frak A|\)</span>; i.e., <span class="math inline">\(f^{\frak A}:|\frak A|^n\rightarrow|\frak
A|\)</span>.</span></li>
</ol>
<p>Note that we require the universe <span class="math inline">\(|\frak
A|\)</span> to be nonempty. Notice also that <span class="math inline">\(f^{\frak A}\)</span> must have all of <span class="math inline">\(|\frak A|^n\)</span> in for its domain.</p>
<p>表示法, 通常用这种方式表示一个结构: <span class="math inline">\({\frak A} = (|{\frak A}|; c^{\frak A}, P^{\frak
A}, f^{\frak A})\)</span>, 例如如下结构:</p>
<ul>
<li><span class="math inline">\(|{\frak N}|={\Bbb N}\)</span>, the set
of natural numbers.</li>
<li><span class="math inline">\(0^{\frak N}\)</span>, the number 0.</li>
<li><span class="math inline">\(S^{\frak N}\)</span>, <span class="math inline">\(+^{\frak N}\)</span>, and <span class="math inline">\(\cdot^{\frak N}\)</span> are <span class="math inline">\(S\)</span>, <span class="math inline">\(+\)</span>, <span class="math inline">\(\cdot\)</span>, the functions of successor,
addition, and multiplication.</li>
</ul>
<p>表示为:<span class="math display">\[{\frak N} = ({\Bbb
N};0,S,+,\cdot).\]</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
如果说一阶逻辑语言是把人的天然的演绎思维抽象成符号的话,
结构(structure)就是通过把一阶逻辑语言里的parameters映射成论域中的元素,
<a href="/48e9c4af#NaryRelation">关系(relation)</a>, 和<a href="/1eec0e97#FirstOrderFunctionSymbol">函数(function)</a>.
把一阶逻辑语言具象化成某一个研究对象. </font></p>
</div>
<h4 id="def-frak-a-satisfies-varphi-with-s-结构frak-a以-变量的取值函数s满足合式公式varphi"><span class="math inline">\(\DEF\)</span> <span class="math inline">\(\frak
A\)</span> satisfies <span class="math inline">\(\varphi\)</span> with
<span class="math inline">\(s\)</span> 结构<span class="math inline">\(\frak A\)</span>以 变量的取值函数<span class="math inline">\(s\)</span>满足合式公式<span class="math inline">\(\varphi\)</span>
<span id="FirstOrderSatisfy"></span></h4>
<p>Let</p>
<ul>
<li><span class="math inline">\(\varphi\)</span> be a wff of our
language,</li>
<li><span class="math inline">\(\frak A\)</span> a struture for the
language,</li>
<li><span class="math inline">\(s:V\rightarrow |\frak
A|\)</span><span id="Function_s_V2A"> a <a href="/48e9c4af#Function">function</a> from the set <span class="math inline">\(V\)</span> of all variables into the universe
<span class="math inline">\(|\frak A|\)</span> of <span class="math inline">\(\frak A\)</span>.</span></li>
</ul>
<p>Then we will define what it means for <span class="math inline">\(\frak A\)</span> to satisfy <span class="math inline">\(\varphi\)</span> with <span class="math inline">\(s\)</span> (对于结构<span class="math inline">\(\frak A\)</span>, 变量的取值<span class="math inline">\(s\)</span>可以使合式公式<span class="math inline">\(\varphi\)</span>满足), <span class="math display">\[
\vDash_{\frak A}\varphi[s]
\]</span></p>
<p>The definition of satisfaction proceeds as follows:</p>
<p>I. <em>Terms</em>. We define the extension: <span class="math display">\[
\cssId{Overlines}{\overline{s}}:T\rightarrow|\frak A|,
\]</span> a <a href="/48e9c4af#Function">function</a> from the set <span class="math inline">\(T\)</span> of all <a href="/1eec0e97#Term">terms</a> into the <a href="/1eec0e97#Universe">universe</a> of <span class="math inline">\(\frak A\)</span>. <span class="math inline">\(\overline{s}\)</span> is defined by recursion as
follows:</p>
<ol type="1">
<li>For each <a href="/1eec0e97#FirstOrderVariable">variable</a> <span class="math inline">\(x\)</span>, <span class="math inline">\(\overline{s}(x)=s(x)\)</span></li>
<li>For each <a href="/1eec0e97#FirstOrderConstantSymbol">constant
symbol</a> <span class="math inline">\(c\)</span>, <span class="math inline">\(\overline{s}(c)=\href{ #StructCA}{c^{\frak
A}}\)</span></li>
<li>If <span class="math inline">\(t_1,\ldots,t_n\)</span> are <a href="/1eec0e97#Term">terms</a> and <span class="math inline">\(f\)</span> is an <a href="/1eec0e97#FirstOrderFunctionSymbol"><span class="math inline">\(n\)</span>-place function symbol</a>, then <span class="math display">\[
\overline{s}(ft_1\cdots t_n)=\href{ #StructFA}{f^{\frak
A}}(\overline{s}(t_1),\ldots,\overline{s}(t_n)).
\]</span></li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
第一步, 通过对<span class="math inline">\(s\)</span>的扩展<span class="math inline">\(\overline{s}(t)\)</span>把所有的项映射成论域里的一个元素.
</font></p>
</div>
<ol start="2" type="I">
<li><em>Atomic formulas</em>. The definition of satisfaction of <a href="/1eec0e97#AtomicFormula">atomic formulas</a> is explicit and not
recursive.</li>
</ol>
<ol type="1">
<li><span class="math inline">\(\vDash_{\frak A}=t_1
t_2[s]\)</span><span id="SatisfyEqualitySymbol"> iff <span class="math inline">\(\overline{s}(t_1)=\overline{s}(t_2)\)</span>.
(Thus <span class="math inline">\(=\)</span> means <span class="math inline">\(=\)</span>. Note that <span class="math inline">\(=\)</span> is a <a href="/1eec0e97#FirstOrderLogicalSymbol">logical symbol</a>, not a <a href="/1eec0e97#FirstOrderParameter">parameter</a> open to
interpretation. 这就是把等号区别于其他谓词符号分类成逻辑符号的原因,
等号不需要解释)</span></li>
<li>For an <a href="/1eec0e97#PredicateSymbol"><span class="math inline">\(n\)</span>-place predicate parameter</a> <span class="math inline">\(P\)</span>, <span class="math display">\[
\vDash_{\frak A}Pt_1\cdots
t_n[s]\quad\text{iff}\quad\langle\overline{s}(t_1),\ldots,\overline{s}(t_n)\rangle\in
\href{ #StructPA}{P^{\frak A}}.
\]</span></li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
对于原子公式, 只要存在于结构的关系中就是满足.
或者说定义结构的时候对关系的定义决定了哪些公式能够被该结构满足.
</font></p>
</div>
<ol start="3" type="I">
<li><em>Other wffs</em>. The wffs we defined inductively, and
consequently here satisfaction is defined recursively.</li>
</ol>
<ol type="1">
<li>For atomic formulas, the definition is above.</li>
<li><span class="math inline">\(\vDash_{\frak
A}\lnot\varphi[s]\)</span><span id="SatisfyNegationSymbol"> iff <span class="math inline">\(\nvDash_{\frak A}\varphi[s].\)</span></span></li>
<li><span class="math inline">\(\vDash_{\frak
A}(\varphi\rightarrow\psi)[s]\)</span><span id="SatisfyConditionalSymbol">
iff either <span class="math inline">\(\nvDash_{\frak
A}\varphi[s]\)</span> or <span class="math inline">\(\vDash_{\frak
A}\psi[s]\)</span> or both.</span></li>
<li><span class="math inline">\(\vDash_{\frak A}\forall
x\varphi[s]\)</span><span id="SatisfyQuantifierSymbol"> iff for every
<span class="math inline">\(d\in|\frak A|\)</span>, we have <span class="math inline">\(\vDash_{\frak A}\varphi[s(x|d)]\)</span>.</span></li>
</ol>
<p>Here <span class="math inline">\(s(x|d)\)</span> is the <a href="/48e9c4af#Function">function</a> which is exactly like <a href="#Function_s_V2A"><span class="math inline">\(s\)</span></a> except
for one thing: At the variable x it assumes the value d. This can be
expressed by the equation <span class="math display">\[
s(x|d)(y)=\left\{
\begin{array}{lll}
s(y) &amp; \text{if} &amp; y\neq x, \\
d &amp; \text{if} &amp; y=x. \\
\end{array}
\right.
\]</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体"> <span class="math inline">\(x\)</span>可以取任意值, 其他变量还是取函数<span class="math inline">\(s\)</span>中分配的值. </font></p>
</div>
<h4 id="theorem-22a">Theorem 22A <span id="Theorem22A"></span></h4>
<p>Assume that <span class="math inline">\(s_1\)</span> and <span class="math inline">\(s_2\)</span> are <a href="#Function_s_V2A">functions from <span class="math inline">\(V\)</span> into <span class="math inline">\(|\frak
A|\)</span></a> which agree at all variables (if any) that <a href="/1eec0e97#OccurFree">occur free</a> in the wff <span class="math inline">\(\varphi\)</span>. Then <span class="math display">\[
\vDash_{\frak A}\varphi[s_1]\quad\text{iff}\quad\vDash_{\frak
A}\varphi[s_2].
\]</span></p>
<p>This theorem justifies the following notation: Suppose that <span class="math inline">\(\varphi\)</span> is a formula such that all
variables <a href="/1eec0e97#OccurFree">occurring free</a> in <span class="math inline">\(\varphi\)</span> are included among <span class="math inline">\(v_1,\ldots,v_k\)</span>. Then for elements <span class="math inline">\(a_1,\ldots,a_k\)</span> of <span class="math inline">\(|\frak A|\)</span>, <span class="math display">\[
\vDash_{\frak A}\varphi\llbracket a_1,\ldots,a_k\rrbracket
\]</span> means that <a href="#FirstOrderSatisfy"><span class="math inline">\(\frak A\)</span> satisfies <span class="math inline">\(\varphi\)</span></a> with some (and hence with
any) <a href="/48e9c4af#Function">function</a> <span class="math inline">\(s:V\rightarrow|\frak A|\)</span> for which <span class="math inline">\(s(v_i)=a_i,1\le i\le k\)</span>.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
函数<span class="math inline">\(s\)</span>中只有自由变量的部分有用.
</font></p>
</div>
<h4 id="corollary-22b">Corollary 22B <span id="Corollary22B"></span></h4>
<p>For a <a href="/1eec0e97#FirstOrderSentence">sentence</a> <span class="math inline">\(\sigma\)</span>, either</p>
<ol type="a">
<li><span class="math inline">\(\frak A\)</span> <a href="#FirstOrderSatisfy">satisfies</a> <span class="math inline">\(\sigma\)</span> with every <a href="/48e9c4af#Function">function</a> <span class="math inline">\(s\)</span> from <span class="math inline">\(V\)</span> into <span class="math inline">\(|\frak
A|\)</span>, or</li>
<li><span class="math inline">\(\frak A\)</span> does not satisfy <span class="math inline">\(\sigma\)</span> with any such <a href="/48e9c4af#Function">function</a>.</li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
命题是没有自由变量的合式公式. 而<span class="math inline">\(s\)</span>中只有自由变量有用. 所以对于命题,
函数<span class="math inline">\(s\)</span>就没用了.
换句话说一个命题是否能被结构满足跟给<span class="math inline">\(V\)</span>中变量取论域中的哪些值无关.
进一步一旦一个结构确定了, 那么一个命题的真假就确定了. </font></p>
</div>
<h4 id="def-truth-and-models-模型"><span class="math inline">\(\DEF\)</span> Truth and Models 模型
<span id="Model"></span></h4>
<p>If alternative (a) of <a href="#Corollary22B">Corollary 22B</a>
holds, then we say that <span class="math inline">\(\sigma\)</span> is
<em>true</em> in <span class="math inline">\(\frak A\)</span> (written
<span class="math inline">\(\vDash_{\frak A}\sigma\)</span>) or that
<span class="math inline">\(\frak A\)</span> is a <em>model</em> of
<span class="math inline">\(\sigma\)</span>.</p>
<p>结构<span class="math inline">\(\frak A\)</span>是合式公式<span class="math inline">\(\sigma\)</span>的模型, 即合式公式<span class="math inline">\(\sigma\)</span>在模型<span class="math inline">\(\frak A\)</span>中为真</p>
<p>If alternative (b) holds, then <span class="math inline">\(\sigma\)</span> is <em>false</em> in <span class="math inline">\(\frak A\)</span>.</p>
<p><span class="math inline">\(\frak A\)</span> is a <em>model</em> of a
set <span class="math inline">\(\Sigma\)</span> of <a href="/1eec0e97#FirstOrderSentence">sentences</a> iff it is a model of
every member of <span class="math inline">\(\Sigma\)</span>.</p>
<h4 id="logical-implication">2.2.1 Logical Implication</h4>
<h5 id="def-logically-imply-逻辑蕴涵"><span class="math inline">\(\DEF\)</span> Logically Imply 逻辑蕴涵
<span id="LogicallyImply"></span></h5>
<p>Let <span class="math inline">\(\Gamma\)</span> be a set of <a href="/1eec0e97#FirstOrderWff">wffs</a>, <span class="math inline">\(\varphi\)</span> a wff. Then <span class="math inline">\(\Gamma\)</span> <em>logically implies</em> <span class="math inline">\(\varphi\)</span>, written <span class="math inline">\(\Gamma\vDash\varphi\)</span>, iff for every <a href="#Structure">structure</a> <span class="math inline">\(\frak
A\)</span> for the language and every <a href="/48e9c4af#Function">function</a> <span class="math inline">\(s:V\rightarrow|\frak A|\)</span> such that <span class="math inline">\(\frak A\)</span> <a href="#FirstOrderSatisfy">satisfies</a> every member of <span class="math inline">\(\Gamma\)</span> with <span class="math inline">\(s\)</span>, <span class="math inline">\(\frak
A\)</span> also satisfies <span class="math inline">\(\varphi\)</span>
with <span class="math inline">\(s\)</span>.</p>
<p>As before we will write "<span class="math inline">\(\gamma\vDash\varphi\)</span>" in place of "<span class="math inline">\(\{\gamma\}\vDash\varphi\)</span>".
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
逻辑蕴涵, 就是不需要对合式公式里符号进行具象化, 仅仅根据合式公式的形式,
就能确定的一个推导关系. <span class="math inline">\(\Gamma\)</span>能推导出<span class="math inline">\(\varphi\)</span>. </font></p>
</div></p>
<h5 id="def-logically-equivalent-逻辑等价"><span class="math inline">\(\DEF\)</span> Logically Equivalent 逻辑等价
<span id="LogicallyEquivalent"></span></h5>
<p>Say that <span class="math inline">\(\varphi\)</span> and <span class="math inline">\(\psi\)</span> are <em>logically equivalent</em>
(<span class="math inline">\(\varphi\tauequ\psi\)</span>) iff <span class="math inline">\(\varphi\vDash\psi\)</span> and <span class="math inline">\(\psi\vDash\varphi\)</span>.</p>
<h5 id="def-valid-wff-恒真公式"><span class="math inline">\(\DEF\)</span> Valid wff 恒真公式
<span id="ValidWff"></span></h5>
<p>A wff <span class="math inline">\(\varphi\)</span> is <em>valid</em>
iff <span class="math inline">\(\varnothing\vDash\varphi\)</span>
(written simply "<span class="math inline">\(\vDash\varphi\)</span>").</p>
<h5 id="corollary-22c">Corollary 22C <span id="Corollary22C"></span></h5>
<p>For a set <span class="math inline">\(\Sigma;\tau\)</span> of <a href="/1eec0e97#FirstOrderSentence">sentences</a>, <a href="#LogicallyImply"><span class="math inline">\(\Sigma\vDash\tau\)</span></a> iff every <a href="#Model">model</a> of <span class="math inline">\(\Sigma\)</span>
is also a model of <span class="math inline">\(\tau\)</span>, A sentence
<span class="math inline">\(\tau\)</span> is <a href="#ValidWff">valid</a> iff it is <a href="#Model">true</a> in every
structure.</p>
<h4 id="definability-in-a-structure">2.2.2 Definability in a
Structure</h4>
<h5 id="def-definedefinable-定义可定义的"><span class="math inline">\(\DEF\)</span> Define/Definable 定义/可定义的
<span id="Define"></span></h5>
<p>Consider a <a href="#Structure">structure</a> <span class="math inline">\({\frak A}\)</span> and a <a href="/1eec0e97#FirstOrderWff">formula</a> <span class="math inline">\(\varphi\)</span> whose <a href="#OccurFree">free
variables</a> are among <span class="math inline">\(v_1,\ldots,v_k\)</span>. Then we can construct the
<a href="/48e9c4af#NaryRelation"><span class="math inline">\(k\)</span>-ary relation</a> on <span class="math inline">\(|{\frak A}|\)</span> <span class="math display">\[
\{\langle a_1,\ldots,a_k\rangle\href{ #FirstOrderSatisfy}{\vDash_{\frak
A}}\varphi\href{ #Theorem22A}{\llbracket a_1,\ldots,a_k\rrbracket}\}
\]</span> Call this the <a href="/48e9c4af#NaryRelation"><span class="math inline">\(k\)</span>-ary relation</a> <span class="math inline">\(\varphi\)</span> <em>defines</em> in <span class="math inline">\({\frak A}\)</span>. In general, a <a href="/48e9c4af#NaryRelation"><span class="math inline">\(k\)</span>-ary
relation</a> on <span class="math inline">\(|{\frak A}|\)</span> is said
to be <em>definable</em> in <span class="math inline">\({\frak
A}\)</span> iff there is a <a href="/1eec0e97#FirstOrderWff">formula</a>
(whose <a href="#OccurFree">free variables</a> are among <span class="math inline">\(v_1,\ldots,v_k\)</span>) that defines it
there.</p>
<p>有些关系是可定义的, 有些关系是不可定义的. 证明不可定义性比较难.
如果一个元素在结构中可以用</p>
<h5 id="examples">Examples</h5>
<p>以如下数论语言的结构为例:</p>
<ul>
<li><span class="math inline">\(|{\frak N}|={\Bbb N}\)</span>, the set
of natural numbers.</li>
<li><span class="math inline">\(0^{\frak N}\)</span>, the number 0.</li>
<li><span class="math inline">\(S^{\frak N}\)</span>, <span class="math inline">\(+^{\frak N}\)</span>, and <span class="math inline">\(\cdot^{\frak N}\)</span> are <span class="math inline">\(S\)</span>, <span class="math inline">\(+\)</span>, <span class="math inline">\(\cdot\)</span>, the functions of successor,
addition, and multiplication.</li>
</ul>
<p><span class="math display">\[
{\frak N} = ({\Bbb N}; 0, S, +, \cdot).
\]</span></p>
<h6 id="序关系">序关系</h6>
<ol type="1">
<li>严格序关系<span class="math inline">\({\langle
m,n\rangle|m&lt;n}\)</span> 在<span class="math inline">\({\frak
N}\)</span>中由如下公式定义: <span class="math display">\[
\exists v_3 v_1+Sv_3 = v_2.
\]</span></li>
</ol>
<h6 id="自然数">自然数</h6>
<ol start="2" type="1">
<li>任意自然数<span class="math inline">\(n\)</span>, <span class="math inline">\(\{n\}\)</span>是可定义的. 例如,
{2}可以由如下公式定义: <span class="math display">\[
v_1=SS0
\]</span></li>
</ol>
<p>Because of this, we say that <span class="math inline">\(n\)</span>
is a <em>definable element</em><span id="DefinableElement"> in <span class="math inline">\({\frak N}\)</span>.</span></p>
<h6 id="素数">素数</h6>
<ol start="3" type="1">
<li>素数在<span class="math inline">\({\frak
N}\)</span>是由如下公式可定义: <span class="math display">\[
1&lt;v_1\land\forall v_2\forall v_3(v_1=v_2\cdot v_3\rightarrow
v_2=1\lor v_3=1)
\]</span> 注意其中用到了前面已经定义的序和可定义元素<span class="math inline">\(n\)</span>. 如果简单的用已有的定义替换可以得到:
<span class="math display">\[
\exists v_3 S0+Sv_3=v_1\land\forall v_2\forall v_3(v_1=v_2\cdot
v_3\rightarrow v_2=S0\lor v_3=S0)
\]</span></li>
</ol>
<h6 id="幂运算">幂运算</h6>
<ol start="4" type="1">
<li>幂运算, <span class="math inline">\(\{\langle
m,n,p\rangle|p=m^n\}\)</span>在<span class="math inline">\({\frak
N}\)</span>中也是可定义的. 我们将会用中国剩余定理给出证明.</li>
</ol>
<h4 id="definability-of-a-class-of-structures">2.2.3 Definability of a
Class of Structures</h4>
<h5 id="def-modhspace0.5exsigma"><span class="math inline">\(\DEF\)</span> <span class="math inline">\(Mod\hspace0.5ex\Sigma\)</span>
<span id="Mod"></span></h5>
<p>For a set <span class="math inline">\(\Sigma\)</span> of <a href="/1eec0e97#FirstOrderSentence">sentences</a>, let <span class="math inline">\(Mod\hspace0.5ex\Sigma\)</span> be the class of all
<a href="#Model">models</a> of <span class="math inline">\(\Sigma\)</span>, i.e., the <em>class of all
structures</em> for the language in which every member of <span class="math inline">\(\Sigma\)</span> is <a href="#Model">true</a>.</p>
<p>For a simgle sentence <span class="math inline">\(\tau\)</span> we
write simply "<span class="math inline">\(Mod\hspace0.5ex\tau\)</span>"
instead of "<span class="math inline">\(Mod\hspace0.5ex\{\tau\}\)</span>."</p>
<p><span class="math inline">\(_*\)</span>In set theory, a
<em>class</em> is a collection of sets (or sometimes other mathematical
objects) that can be unambiguousely defined by a property that all its
members share. The precise definition of "class" depends on foundational
context.</p>
<p><span class="math inline">\(_*\)</span>A class that is not a set is
called a <em>proper class</em>, and a class that is a set is sometimes
called a <em>small class</em>. For instance, the class of all ordinal
numbers, and the class of all sets, are proper classes in many formal
systems.</p>
<h5 id="def-elementary-class-初等类"><span class="math inline">\(\DEF\)</span> Elementary Class 初等类
<span id="ElementaryClass"></span></h5>
<p>A class <span class="math inline">\({\cal K}\)</span> is an
<em>elementary class</em> (<span class="math inline">\(EC\)</span>) iff
<span class="math inline">\({\cal K}=\href{
#Mod}{\text{Mod}\hspace0.5ex\tau}\)</span> for some <a href="/1eec0e97#FirstOrderSentence">sentence</a> <span class="math inline">\(\tau\)</span>.</p>
<p><span class="math inline">\({\cal K}\)</span> is an <em>elementary
class in the wider sense</em> (<span class="math inline">\(EC_\Delta\)</span>) iff <span class="math inline">\({\cal K}=\href{
#Mod}{\text{Mod}\hspace0.5ex\Sigma}\)</span> for some set <span class="math inline">\(\Sigma\)</span> of <a href="/1eec0e97#FirstOrderSentence">sentences</a>. (广义初等类)</p>
<p>(The adjective elementary is employed as a synonym for
"first-order.")</p>
<h4 id="homomorphisms-同态">2.2.4 Homomorphisms 同态</h4>
<h5 id="def-homomorphism-同态"><span class="math inline">\(\DEF\)</span>
Homomorphism 同态 <span id="Homomorphism"></span></h5>
<p>Let <span class="math inline">\({\frak A}, {\frak B}\)</span> be <a href="#Structure">structures</a> for the language. A
<em>homomorphism</em> <span class="math inline">\(h\)</span> of <span class="math inline">\({\frak A}\)</span> into <span class="math inline">\({\frak B}\)</span> (从<span class="math inline">\({\frak A}\)</span>到<span class="math inline">\({\frak B}\)</span>中的同态) is a <a href="/48e9c4af#Function">function</a> <span class="math inline">\(h:|{\frak A}|\rightarrow|{\frak B}|\)</span> with
the properties:</p>
<ol type="a">
<li><p>For each <a href="/1eec0e97#PredicateSymbol"><span class="math inline">\(n\)</span>-place predicate parameter</a> <span class="math inline">\(P\)</span> and each <a href="/48e9c4af#Tuple"><span class="math inline">\(n\)</span>-tuple</a>
<span class="math inline">\(\langle a_1,\ldots,a_n\)</span> of elements
of <span class="math inline">\(|{\frak A}|\)</span>, <span class="math display">\[
\langle a_1,\ldots,a_n\rangle\in P^{\frak A}\quad\text{iff}\quad\langle
h(a_1),\ldots,h(a_n)\rangle\in P^{\frak B}.
\]</span></p></li>
<li><p>For each <a href="/1eec0e97#FirstOrderFunctionSymbol"><span class="math inline">\(n\)</span>-place function symbol</a> <span class="math inline">\(f\)</span> and each such <a href="/48e9c4af#Tuple"><span class="math inline">\(n\)</span>-tuple</a>,
<span class="math display">\[
h(f^{\frak A}(a_1,\ldots,a_n))=f^{\frak B}(h(a_1),\ldots,h(a_n)).
\]</span></p></li>
<li><p>In the case of a constant symbol <span class="math inline">\(c\)</span> this becomes <span class="math display">\[h(c^{\frak A})=c^{\frak B}.\]</span></p></li>
</ol>
<h5 id="def-isomorphism-同构"><span class="math inline">\(\DEF\)</span>
Isomorphism 同构 <span id="Isomorphism"></span></h5>
<p>If <span class="math inline">\(h\)</span> is <a href="#Homomorphism">homomorphism</a> of <span class="math inline">\({\frak A}\)</span> into <span class="math inline">\({\frak B}\)</span>, and is one-to-one, it is
called an <em>isomorphism</em> (or <em>isomorphic embedding</em>) of
<span class="math inline">\({\frak A}\)</span> into <span class="math inline">\({\frak B}\)</span> (从<span class="math inline">\({\frak A}\)</span>到<span class="math inline">\({\frak B}\)</span>中的同构, 或同构嵌入).</p>
<p>If there is an <em>isomorphism</em> of <span class="math inline">\({\frak A}\)</span> onto <span class="math inline">\({\frak B}\)</span> (i.e., an isomorphism <span class="math inline">\(h\)</span> for which ran <span class="math inline">\(h=|{\frak B}|\)</span>), then <span class="math inline">\({\frak A}\)</span> and <span class="math inline">\({\frak B}\)</span> are said <em>isomorphic</em>
(written <span class="math inline">\({\frak A}\cong{\frak B}\)</span>)
(从<span class="math inline">\({\frak A}\)</span>到<span class="math inline">\({\frak B}\)</span>上的同构, 或<span class="math inline">\({\frak A}\)</span>和<span class="math inline">\({\frak B}\)</span>是同构的).</p>
<h5 id="def-substructure-子结构"><span class="math inline">\(\DEF\)</span> Substructure 子结构
<span id="Substructure"></span></h5>
<p>Consider two structures <span class="math inline">\({\frak
A}\)</span> and <span class="math inline">\({\frak B}\)</span> for the
language such that <span class="math inline">\(|{\frak
A}|\subseteq|{\frak B}|\)</span>. It is clear from the definition of
homomorphism that the <a href="\48e9c4af#IdentityFunction">identity
map</a> from <span class="math inline">\(|{\frak A}|\)</span> into <span class="math inline">\(|{\frak B}|\)</span> is an <a href="#Isomorphism">isomorphism</a> of <span class="math inline">\({\frak A}\)</span> into <span class="math inline">\({\frak B}\)</span> iff</p>
<ol type="a">
<li><p><span class="math inline">\(P^{\frak A}\)</span> is the <a href="\48e9c4af#Restriction">restriction</a> of <span class="math inline">\(P^{\frak B}\)</span> to <span class="math inline">\(|{\frak A}|\)</span>, for each <a href="/1eec0e97#PredicateSymbol">predicate parameter</a> <span class="math inline">\(P\)</span>;</p></li>
<li><p><span class="math inline">\(f^{\frak A}\)</span> is the <a href="\48e9c4af#Restriction">restriction</a> of <span class="math inline">\(f^{\frak B}\)</span> to <span class="math inline">\(|{\frak A}|\)</span>, for each <a href="/1eec0e97#FirstOrderFunctionSymbol">function symbol</a> <span class="math inline">\(f\)</span>, and <span class="math inline">\(c^{\frak A}=c^{\frak B}\)</span> for each <a href="/1eec0e97#FirstOrderConstantSymbol">constant symbol</a> <span class="math inline">\(c\)</span>.</p></li>
</ol>
<p>If these conditions are met, then <span class="math inline">\({\frak
A}\)</span> is said to be s <em>substructure of <span class="math inline">\({\frak B}\)</span>, and <span class="math inline">\({\frak B}\)</span> is an </em>extension* of <span class="math inline">\({\frak A}\)</span>.</p>
<h5 id="homomorphism-theorem-同态定理">Homomorphism Theorem 同态定理
<span id="HomomorphismTheorem"></span></h5>
<p>Let <span class="math inline">\(h\)</span> be a <a href="#Homomorphism">homomorphism</a> of <span class="math inline">\({\frak A}\)</span> into <span class="math inline">\({\frak B}\)</span>, and let <span class="math inline">\(s\)</span> map the set of variables into <span class="math inline">\(|{\frak A}|\)</span>.</p>
<ol type="a">
<li><p>For any <a href="/1eec0e97#Term">term</a> <span class="math inline">\(t\)</span>, we have <span class="math inline">\(\href{
#Homomorphism}{h}(\overline{s}(t))=\overline{h\circ s}(t)\)</span>,
where <a href="#Function_s_V2A"><span class="math inline">\(\overline{s}(t)\)</span></a> is computed in <span class="math inline">\({\frak A}\)</span> and <span class="math inline">\(\overline{h\circ s}(t)\)</span> is computed in
<span class="math inline">\({\frak B}\)</span>.</p></li>
<li><p>For any quantifier-free formula α not containing the equality
symbol, <span class="math display">\[
\vDash_{\frak A}\alpha[s]\quad\text{iff}\quad\vDash_{\frak
B}\alpha[h\circ s].
\]</span></p></li>
<li><p>If <span class="math inline">\(h\)</span> is one-to-one (i.e., is
an <a href="#Isomorphism">isomorphism</a> of <span class="math inline">\({\frak A}\)</span> into <span class="math inline">\({\frak B}\)</span>), then in part (b) we may
delete the restriction "not containing the equality symbol."</p></li>
<li><p>If <span class="math inline">\(h\)</span> is a homomorphism of
<span class="math inline">\({\frak A}\)</span> onto <span class="math inline">\({\frak B}\)</span>, then in (b) we may delete the
restriction "quantifier-free."</p></li>
</ol>
<h5 id="def-elementarily-equivalent-初等等价"><span class="math inline">\(\DEF\)</span> Elementarily Equivalent 初等等价
<span id="ElementarilyEquivalent"></span></h5>
<p>Two structures <span class="math inline">\({\frak A}\)</span> and
<span class="math inline">\({\frak B}\)</span>, for the language are
said to be <em>elementarily equivalent</em> (written <span class="math inline">\({\frak A}\equiv{\frak B}\)</span>) iff for any
sentence <span class="math inline">\(\sigma\)</span>, <span class="math display">\[
\vDash_{\frak A}\sigma\Leftrightarrow\vDash_{\frak B}\sigma.
\]</span></p>
<h5 id="corollary-22d">Corollary 22D <span id="Corollary22D"></span></h5>
<p><a href="#Isomorphism">Isomorphic structures</a> are <a href="#ElementarilyEquivalent">elementarily equivalent</a>:<span class="math display">\[{\frak A}\cong{\frak B}\Rightarrow{\frak
A}\equiv{\frak B}\]</span></p>
<h5 id="def-automorphism-自同构"><span class="math inline">\(\DEF\)</span> Automorphism 自同构
<span id="Automorphism"></span></h5>
<p>An <em>Automorphism</em> of the structure <span class="math inline">\({\frak A}\)</span> is an <a href="#Isomorphism">isomorphism</a> of <span class="math inline">\({\frak A}\)</span> onto <span class="math inline">\({\frak A}\)</span>.</p>
<p>The <a href="\48e9c4af#IdentityFunction">identity</a> function on
<span class="math inline">\(|{\frak A}|\)</span> is trivially an
automorphism of A. A may or may not have <em>nontrivial
automorphisms</em>. (We say that A is <em>rigid</em><span id="Rigid">
(固化的) if the identity function is its only automorphism.)</span></p>
<h5 id="corollary-22e">Corollary 22E <span id="Corollary22E"></span></h5>
<p>Let h be an <a href="#Automorphism">automorphism</a> of the structure
<span class="math inline">\({\frak A}\)</span>, and let <span class="math inline">\(R\)</span> be an <span class="math inline">\(n\)</span>-ary relation on <span class="math inline">\(|{\frak A}|\)</span> <a href="#Define">definable</a> in <span class="math inline">\({\frak
A}\)</span>. Then for any <span class="math inline">\(a_1,\ldots,a_n\)</span> in <span class="math inline">\(|{\frak A}|\)</span>, <span class="math display">\[
\langle a_1,\ldots,a_n\rangle\in R\Leftrightarrow\langle
h(a_1),\ldots,h(a_n)\rangle\in R
\]</span></p>
<p>这个推论可以用于证明给定的关系在某个结构下不可定义.
当我们能够找到一个在结构<span class="math inline">\({\frak
A}\)</span>里构成自同构的函数<span class="math inline">\(h\)</span>时,
如果某个给定的关系不满足于上面的条件 <span class="math inline">\(\langle
a_1,\ldots,a_n\rangle\in R\Leftrightarrow\langle
h(a_1),\ldots,h(a_n)\rangle\in R\)</span>, 就可以说明这个关系在结构<span class="math inline">\({\frak A}\)</span>下是不可定义的.</p>
<p>点击<a href="/edd6b774">这里进入AMIL目录</a></p>
<h4 id="exercises-2.2">Exercises 2.2 <span id="Exercises2.2"></span></h4>
<h5 id="problem-1">Problem 1 <span id="Problem2.2-1"></span></h5>
<p>Show that (a) <span class="math inline">\(\Gamma;\alpha\vDash\varphi\)</span> iff <span class="math inline">\(\Gamma\vDash(\alpha\rightarrow\varphi)\)</span>;
and (b) <span class="math inline">\(\varphi\tauequ\psi\)</span> iff
<span class="math inline">\(\vDash(\varphi\leftrightarrow\psi)\)</span>.</p>
<p><span class="math inline">\(\PROOF\)</span><cr></cr></p>
<p>(a)<cr> <span class="math display">\[
\begin{array}{lcll}
\Gamma;\alpha\vDash\varphi &amp; \Leftrightarrow &amp;
\forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma;\alpha\land\vDash_{\frak
A}\psi[s]\rightarrow\vDash_{\frak A}\varphi[s]) &amp;
(\text{   definition of }\href{ #LogicallyImply}{\text{logical imply}})
\\
&amp; \Leftrightarrow &amp; \left\{\begin{array}{l}
                    \forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma\land\vDash_{\frak
A}\psi[s]\land\nvDash_{\frak A}\alpha[s]\rightarrow\vDash_{\frak
A}\varphi[s]) \\
                    \forall{\frak A}\forall{s}(\vDash_{\frak
A}\alpha[s]\rightarrow\vDash_{\frak A}\varphi[s])
                    \end{array}
                    \right. \\
&amp; \Leftrightarrow &amp; \forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma\land\vDash_{\frak
A}\psi[s]\rightarrow(\nvDash_{\frak A}\alpha[s]\lor\vDash_{\frak
A}\varphi[s]\lor(\vDash_{\frak A}\alpha[s]\land\vDash_{\frak
A}\varphi[s]))) \\
&amp; \Leftrightarrow &amp; \forall\psi\forall{\frak
A}\forall{s}(\psi\in\Gamma\land\vDash_{\frak
A}\psi[s]\rightarrow\vDash_{\frak A}(\alpha\rightarrow\varphi)[s])
&amp;  (\text{   definition of } \href{
#SatisfyConditionalSymbol}{\vDash_{\frak
A}(\alpha\rightarrow\varphi)[s]}) \\
&amp; \Leftrightarrow &amp; \Gamma\vDash(\alpha\rightarrow\varphi) &amp;
(\text{   definition of logical imply})
\end{array}
\]</span></cr></p>
<p>(b)<cr> <span class="math display">\[
\begin{array}{lcll}
\varphi\tauequ\psi &amp; \Leftrightarrow &amp;
\varphi\vDash\psi\land\psi\vDash\varphi \\
&amp; \Leftrightarrow &amp;
\vDash(\varphi\rightarrow\psi)\land\vDash(\psi\rightarrow\varphi) &amp;
(\text{according to (a)}) \\
&amp; \Leftrightarrow &amp; \forall{\frak A}\forall{s}(\vDash_{\frak
A}(\varphi\rightarrow\psi)[s]\land\vDash_{\frak
A}(\psi\rightarrow\varphi)[s]) \\
&amp; \Leftrightarrow &amp; \forall{\frak A}\forall{s}(\vDash_{\frak
A}(\varphi\rightarrow\psi\land\psi\rightarrow\varphi)[s]) \\
&amp; \Leftrightarrow &amp; \vDash(\varphi\leftrightarrow\psi)
\end{array}
\]</span></cr></p>
<h5 id="problem-2">Problem 2 <span id="Problem2.2-2"></span></h5>
<p>Show that no one of the following sentences is logically implied by
the other two. (This is done by giving a structure in which the sentence
in question is false, while the other two are true.)</p>
<ol type="a">
<li><span class="math inline">\(\forall{x}\forall{y}\forall{z}(Pxy\rightarrow
Pyz\rightarrow Pxz).\)</span> Recall that by our convention <span class="math inline">\(\alpha\rightarrow\beta\rightarrow\gamma\)</span>
is <span class="math inline">\(\alpha\rightarrow(\beta\rightarrow\gamma).\)</span></li>
<li><span class="math inline">\(\forall{x}\forall{y}(Pxy\rightarrow
Pyx\rightarrow x=y).\)</span></li>
<li><span class="math inline">\(\forall{x}\exists{y}Pxy\rightarrow\exists{y}\forall{x}Pxy.\)</span></li>
</ol>
<p><span class="math inline">\(\PROOF\)</span></p>
<p>Let above wff in a,b and c be <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span>.</p>
<ul>
<li><span class="math inline">\(\alpha\)</span> is a <a href="\48e9c4af#Transitive">transitive relation</a></li>
<li><span class="math inline">\(\beta\)</span> is a <a href="\48e9c4af#Anti-symmetric">anti-symmetric relation</a></li>
<li><span class="math inline">\(\gamma\)</span> describe a relation in
which if for every element, there is a greater one then there is a
maximal element.</li>
</ul>
<p>Three different structures will be constructed below in which one
sentence in question is false, while the other two are true.</p>
<ol type="1">
<li><p><span class="math inline">\({\frak A} = ({\Bbb
N};\forall,=,\le)\)</span>, in which</p>
<ul>
<li><span class="math inline">\(|{\frak A}| = {\Bbb N}\)</span></li>
<li><span class="math inline">\(P_{\frak A} = \le\)</span></li>
</ul></li>
</ol>
<p>Then obviously <span class="math inline">\(\vDash_{\frak
A}\alpha\)</span>, <span class="math inline">\(\vDash_{\frak
A}\beta\)</span>, but <span class="math inline">\(\nvDash_{\frak
A}\gamma\)</span>. So <span class="math inline">\(\{\alpha,\beta\}\nvDash\gamma\)</span></p>
<ol start="2" type="1">
<li><p>Say that <span class="math inline">\({\frak B}\)</span> is
defined as below:</p>
<ul>
<li><span class="math inline">\(|{\frak B}| = \{a,b\}\)</span></li>
<li><span class="math inline">\(P_{\frak B} = \{\langle
a,a\rangle,\langle a,b\rangle,\langle b,a\rangle,\langle
b,b\rangle\}\)</span></li>
</ul></li>
</ol>
<p>Then obviously <span class="math inline">\(\vDash_{\frak
B}\alpha\)</span>, <span class="math inline">\(\vDash_{\frak
B}\gamma\)</span>. But <span class="math inline">\(\nvDash_{\frak
B}\beta\)</span> because <span class="math inline">\(Pab\)</span>, <span class="math inline">\(Pba\)</span> exists, but <span class="math inline">\(a\neq b\)</span>. So <span class="math inline">\(\{\alpha,\gamma\}\nvDash\beta\)</span>.</p>
<ol start="3" type="1">
<li><p>Say that <span class="math inline">\({\frak C}\)</span> is
defined as below:</p>
<ul>
<li><span class="math inline">\(|{\frak C}| = \{a,b,c\}\)</span></li>
<li><span class="math inline">\(P_{\frak C} = \{\langle
a,b\rangle,\langle b,c\rangle\}\)</span></li>
</ul></li>
</ol>
<p>Then <span class="math inline">\(\vDash_{\frak C}\beta\)</span>,
because there is no <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> such that <span class="math inline">\(Pxy\)</span> and <span class="math inline">\(Pyx\)</span>. <span class="math inline">\(\vDash_{\frak B}\gamma\)</span> because not for
every <span class="math inline">\(x\)</span> there is <span class="math inline">\(y\)</span> such that <span class="math inline">\(Pxy\)</span>. But <span class="math inline">\(\nvDash_{\frak B}\alpha\)</span> because there is
no <span class="math inline">\(Pac\)</span>. <span class="math inline">\(\{\beta,\gamma\}\nvDash\alpha\)</span></p>
<p>In summary, no one of the three sentences in question is logically
implied by the other two.<span class="math inline">\(\dashv\)</span></p>
<h5 id="problem-3">Problem 3 <span id="Problem2.2-3"></span></h5>
<p>Show that <span class="math display">\[\{\forall{x}(\alpha\rightarrow\beta),\forall{x}\alpha\}\vDash\forall{x}\beta\]</span></p>
<p><span class="math inline">\(\PROOF\)</span></p>
<p>For <span class="math inline">\(\forall{\frak A}\)</span>, <span class="math inline">\(\forall{s},\hspace1ex s:V\rightarrow|{\frak
A}|\)</span> such that <span class="math inline">\(\vDash_{\frak
A}\forall{x}(\alpha\rightarrow\beta)[s]\)</span> and <span class="math inline">\(\vDash_{\frak A}\forall{x}\alpha[s]\)</span></p>
<p>According to the definition of <a href="/1eec0e97#SatisfyQuantifierSymbol">Satisfy of Quantifier
Symbol</a>, we have</p>
<p><span class="math display">\[
\eqalignno{
\forall d\in|{\frak A}|, &amp;\vDash_{\frak
A}\alpha\rightarrow\beta[s(x|d)] &amp; (\dagger) \\
\forall d\in|{\frak A}|, &amp;\vDash_{\frak A}\alpha[s(x|d)] &amp;
(\ddagger)
}
\]</span></p>
<p>For wff <span class="math inline">\(\dagger\)</span>, according to
the definition of <a href="/1eec0e97#SatisfyConditionalSymbol">Satisfy
of Conditional Symbol</a>, either <span class="math inline">\(\nvDash_{\frak A}\alpha[s(x|d)]\)</span> or <span class="math inline">\(\vDash_{\frak A}\beta[s(x|d)]\)</span> or both.
From <span class="math inline">\(\ddagger\)</span>, <span class="math inline">\(\forall{d}\in|{\frak A}|, \vDash_{\frak
A}\beta[s(x|d)]\)</span>. So <span class="math inline">\(\vDash_{\frak
A}\forall{x}\beta\)</span></p>
<p>According to definition of <a href="#LogicallyImply">Logically
Imply</a>, we have the wff in question. <span class="math inline">\(\dashv\)</span></p>
<h5 id="problem-4">Problem 4 <span id="Problem2.2-4"></span></h5>
<p>Show that if <span class="math inline">\(x\)</span> does not occur
free in <span class="math inline">\(\alpha\)</span>, then <span class="math inline">\(\alpha\vDash\forall{x}\alpha\)</span>.</p>
<p><span class="math inline">\(\PROOF\)</span></p>
<p>For any <span class="math inline">\({\frak A}\)</span>, and any <span class="math inline">\(s\)</span>, <span class="math inline">\(s:V\rightarrow|{\frak A}|\)</span> such that <span class="math inline">\(\vDash_{\frak A}\forall{x}\alpha[s]\)</span>.</p>
<p>According to <a href="#Theorem22A">Theorem 22A</a> and the condition
<span class="math inline">\(x\)</span> isn't <a href="#OccurFree">free
variable</a>.</p>
<p>For any function <span class="math inline">\(s(x|d)\)</span>, <span class="math inline">\(\vDash_{\frak A}\alpha[s(x|d)]\)</span>. Because
<span class="math inline">\(s(x|d)\)</span> agree at all variables that
occur free for <span class="math inline">\(\forall{d}\in |{\frak
A}|\)</span>.</p>
<p>Based on the definition of <a href="/1eec0e97#SatisfyQuantifierSymbol">satisfy quantifier symbol</a>,
<span class="math inline">\(\vDash_{\frak
A}\forall{x}\alpha[s]\)</span></p>
<p>Based on the definition of <a href="#LogicallyImply">logical
implication</a>, <span class="math inline">\(\alpha\vDash\forall\alpha\)</span>.</p>
<h5 id="problem-5">Problem 5 <span id="Problem2.2-5"></span></h5>
<p>Show that the formula <span class="math inline">\(x=y\rightarrow
Pzfx\rightarrow Pzfy\)</span> (where <span class="math inline">\(f\)</span> is a one-place function symbol and
<span class="math inline">\(P\)</span> is a two-place predicate symbol)
is valid.</p>
<p><span class="math inline">\(\PROOF\)</span></p>
<p><span class="math display">\[
\begin{array}{lll}
&amp;x=y\rightarrow Pzfx\rightarrow Pzfy\text{ is valid.} \\
\Leftrightarrow&amp;\forall{\frak A}\text{ and }\forall{s},
\vDash_{\frak A}x=y\rightarrow Pzfx\rightarrow Pzfy[s] &amp; ( \href{
#ValidWff}{\text{Definition of valid wff}} ) \\
\Leftrightarrow&amp;\text{either }\nvDash_{\frak A}x=y[s]\text{ or
}\vDash_{\frak A}Pzfx\rightarrow Pzfy[s] &amp; ( \href{
#SatisfyConditionalSymbol}{\text{Definition of Satisfy}} )\\
\Leftrightarrow&amp;\nvDash_{\frak A}x=y[s]\text{ or }\nvDash_{\frak
A}Pzfx[s]\text{ or }\vDash_{\frak A}Pzfy[s] \\
\end{array}
\]</span></p>
<p>So as long as we can proof one of wffs <span class="math inline">\(\nvDash_{\frak A}x=y[s]\)</span>, <span class="math inline">\(\nvDash_{\frak A}Pzfx[s]\)</span> and <span class="math inline">\(\vDash_{\frak A}Pzfy[s]\)</span> holds, the wff in
question is valid.</p>
<p>If <span class="math inline">\(s(x)\neq s(y)\)</span>, according to
definition of <a href="/1eec0e97#SatisfyEqualitySymbol">satisfy</a> the
first wff holds.</p>
<p>If <span class="math inline">\(s(x)=s(y)\)</span>, and according to
definition of <a href="/1eec0e97#Overlines">extension of <span class="math inline">\(s\)</span></a>, we have <span class="math display">\[\overline{s}(fx)=f(s(x))=f(s(y))=\overline{s}(fx).\]</span></p>
<p>Then relations <span class="math inline">\(\langle
z,fx\rangle\)</span> and <span class="math inline">\(\langle
z,fy\rangle\)</span> either both belong to <span class="math inline">\(P^{\frak A}\)</span> or neither of them belong to
<span class="math inline">\(P^{\frak A}\)</span>.</p>
<p>So that means one of wffs <span class="math inline">\(\nvDash_{\frak
A}Pzfx[s]\)</span> and <span class="math inline">\(\vDash_{\frak
A}Pzfy[s]\)</span> holds. <span class="math inline">\(\dashv\)</span></p>
<h5 id="problem-6">Problem 6 <span id="Problem2.2-6"></span></h5>
<p>Show that a formula <span class="math inline">\(\theta\)</span> is
valid iff <span class="math inline">\(\forall x\theta\)</span> is
valid.</p>
<h5 id="problem-7">Problem 7 <span id="Problem2.2-7"></span></h5>
<p>Restate the definition of "<span class="math inline">\({\frak
A}\)</span> Satisfies with s" in the way described on page 84. That is,
define by recursion a function <span class="math inline">\(\overline{h}\)</span> such that <span class="math inline">\({\frak A}\)</span> satisfies <span class="math inline">\(\varphi\)</span> with <span class="math inline">\(s\)</span> iff <span class="math inline">\(s\in\overline{h}(\varphi)\)</span>.</p>
<h5 id="problem-8">Problem 8 <span id="Problem2.2-8"></span></h5>
<p>Assumeme that <span class="math inline">\(\Sigma\)</span> is a set of
sentences such that for any sentencese <span class="math inline">\(\tau\)</span>, either <span class="math inline">\(\Sigma\vDash\tau\)</span> or <span class="math inline">\(\Sigma\vDash\lnot\tau\)</span>. Assume that <span class="math inline">\({\frak A}\)</span> is a model of <span class="math inline">\(\Sigma\)</span>. Show that for any sentence <span class="math inline">\(\tau\)</span>, we have <span class="math inline">\({\frak A}\tau\)</span> iff <span class="math inline">\(\Sigma\vDash\tau\)</span>.</p>
<h5 id="problem-9">Problem 9 <span id="Problem2.2-9"></span></h5>
<p>Assume that the language has equality and a two-place predicate
symbol <span class="math inline">\(P\)</span>. For each of the following
conditions, find a sentence <span class="math inline">\(\sigma\)</span>
such that the structure <span class="math inline">\({\frak A}\)</span>
is a model of <span class="math inline">\(\sigma\)</span> iff the
condition is met.</p>
<ol type="a">
<li><span class="math inline">\(|{\frak A}|\)</span> has exactly two
members.</li>
<li><span class="math inline">\(P^{\frak A}\)</span> is a function from
<span class="math inline">\(|{\frak A}|\)</span> into <span class="math inline">\(|{\frak A}|\)</span>. (A function is a
single-valued relation, as in Chapter 0. For <span class="math inline">\(f\)</span> to be a function from <span class="math inline">\(A\)</span> into <span class="math inline">\(B\)</span>, the domain of <span class="math inline">\(f\)</span> must be all of <span class="math inline">\(A\)</span>; the range of <span class="math inline">\(f\)</span> is a subset, not necessarily proper, of
<span class="math inline">\(B\)</span>.)</li>
<li><span class="math inline">\(P^{\frak A}\)</span> is a permutation of
<span class="math inline">\(|{\frak A}|\)</span>; i.e., <span class="math inline">\(P^{\frak A}\)</span> is a one-to-one function with
domain and range equal to <span class="math inline">\(|{\frak
A}|\)</span>.</li>
</ol>
<h5 id="problem-10">Problem 10 <span id="Problem2.2-10"></span></h5>
<p>Show that <span class="math display">\[
\vDash_{\frak A}\forall v_2 Qv_1 v_2\llbracket c^{\frak
A}\rrbracket\quad\text{iff}\quad\vDash_{\frak A}\forall v_2 Qcv_2.
\]</span></p>
<h5 id="problem-11">Problem 11 <span id="Problem2.2-11"></span></h5>
<p>For each of the following relations, give a formula which defines it
in (<span class="math inline">\(\Bbb{N}\)</span>;+,<span class="math inline">\(\cdot\)</span>). (The language is assumed to have
equality and the parameters <span class="math inline">\(\forall\)</span>, <span class="math inline">\(+\)</span>, and <span class="math inline">\(\cdot\)</span>).</p>
<ol type="a">
<li><span class="math inline">\(\{0\}\)</span>.</li>
<li><span class="math inline">\(\{1\}\)</span>.</li>
<li><span class="math inline">\(\{\langle m, n\rangle | n \text{ is the
successor of } m \text{ in }\Bbb{N}\}\)</span>.</li>
<li><span class="math inline">\(\{\langle m, n\rangle | m &lt; n \text{
in } \Bbb{N}\}\)</span>.</li>
</ol>
<p><em>Digression</em>: This is merely the tip of the iceberg. A
relation on <span class="math inline">\(\Bbb{N}\)</span> is said to be
<em>arithmetical</em> if it is definable in this structure. All
decidable relations are arithmetical, as are many others. The
arithmetical relations can be arranged in a hierarchy; see Section
3.5.</p>
<h5 id="problem-12">Problem 12 <span id="Problem2.2-12"></span></h5>
<p>Let <span class="math inline">\({\frak R}\)</span> be the structure
<span class="math inline">\((\Bbb{R};+,\cdot)\)</span>. (The language is
assumed to have equality and the parameters <span class="math inline">\(\forall\)</span>, <span class="math inline">\(+\)</span>, and <span class="math inline">\(\cdot\)</span>. <span class="math inline">\({\frak
R}\)</span> is the structure whose universe is the set <span class="math inline">\(\Bbb{R}\)</span> of real numbers and such that
<span class="math inline">\(+^{\frak R}\)</span> and <span class="math inline">\(\cdot^{\frak R}\)</span> are the usual addition
and multiplication operations.)</p>
<ol type="a">
<li>Give a formula that defines in <span class="math inline">\({\frak
R}\)</span> the interval <span class="math inline">\([0,\infty)\)</span>.</li>
<li>Give a formula that defines in <span class="math inline">\({\frak
R}\)</span> the set <span class="math inline">\({2}\)</span>.</li>
<li><span class="math inline">\(^*\)</span>Show that any finite union of
intervals, the endpoints of which are algebraic, is definable in <span class="math inline">\({\frak R}\)</span>. (The converse is also true;
these are the only definable sets in the structure. But we will not
prove this fact.)</li>
</ol>
<h5 id="problem-13">Problem 13 <span id="Problem2.2-13"></span></h5>
<p>Prove part (a) of the homomorphism theorem.</p>
<h5 id="problem-14">Problem 14 <span id="Problem2.2-14"></span></h5>
<p>What subsets of the real line <span class="math inline">\(\Bbb{R}\)</span> are definable in <span class="math inline">\((\Bbb{R};&lt;)\)</span>? What subsets of the plane
<span class="math inline">\(\Bbb{R}\times\Bbb{R}\)</span> are definable
in <span class="math inline">\((\Bbb{R};&lt;)\)</span>?</p>
<p><em>Remarks</em> : The nice thing about <span class="math inline">\((\Bbb{R};&lt;)\)</span> is that its automorphisms
are exactly the order-preserving maps from R onto itself. But stop after
the binary relations. There are <span class="math inline">\(2^{13}\)</span> definable ternary relations, so
you do not want to catalog all of them.</p>
<h5 id="problem-15">Problem 15 <span id="Problem2.2-15"></span></h5>
<p>Show that the addition relation, <span class="math inline">\(\{\langle m, n, p\rangle | p = m + n\}\)</span>,
is not definable in <span class="math inline">\((\Bbb{N};\cdot)\)</span>. <em>Suggestion</em> :
Consider an automorphism of <span class="math inline">\((\Bbb{N};\cdot)\)</span> that switches two
primes.</p>
<p><em>Digression</em> : Algebraically, the structure of the natural
numbers with multiplication is nothing but the free Abelian semigroup
with <span class="math inline">\(\aleph_0\)</span> generators (viz. the
primes), together with a zero element. There is no way you could define
addition here. If you could define addition, then you could define
ordering (by Exercise 11 and the natural transitivity statement). But
one generator looks just like another. That is, there are <span class="math inline">\(2^{\aleph_0}\)</span> automorphisms--simply
permute the primes. None of them is order-preserving except the
identity.</p>
<h5 id="problem-16">Problem 16 <span id="Problem2.2-16"></span></h5>
<p>Give a sentence having models of size <span class="math inline">\(2n\)</span> for every positive integer <span class="math inline">\(n\)</span>, but no finite models of odd size.
(Here the language should include equality and will have whatever
parameters you choose.)</p>
<p><em>Suggestion</em> : One method is to make a sentence that says,
“Everything is either red or blue, and f is a color-reversing
permutation.”</p>
<p><em>Remark</em> : Given a sentence <span class="math inline">\(\sigma\)</span>, it might have some finite models
(i.e., models with finite universes). Define the <em>spectrum</em> of
<span class="math inline">\(\sigma\)</span> to be the set of positive
integers <span class="math inline">\(n\)</span> such that <span class="math inline">\(\sigma\)</span> has a model of size <span class="math inline">\(n\)</span>. This exercise shows that the set of
even numbers is a spectrum.</p>
<p>For example if <span class="math inline">\(\sigma\)</span> is the
conjunction of the field axioms (there are only finitely many, so we can
take their conjunction), then its spectrum is the set of powers of
primes. This fact is proved in any course on finite fields. The spectrum
of <span class="math inline">\(\lnot\sigma\)</span>, by contrast, is the
set of all positive integers (non-fields come in all sizes).</p>
<p>Günter Asser in 1955 raised the question: Is the complement of every
spectrum a spectrum? Once you realize that simply taking a negation does
not work (cf. the preceding paragraph), you see that this is a
nontrivial question. In fact the problem, known as the spectrum problem,
is still open. But modern work has tied it to another open problem,
whether or not co-NP=NP.</p>
<h5 id="problem-17">Problem 17 <span id="Problem2.2-17"></span></h5>
<ol type="a">
<li>Consider a language with equality whose only parameter (aside from
<span class="math inline">\(\forall\)</span>) is a two-place predicate
symbol <span class="math inline">\(P\)</span>. Show that if <span class="math inline">\({\frak A}\)</span> is finite and <span class="math inline">\(A\equiv B\)</span>, then <span class="math inline">\({\frak A}\)</span> is isomorphic to <span class="math inline">\({\frak B}\)</span>. <em>Suggestion</em> : Suppose
the universe of <span class="math inline">\({\frak A}\)</span> has size
<span class="math inline">\(n\)</span>. Make a single sentence <span class="math inline">\(\sigma\)</span> of the form <span class="math inline">\(\exists v_1\cdots\exists v_n\theta\)</span> that
describes A “completely.” That is, on the one hand, <span class="math inline">\(\sigma\)</span> must be true in <span class="math inline">\({\frak A}\)</span>. And on the other hand, any
model of <span class="math inline">\(\sigma\)</span> must be exactly
like (i.e., isomorphic to) <span class="math inline">\({\frak
A}\)</span>.</li>
<li><span class="math inline">\(^*\)</span>Show that the result of part
(a) holds regardless of what parameters the language contains.</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>在Virtual Box安装CentOS Stream 8</title>
    <url>//2a4da3e0/</url>
    <content><![CDATA[<p>一直使用CentOS 7, 最近才发现发现CentOS发布有个大的改变. 具体可以见<a href="https://blog.csdn.net/taoofcode/article/details/120480889">这篇介绍</a></p>
<p>正好最近想装一个linux系统做些实验. 这里记录一下安装的过程.</p>
<span id="more"></span>
<ol type="1">
<li>Download and install <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a></li>
<li>从这个地址<a href="http://isoredirect.centos.org/centos/8-stream/isos/x86_64">http://isoredirect.centos.org/centos/8-stream/isos/x86_64</a>下载CentOS
strem 8 iso image</li>
<li>新建一个虚拟磁盘, 然后挂载iso image作为光盘.
启动安装centos都很直观.</li>
<li>启动后需要到如下这个地方点击, <img src="/2a4da3e0//VBoxGuestAdditions.png" class title="安装增强功能">
然后到linux里的<code>/run/media</code>里面执行<code>sudo sh VBoxLinuxAdditions.run</code></li>
<li>到host的virtual
box界面里面的<code>设置-&gt;显示-&gt;远程桌面</code>里启动服务.</li>
<li>查看host的ip, 找到VirtualBox Host-Only Network的ip,
然后用mstsc访问这个ip, mstsc比起virtualBox本来的窗口要好用得多.</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>linux</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>VirtualBox</tag>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>无理数指数, 复数指数, 欧拉公式, 复对数</title>
    <url>//c9b396ad/</url>
    <content><![CDATA[<h2 id="起因">起因</h2>
<p>起因是最近在努力想把傅立叶级数和傅立叶变换重学一遍, 完全搞懂.
傅立叶变换用欧拉公式转换成复系数的形式看起来是非常优雅的.
但是遗憾我已经不记得欧拉公式是怎么来的了. 上网查了些资料,
终于搞清楚了.</p>
<p>先把欧拉公式写在这里:</p>
<p><span class="math display">\[
\forall x \in \mathbb{R}, \quad
\begin{equation*}
e^{ix} = \cos x + i \sin x
\end{equation*}
\]</span></p>
<p>这里<span class="math inline">\(\mathrm{e}\)</span>是自然对数的底,
也叫欧拉数. <span class="math inline">\(\mathrm{e} \approx
2.718\)</span>. <span class="math inline">\(i\)</span>是虚数单位.</p>
<p>这个公式右边是一个关于<span class="math inline">\(x\)</span>的三角函数, 函数值落在复数数域里,
也就是一个<span class="math inline">\(\mathbb{R} \mapsto
\mathbb{C}\)</span>的映射.</p>
<p>而左边是一个指数为复数的指数函数. 可是,
指数为复数的幂运算是怎么定义的? 所以为了搞清楚所有这些概念.
需要把复数域幂运算, 复数域对数运算一起串起来.
写了这篇总结相信再不会忘记了.</p>
<span id="more"></span>
<h2 id="幂运算">幂运算</h2>
<h3 id="整数指数">整数指数</h3>
<p>先来回顾一下初等代数里关于幂运算的内容.</p>
<ol type="1">
<li>最最开始, 我们见到的<span class="math inline">\(x^n\)</span>运算里,
<span class="math inline">\(x \in \mathbb{R}, \quad n \in
\mathbb{Z}^+\)</span>. 在这个限制下, 幂运算的定义为<span class="math inline">\(n\)</span>个<span class="math inline">\(x\)</span>自乘.</li>
<li>规定<span class="math inline">\(x^0=1\)</span></li>
<li>若<span class="math inline">\(x \neq 0\)</span>, 定义<span class="math inline">\(\displaystyle x^{-n}=\frac{1}{x^n}\)</span></li>
</ol>
<p>这三个合在一起将运算<span class="math inline">\(x^n\)</span>里的<span class="math inline">\(n\)</span>延拓到整数域.
根据这几个定义可以轻松证明下列幂运算的运算性质.</p>
<ol type="a">
<li><p>同底数相乘除,指数相加减: <span class="math display">\[
\begin{equation}
\begin{aligned}
x^a \times x^b = x^{a+b} \\
\frac{x^a}{x^b} = x^{a-b}
\end{aligned}
\end{equation} \label{eq:sameBaseTimesDivide}
\]</span></p></li>
<li><p>幂的幂,指数相乘: <span class="math display">\[
\begin{equation}
\begin{aligned}
(x^a)^b = x^{(a \times b)}
\end{aligned}
\end{equation} \label{eq:powerPower}
\]</span></p></li>
<li><p>指数分配: <span class="math display">\[
\begin{equation}
\begin{aligned}
(x \times y)^z=x^z \times y^z \\
\left({\frac{x}{y}}\right)^z=\frac{x^z}{y^z}
\end{aligned}
\end{equation} \label{eq:powerDistributiveLaw}
\]</span></p></li>
</ol>
<p>我们也可以轻松证明, 把运算里的底数<span class="math inline">\(x\)</span>延拓到整个非零复数域,
这些运算性质依然成立.</p>
<h3 id="正实数底的实数指数次幂">正实数底的实数指数次幂</h3>
<p>如果我们在运算<span class="math inline">\(a^x\)</span>中把底数<span class="math inline">\(a\)</span>的定义域限定到正实数. 对于<span class="math inline">\(\forall a \in \mathbb{R}^+\)</span>, <span class="math inline">\(a^x\)</span>变为关于<span class="math inline">\(x\)</span>的指数函数.
进一步延拓指数的定义范围.</p>
<ol start="4" type="1">
<li>若<span class="math inline">\(\displaystyle x=\frac{1}{n}, \quad n
\in \mathbb{Z}^+\)</span>, 定义<span class="math inline">\(a^x\)</span>为<span class="math inline">\(\sqrt[n]{a}\)</span>的正实数根.</li>
<li>若<span class="math inline">\(\displaystyle x=\frac{m}{n}, \quad n
\in \mathbb{Z}^+, \quad m \in \mathbb{Z}\)</span>, 定义<span class="math inline">\(a^x = \sqrt[n]{a^m}\)</span></li>
</ol>
<p>由于已知有理数是跟分数一一对应的可数集合.
所以上面的定义5就把指数延拓到整个有理数集合了.</p>
<h4 id="无理数指数">无理数指数</h4>
<p>我们肯定希望我们定义的无理数指数可以使指数函数<span class="math inline">\(a^x\)</span>是个连续函数.
所以可以用极限来定义无理数指数. 已知无理数为无限不循环小数,
所以可以做出两个有理数数列来趋近这个无理数. 设<span class="math inline">\(x=\alpha\)</span>是无理数, 我们取其前n位有效数字,
舍去剩下的小数得到的值为<span class="math inline">\(r_n\)</span>.
取其前<span class="math inline">\(n-1\)</span>个有效数字加上第n个有效数字进位得到的值为<span class="math inline">\(s_n\)</span>. 称<span class="math inline">\(\{r_n\}\)</span>为不足近似值数列, <span class="math inline">\(\{s_n\}\)</span>为过剩近似值数列. 举个例子,
对于<span class="math inline">\(\pi\)</span>来讲:</p>
<p><span class="math display">\[
\begin{align*}
\{r_n\} &amp;= \{3,\: 3.1,\: 3.14,\: 3.141,\: 3.1415\} \\
\{s_n\} &amp;= \{4,\: 3.2,\: 3.15,\: 3.142,\: 3.1416\}
\end{align*}
\]</span></p>
<p>由这两个数列的定义可知<span class="math inline">\(\{r_n\}\)</span>单调递增, <span class="math inline">\(\{s_n\}\)</span>单调递减. 且<span class="math inline">\(\alpha = sup\{r_n\}=inf\{s_n\}\)</span> (<span class="math inline">\(sup\)</span>是上确界, <span class="math inline">\(inf\)</span>是下确界). 易知<span class="math inline">\(\displaystyle\lim_{n \to +\infty}{r_n} = \lim_{n
\to +\infty}{s_n} = \alpha\)</span>, 则 <span class="math display">\[\begin{equation}\lim_{n \to +\infty}{s_n - r_n} =
0 \end{equation}\]</span></p>
<p>下面只需要证明这两个极限<span class="math inline">\(\displaystyle\lim_{n \to +\infty}
{a^{r_n}}\)</span>和<span class="math inline">\(\displaystyle\lim_{n \to
+\infty} {a^{s_n}}\)</span>都存在且相等,
就可以用这个极限来定义一个实数的无理数指数了.</p>
<p>先假设<span class="math inline">\(a&gt;1\)</span>,
由于我们要定义无理数指数使指数函数<span class="math inline">\(a^x\)</span>在实数域上是个连续函数,
而已知这个指数函数当<span class="math inline">\(a&gt;1\)</span>时是个单调递增函数.
所以我们定义的无理数指数一定是使不等式<span class="math inline">\(a^{r_n} &lt; a^\alpha &lt; a^{s_n}\)</span>成立.
由于单调有界数列必有极限. 所以这两个极限<span class="math inline">\(\displaystyle\lim_{n \to
+\infty}{a^{r_n}}\)</span>和<span class="math inline">\(\displaystyle\lim_{n \to
+\infty}{a^{s_n}}\)</span>都存在. 由下式可知</p>
<p><span class="math display">\[
\begin{equation}
\displaystyle\frac{\lim_{n \to +\infty}{a^{s_n}}}{\lim_{n \to
+\infty}{a^{r_n}}} = \lim_{n \to +\infty}{\frac{a^{s_n}}{a^{r_n}}} =
\lim_{n \to +\infty}{a^{s_n-r_n}}=1
\end{equation}
\]</span></p>
<p>对于<span class="math inline">\(0&lt;a&lt;1\)</span>的情况,
可以用相同的办法讨论, 只有单调方向不同. <span class="math inline">\(a=1\)</span>的清况是平凡的.</p>
<p>6-1. 若<span class="math inline">\(x=\alpha\)</span>为无理数,
定义指数函数<span class="math inline">\(\displaystyle a^\alpha = \lim_{n
\to +\infty}{a^{r_n}} = \lim_{n \to +\infty}{a^{s_n}}\)</span></p>
<p>到此为止, 幂运算, 底数为正实数, 指数为全体实数,
值为正实数的各种情况已经被很好的定义了.
而且这些定义都可以让前面提到的几条指数运算性质成立. 但后面我们会看到,
一旦我们把指数运算延拓到复数, 有些运算性质就不再成立了.</p>
<p>我们可以看到这里的定义虽然直观, 理解起来容易. 但总感觉不够美观,
跟之前的定义不够统一. 其实这里还有其他的定义方法,
我们先列出这个定义方法.</p>
<p>6-2. 对于任意实数<span class="math inline">\(a\)</span>, <span class="math inline">\(a&gt;0\)</span>, 以及任意实数<span class="math inline">\(x\)</span>, 定义<span class="math inline">\(a^x =
\mathrm{e}^{x \cdot \ln{a}}\)</span></p>
<p>这个定义看起来好像是个循环定义, <span class="math inline">\(\mathrm{e}\)</span>的无理数次幂不也还没定义呢么.
所以如果想这个定义成立, 还得先用别的办法定义<span class="math inline">\(\mathrm{e}\)</span>的实数次幂.</p>
<h4 id="mathrme的实数次幂"><span class="math inline">\(\mathrm{e}\)</span>的实数次幂</h4>
<p>这里有两种办法可以定义<span class="math inline">\(\mathrm{e}\)</span>的实数次幂</p>
<p>方法1, 直接利用极限.</p>
<p>首先我们已知<span class="math inline">\(&quot;\mathrm{e}\)</span>可以通过极限<span class="math inline">\(\displaystyle\lim_{n \to +\infty}{\left(1 +
\frac{1}{n}\right)^n}\)</span>来定义.</p>
<p>那么对于任意实数<span class="math inline">\(x\)</span>, 可以定义<span class="math inline">\(\displaystyle\mathrm{e}^x=\lim_{n \to
+\infty}{\left(1+\frac{x}{n}\right)^n}\)</span></p>
<p>可以简单证明在<span class="math inline">\(x\)</span>为正整数的时候,
上述定义跟之前的自乘的定义可以互相推导.</p>
<p><span class="math display">\[
\begin{align*}
\mathrm{e}^k &amp;= \left[\lim_{n \to \infty
}{\left(1+\frac{1}{n}\right)^n}\right]^k \\
&amp;=\lim_{n \to \infty }{\left[\left(1+\frac{1}{n}\right)^n\right]^k}
\\
&amp;=\lim_{n\cdot k \to \infty }{\left(1+\frac{k}{n \cdot
k}\right)^{n\cdot k}} \\
&amp;=\lim_{m \to \infty}{\left(1+\frac{k}{m}\right)^m}
\end{align*}
\]</span></p>
<p>方法2, 使用泰勒级数定义</p>
<p><span class="math display">\[
\mathrm{e}^x = 1+x+\frac{x^2}{2!}+\frac{x^3}{3!} + \cdots =
\sum_{n=0}^{+\infty}{\frac{x^n}{n!}}
\]</span></p>
<p>有了这个<span class="math inline">\(\mathrm{e}^x\)</span>的定义,
任何正实数的实数次幂都可以统一定义成6-2的形式.
甚至复数也可以统一成这个定义.</p>
<h3 id="正实数底的复数次幂">正实数底的复数次幂</h3>
<p>跟前面实数一样, 想要把任何正实数的复数次幂也定义成6-2的式子,
必须先定义<span class="math inline">\(\mathrm{e}\)</span>的复数次幂.
这就终于要轮到欧拉公式出场了.</p>
<h4 id="欧拉公式">欧拉公式</h4>
<p>对于任意实数<span class="math inline">\(x\)</span>, 任意复数<span class="math inline">\(z=a+bi\)</span>, 可以证明: <span class="math display">\[
\begin{align*}
\mathrm{e}^{ix} &amp;= \cos x+i\cdot\sin x \\
\mathrm{e}^z &amp;= \mathrm{e}^a(\cos b+i\cdot\sin b)
\end{align*}
\]</span> 证明有多种方法, 比如用泰勒级数也可以证明. 首先把<span class="math inline">\(\mathrm{e}^x\)</span>, <span class="math inline">\(\cos x\)</span>, 和<span class="math inline">\(\sin x\)</span>的泰勒级数展开写出来作为已知条件:
<span class="math display">\[
\begin{align*}
&amp;\mathrm{e}^x = 1+x+\frac{x^2}{2!}+\frac{x^3}{3!} + \cdots \\
&amp;\cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} +
\cdots \\
&amp;\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} +
\cdots
\end{align*}
\]</span> 将<span class="math inline">\(x=iy\)</span>带入<span class="math inline">\(\mathrm{e}^x\)</span>可简单的证明欧拉公式得.</p>
<h4 id="定义">定义</h4>
<p>有了欧拉公式, 再定义正实数的复数次幂就容易了. 形式重复6-2.</p>
<ol start="7" type="1">
<li>若<span class="math inline">\(a\)</span>是一个正实数, <span class="math inline">\(z\)</span>是任何复数, <span class="math inline">\(a^z\)</span>可以定义成<span class="math inline">\(\mathrm{e}^{z\cdot\ln(a)}\)</span>.</li>
</ol>
<h3 id="非零复数的复数次幂">非零复数的复数次幂</h3>
<p>定义7已经将指数延拓到整个复数, 现在开始考察底数的进一步延拓.
之前之所以一直限定底数为正实数, 是因为初等数学里定义7里出现的<span class="math inline">\(\ln a\)</span>的自变量是正实数.
但我们现在有了欧拉公式, 可以把对数运算延拓到复数范围.</p>
<h4 id="复平面上的对数运算">复平面上的对数运算</h4>
<p>对数函数在正实数定义域上的定义是指数函数的反函数, 或者说<span class="math inline">\(x=\ln a\)</span>里<span class="math inline">\(x\)</span>是方程<span class="math inline">\(\mathrm{e}^x=a\)</span>的唯一解. 在复数范围内,
也可以将<span class="math inline">\(z=ln(a+bi)\)</span>定义成方程<span class="math inline">\(\mathrm{e}^z=a+bi\)</span>的解, 但这个解并不唯一.
换句话说复指数函数的反函数是个多值函数.</p>
<p>考虑复数<span class="math inline">\(w=a+bi\)</span>的几何意义,
把复平面从a,b为轴的笛卡尔坐标系转换成极坐标, 定义<span class="math inline">\(\sqrt{a^2+b^2}\)</span>为复数<span class="math inline">\(w\)</span>的模. 表示为<span class="math inline">\(|w|\)</span>.
定义从正实数轴到复数在复平面上的对应的向量所成的角叫做辐角, 记为Arg(w).
由几何意义易知一个复数点对应的辐角是相差<span class="math inline">\(2k\pi\)</span>的无穷多个角度值, 其中在<span class="math inline">\((-\pi,\pi]\)</span>的那个值叫做辐角主值, 记为<span class="math inline">\(\theta\)</span>.
根据欧拉公式上这些定义可以算出对数以<span class="math inline">\(\mathrm{e}\)</span>为底的对数<span class="math inline">\(\mathrm{Ln}w = \ln |w|+i(\theta+2k\pi)\)</span>,
其中<span class="math inline">\(k\)</span>为整数.
注意这里用的是大写L开头, 代表多值函数, 如果我们限定辐角必须是辐角主值,
就又变成单值函数了, 用<span class="math inline">\(\ln
w\)</span>表示.</p>
<h4 id="定义-1">定义</h4>
<p>结合对数运算和定义7,
可以得到最终复数域中一般幂函数(或指数函数)的定义如下:</p>
<ol start="8" type="1">
<li><span class="math inline">\(w^z=e^{w\cdot \mathrm{Ln}z}, \quad w,z
\in \mathbb{C}, w \neq 0\)</span></li>
</ol>
<h4 id="运算性质">运算性质</h4>
<p>由于我们得到这个最终的定义变为一个多值函数,
这就导致前面提到运算性质<span class="math inline">\(\eqref{eq:powerPower}\)</span>和<span class="math inline">\(\eqref{eq:powerDistributiveLaw}\)</span>不再成立了.</p>
<h2 id="前置知识">前置知识</h2>
<p>数列, 极限, 级数, 泰勒级数</p>
<h2 id="参考网页">参考网页</h2>
<p><a href="http://blog.sciencenet.cn/blog-826653-900633.html">1</a> <a href="https://www.zhihu.com/question/20679434">2</a> <a href="https://zh.wikipedia.org/wiki/%E5%86%AA#cite_note-Denlinger-3">3</a></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>分析</category>
        <category>复变</category>
      </categories>
      <tags>
        <tag>Euler Formula</tag>
        <tag>power function</tag>
        <tag>exponential function</tag>
        <tag>logarithm function</tag>
      </tags>
  </entry>
  <entry>
    <title>A Mathematical Introduction to Logic -- Section 2.4</title>
    <url>//e33671ac/</url>
    <content><![CDATA[<p><span class="math inline">\(\def\tauequ{\mathbin{\vDash\style{display:
inline-block; transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\Dashv{\mathbin{\style{display: inline-block;
transform: scaleX(-1)}{\vDash}}}\)</span> <span class="math inline">\(\def\DEF{\sf{D\scriptsize EF}.\quad}\)</span>
<span class="math inline">\(\def\DEFi{\sf{D\scriptsize
EF}^*.\quad}\)</span> <span class="math inline">\(\def\DEFn{\sf{D\scriptsize EF}_*.\quad}\)</span>
<span class="math inline">\(\def\DEFin{\sf{D\scriptsize
EF}^*_*.\quad}\)</span> <span class="math inline">\(\def\llbracket{\unicode{x27E6}}\)</span> <span class="math inline">\(\def\rrbracket{\unicode{x27E7}}\)</span> <span class="math inline">\(\def\PROOF{\sf{P\scriptsize ROOF}.\quad}\)</span>
<span class="math inline">\(\def\MYNOTE{\sf{M\scriptsize{Y}}\sf{N\scriptsize{OTE}}.\quad}\)</span>
<span class="math inline">\(\def\EXAMPLE{\bf\sf{E\scriptsize{XAMPLES}}\quad}\)</span>
这是一个关于数理逻辑的读书笔记和学习总结, 书名是A Mathematical
Introduction to Logic (以下简称AMIL), 作者<a href="https://en.wikipedia.org/wiki/Herbert_Enderton">Herbert B.
Enderton</a>, University of California</p>
<p>点击<strong><a href="/edd6b774">这里进入AMIL的目录</a></strong></p>
<p>本文是Section 2.4, 内容是介绍演绎计算(Deductive Calculus).</p>
<span id="more"></span>
<div class="note info"><p>由于中文版错误太多, 大部分章节读的是英文第二版,
所以笔记也是中英文夹杂着写的. 英文一般是关键原文. 中文有的是原文的翻译,
有的是我自己的理解, 还有的是 为了做练习写的证明和计算过程.</p>
</div>
<div class="note info"><p>前缀关键字的含义:</p>
<ul>
<li><span class="math inline">\(\DEF\)</span> : 表明后面是概念定义.</li>
<li><span class="math inline">\(^*\)</span> :
表明后面内容并不是数学上的精确表达.</li>
<li><span class="math inline">\(_*\)</span> :
表明后面的内容并不来自于这本书.</li>
<li><span class="math inline">\(\MYNOTE\)</span> :
后面的内容是我用自己的话做的总结,或心得体会</li>
</ul>
</div>
<p>Suppose that <a href="/a55d499/#LogicallyImply"><span class="math inline">\(\Sigma\vDash\tau\)</span></a>.</p>
<ol type="1">
<li>What methods of proof might be required to demonstrate that
fact?</li>
<li>Is there necessarily a proof at all?</li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
这一章是用来回答整本书的前言中提出的四个最需要关注的问题中的<a href="/f4228e25/#Q2">问题2</a> 为了避免自然语言中关于证明概念的混乱,
正式的证明(proof)在这本书里被叫做演绎(deduction). 这一章的目标就是,
给"演绎"提供一个精确的数学概念, 使其在一阶逻辑的语境下是充分的和正确的.
</font></p>
</div>
<h2 id="formal-deductions">Formal Deductions
<span id="FormalDeductions"></span></h2>
<h3 id="演绎的定义">演绎的定义</h3>
<p><span class="math inline">\(\DEF\)</span> A <em>deduction of <span class="math inline">\(\varphi\)</span> from <span class="math inline">\(\Gamma\)</span></em> is a <a href="/48e9c4af/#String">finite sequence</a> <span class="math inline">\(\langle\alpha_0,\ldots, \alpha_n\rangle\)</span>
of <a href="/1eec0e97/#FirstOrderWff">formulas</a> such that <span class="math inline">\(\alpha_n\)</span> is <span class="math inline">\(\varphi\)</span> and for each <span class="math inline">\(k\leq n\)</span>, either</p>
<ol type="a">
<li><span class="math inline">\(\alpha_k\)</span> is in <span class="math inline">\(\Gamma\cup\Lambda\)</span>, or</li>
<li><span class="math inline">\(\alpha_k\)</span> is obtained by modus
ponens from two earlier formulas in the sequence; that is, for some
<span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> less than <span class="math inline">\(k\)</span>, <span class="math inline">\(\alpha_j\)</span> is <span class="math inline">\(\alpha_i\rightarrow\alpha_k\)</span>.</li>
</ol>
<p>If such a deduction exists, we say that <span class="math inline">\(\varphi\)</span> is <em>deducible</em> from <span class="math inline">\(\Gamma\)</span>, or that <span class="math inline">\(\varphi\)</span> is <em>theorem</em> of <span class="math inline">\(\Gamma\)</span><span id="Deduction">, and we
write "<span class="math inline">\(\Gamma\vdash\varphi\)</span>". If
<span class="math inline">\(\Gamma\)</span> is <span class="math inline">\(\varnothing\)</span>, we write "<span class="math inline">\(\vdash\alpha\)</span>" in place of "<span class="math inline">\(\varnothing\vdash\alpha\)</span>". If <span class="math inline">\(\Gamma=\{\varphi\}\)</span>, we write "<span class="math inline">\(\varphi\vdash\alpha\)</span>" in place of "<span class="math inline">\(\{\varphi\}\vdash\alpha\)</span>".</span></p>
<p>Where</p>
<ul>
<li><span class="math inline">\(\Lambda\)</span> is an selected infinite
set of <a href="/1eec0e97/#FirstOrderWff">formulas</a> to be called
logical axioms(逻辑公理)<span id="LogicalAxioms">.</span></li>
<li><span class="math inline">\(\Gamma\)</span> is a set of <a href="/1eec0e97/#FirstOrderWff">formulas</a>.</li>
<li>And the <em>modus ponens</em>(假言推理)<span id="ModusPonens"> is a
rule of inference. It is usually stated: From the formulas <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\alpha\rightarrow\beta\)</span> we may infer <span class="math inline">\(\beta\)</span>:</span></li>
</ul>
<p><span class="math display">\[
\frac{\alpha,\alpha\rightarrow\beta}{\beta}.
\]</span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
Deduction(演绎)被定义为一个finite sequence(有限序列). </font></p>
</div>
<h3 id="归纳原则">归纳原则</h3>
<p><span class="math inline">\(\sf{I\scriptsize{NDUCTION}}\enspace\sf{P\scriptsize{RINCIPLE}}\quad\)</span>(归纳原则)
<span id="FirstOrderInductionPrinciple"> Suppose that <span class="math inline">\(S\)</span> is a set of <a href="/1eec0e97/#FirstOrderWff">wffs</a> that includes <span class="math inline">\(\Gamma\cup\Lambda\)</span> and is closed under
modus ponens. Then <span class="math inline">\(S\)</span> contains every
theorem of <span class="math inline">\(\Gamma\)</span>. Where we say
that a set <span class="math inline">\(S\)</span> of formulas is
<em>closed</em> under modus ponens if whenever both <span class="math inline">\(\alpha\in S\)</span> and <span class="math inline">\(\alpha\rightarrow\beta\in S\)</span> then also
<span class="math inline">\(\beta\in S\)</span></span></p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
这个定义是<a href="/e170cff5/#InductionPrinciple">section
1.4里给出的归纳原则的定义</a>的特例.
书中描述定理的归纳与命题逻辑中归纳合式公式的区别有两点, 一是这里的modus
ponens运算是部分定义的, 一个是生成的定理集合不是<a href="/e170cff5/#FreelyGenerate">自由生成的</a>. 这里什么是部分定义存疑.
</font></p>
</div>
<h3 id="逻辑公理">逻辑公理</h3>
<p><span class="math inline">\(\DEF\)</span> Say that a <a href="/1eec0e97/#FirstOrderWff">wff</a> <span class="math inline">\(\varphi\)</span> is a
<em>generalization</em>(概化)<span id="Generalization"> of <span class="math inline">\(\psi\)</span> iff for some <span class="math inline">\(n\geq 0\)</span> and some variables <span class="math inline">\(x_1,\ldots,x_n\)</span>, <span class="math display">\[
\varphi=\forall x_1\dots\forall x_n\psi.
\]</span> In particular, <span class="math inline">\(n=0\)</span> is
included. It means any <a href="/1eec0e97/#FirstOrderWff">wff</a> is a
generalization of itself.</span></p>
<p>The logical axioms are then all <a href="#Generalization">generalizations</a> of <a href="/1eec0e97/#FirstOrderWff">wffs</a> of the following forms (6
groups)<span id="AnxiomGroups">, where <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are variables and <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are wffs:</span></p>
<ol type="1">
<li><a href="/5a484d90/#Tautology">Tautologies</a>;</li>
<li><span class="math inline">\(\forall
x\alpha\rightarrow\alpha^x_t\)</span>, where t is <a href="#Substitutable">substitutable for <span class="math inline">\(x\)</span> in <span class="math inline">\(\alpha\)</span></a>;</li>
<li><span class="math inline">\(\forall
x(\alpha\rightarrow\beta)\rightarrow(\forall x\alpha\rightarrow\forall
x\beta)\)</span>;</li>
<li><span class="math inline">\(\alpha\rightarrow\forall
x\alpha\)</span>, where <span class="math inline">\(x\)</span> does not
<a href="/1eec0e97/#OccurFree">occur free</a> in <span class="math inline">\(\alpha\)</span></li>
</ol>
<p>And if the language includes equality, then we addition</p>
<ol start="5" type="1">
<li><span class="math inline">\(x=x\)</span>;</li>
<li><span class="math inline">\(x=y\rightarrow(\alpha\rightarrow\alpha&#39;)\)</span>,
where <span class="math inline">\(\alpha\)</span> is <a href="/1eec0e97#AtomicFormula">atomic</a> and <span class="math inline">\(\alpha&#39;\)</span> is obtained from <span class="math inline">\(\alpha\)</span> by replacing <span class="math inline">\(x\)</span> in zero or more (but not necessarily
all) places by <span class="math inline">\(y\)</span>.</li>
</ol>
<p>How our particular list of logical axioms was formed.</p>
<ol type="a">
<li>The tautologies were included to handle <a href="/1eec0e97/#FirstOrderConnectiveSymbols">the sentential connective
symbols</a>.</li>
<li>Group 2 reflects the intended meaning of <a href="/1eec0e97/#Quantifier">the quantifier symbol</a>.</li>
<li>Group 3, group 4 and generalizations of axioms are added to prove
the <a href="#GeneralizationTheorem">generalization theorem</a>
below.</li>
<li>Group 5 and group 6 will turn out to be just enough to prove the
crucial <a href="#Equality">properties of equality</a>.</li>
</ol>
<p>Two objections(反对理由) to simply use the set of all <a href="/a55d499/#ValidWff">valid formulas</a> as logical axioms:</p>
<ol type="1">
<li>The validity was defined <em>semantically</em>, but we need a class
<span class="math inline">\(\Lambda\)</span> with a finitary,
<em>syntactical</em> definition. (前者"语义"是依赖于<a href="/a55d499/#Structure">structure</a>的,
后者"语法"仅跟符号的安排有关.)</li>
<li>We prefer a <a href="/78799e4f/#Decidable">decidable</a> set <span class="math inline">\(\Lambda\)</span>, and the set of validities fails
to be decidable.</li>
</ol>
<h4 id="substitution-替换">Substitution 替换</h4>
<p><span class="math inline">\(\DEF\)</span> Let <span class="math inline">\(x\)</span> be a variable, <span class="math inline">\(t\)</span> a <a href="/1eec0e97/#Term">term</a>.
We define the phrase "<span class="math inline">\(t\)</span> is
<em>substitutable</em> for <span class="math inline">\(x\)</span> in
<span class="math inline">\(\alpha\)</span>"(对于合式公式<span class="math inline">\(\alpha\)</span>中的变量<span class="math inline">\(x\)</span>, <span class="math inline">\(t\)</span>是可替换的)<span id="Substitutable"> as
follows:</span></p>
<ol type="1">
<li>For <a href="/1eec0e97#AtomicFormula">atomic</a> <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(t\)</span> is always substitutable for <span class="math inline">\(x\)</span> in <span class="math inline">\(\alpha\)</span>.</li>
<li><span class="math inline">\(t\)</span> is substitutable for <span class="math inline">\(x\)</span> in <span class="math inline">\(\lnot(\alpha)\)</span> iff it is substitutable for
<span class="math inline">\(x\)</span> in <span class="math inline">\(\alpha\)</span>. <span class="math inline">\(t\)</span> is substitutable for x in <span class="math inline">\((\alpha\rightarrow\beta)\)</span> iff it is
substitutable for <span class="math inline">\(x\)</span> in both <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>.</li>
<li><span class="math inline">\(t\)</span> is substitutable for <span class="math inline">\(x\)</span> in <span class="math inline">\(\forall
y\alpha\)</span> iff either
<ol type="a">
<li><span class="math inline">\(x\)</span> does not <a href="/1eec0e97/#OccurFree">occur free</a> in <span class="math inline">\(\forall y\alpha\)</span>, or</li>
<li><span class="math inline">\(y\)</span> does not occur in <span class="math inline">\(t\)</span> and <span class="math inline">\(t\)</span> is substitutable for <span class="math inline">\(x\)</span> in <span class="math inline">\(\alpha\)</span>.</li>
</ol></li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
这个递归定义的关键就是上边第三点, 确保t中没有变量能够被<span class="math inline">\(\forall y\)</span>前缀捕获(capture), 就是可替换的.
</font></p>
</div>
<p><span class="math inline">\(\EXAMPLE\)</span></p>
<ol type="1">
<li><span class="math inline">\(\varphi^x_x=\varphi\)</span>.</li>
<li><span class="math inline">\((Qx\rightarrow\forall{x}Px)^x_y=(Qy\rightarrow\forall{x}Px)\)</span>.</li>
<li>If <span class="math inline">\(\alpha\)</span> is <span class="math inline">\(\lnot\forall{y}x=y\)</span>, then <span class="math inline">\(\forall{x}\alpha\rightarrow\alpha^x_z\)</span> is
<span class="math inline">\(\forall{x}\lnot\forall{y}x=y\rightarrow\lnot\forall{y}z=y\)</span>.</li>
<li>For <span class="math inline">\(\alpha\)</span> as in 3, <span class="math inline">\(\forall{x}\alpha\rightarrow\alpha^x_y\)</span> is
<span class="math inline">\(\forall{x}\lnot\forall{y}x=y\rightarrow\lnot\forall{y}y=y\)</span>.</li>
</ol>
<p>第4个是反例, y对于公式中的x是不可替换的.</p>
<h4 id="tautologies-重言式">Tautologies 重言式</h4>
<p>可以用两种方法定义逻辑公理第一组的重言式.</p>
<p><span class="math inline">\(\DEF\)</span> Axiom group 1 consists of
generalization of formulas to be called <em>tautologies</em>. These are
the wffs obtainable from <a href="/5a484d90/#ListOfTautologies">tautologies of sentential
logic</a>(having only the connectives <span class="math inline">\(\lnot\)</span> and <span class="math inline">\(\rightarrow\)</span>) by replacing each sentence
symbol by a wff of the first-order language.</p>
<p><span class="math inline">\(\DEF\)</span></p>
<ol type="1">
<li>The <em>prime</em> formulas are the <a href="/1eec0e97#AtomicFormula">atomic formulas</a> and those of the form
<span class="math inline">\(\forall x\alpha\)</span>.</li>
<li>The nonprime formulas are the others, i.e., those of the form <span class="math inline">\(\lnot\alpha\)</span> or <span class="math inline">\(\alpha\rightarrow\beta\)</span>.</li>
</ol>
<p>Any <a href="/5a484d90/#ListOfTautologies">tautology of sentential
logic</a> (that uses only the connectives <span class="math inline">\(\lnot\)</span>, <span class="math inline">\(\rightarrow\)</span>) where the sentence symbols
is taken to be the prime formulas of the first-order language is in
axiom group 1.</p>
<p>Three remarks:</p>
<ol type="1">
<li>这种替换将命题逻辑里的命题符号扩展到不可数.</li>
<li>不用包括所有的重言式, 因为没有好办法证明一个公式是重言式.</li>
<li>由于明确了一阶逻辑公式同时也是命题逻辑公式,
命题逻辑的概念也可以被使用. 注意如果<span class="math inline">\(\Gamma\)</span> <a href="/5a484d90/#TautologicallyImply">tautologically
implies(重言蕴含)</a> <span class="math inline">\(\varphi\)</span>,
那么<span class="math inline">\(\Gamma\)</span> <a href="/4ea3d2b5/#LogicallyImply">logically implies(逻辑蕴含)</a> <span class="math inline">\(\varphi\)</span>, 但反过来不成立.</li>
</ol>
<h3 id="theorem-24b">Theorem 24B <span id="Theorem24B"></span></h3>
<p><span class="math inline">\(\Gamma\href{
#Deduction}{\vdash}\varphi\)</span> iff <span class="math inline">\(\Gamma\cup\Lambda\)</span> <a href="/5a484d90/#TautologicallyImply">tautologically implies</a> <span class="math inline">\(\varphi\)</span></p>
<h2 id="deductions-and-metatheorems">Deductions and Metatheorems</h2>
<p>定理"theorem"这个词本节有两个含义, 一个实在一阶逻辑里若<span class="math inline">\(\Gamma\vdash\alpha\)</span>, 我们说<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(\Gamma\)</span>的定理.
但我们也把一些自然语言表达的陈述叫做定理. 一般这不会造成混淆.
但为了避免误解,
也可以把本节如下一些自然语言描述的定理称作元定理(metatheorem)<span id="metatheorem">,
来强调它们是关于演绎和定理的结果.</span></p>
<h3 id="generalization-theorem-概化定理">Generalization Theorem 概化定理
<span id="GeneralizationTheorem"></span></h3>
<p>If <span class="math inline">\(\Gamma\href{
#Deduction}{\vdash}\varphi\)</span> and <span class="math inline">\(x\)</span> do not <a href="/1eec0e97/#OccurFree">occur free</a> in any formula in <span class="math inline">\(\Gamma\)</span>, then <span class="math inline">\(\Gamma\vdash\forall{x}\varphi\)</span></p>
<p>反映了一个非形式的感觉: 如果在没有对<span class="math inline">\(x\)</span>做特定假设的前提下能够证明一个包含_<span class="math inline">\(x\)</span>_的公式, 那么就可以说"因为<span class="math inline">\(x\)</span>是任意的, 我们有<span class="math inline">\(\forall x\_x\_\)</span>. 一旦给定了从<span class="math inline">\(\Gamma\)</span>到<span class="math inline">\(\varphi\)</span>的演绎, 就可以将其转化为从<span class="math inline">\(\Gamma\)</span>到<span class="math inline">\(\forall x\varphi\)</span>的演绎.</p>
<h3 id="lemma-24c-rule-t-规则t">Lemma 24C (Rule T) 规则T
<span id="RuleT"></span></h3>
<p>If <span class="math inline">\(\Gamma\href{
#Deduction}{\vdash}\alpha_1,\ldots,\Gamma\vdash\alpha_n\)</span> and
<span class="math inline">\(\{\alpha_1,\ldots,\alpha_n\}\)</span> <a href="/5a484d90/#TautologicallyImply">tautologically implies</a> <span class="math inline">\(\beta\)</span>, then <span class="math inline">\(\Gamma\vdash\beta\)</span>.</p>
<h3 id="deduction-theorem-演绎定理">Deduction Theorem 演绎定理
<span id="DeductionTheorem"></span></h3>
<p>If <span class="math inline">\(\Gamma;\gamma\href{
#Deduction}{\vdash}\varphi\)</span>, then <span class="math inline">\(\Gamma\vdash(\gamma\rightarrow\varphi)\)</span></p>
<p>反向也成立, 实际上反向就是假言推论.</p>
<h3 id="corollary-24d-contraposition-逆否">Corollary 24D
(Contraposition) 逆否 <span id="Contraposition"></span></h3>
<p><span class="math inline">\(\Gamma;\varphi\href{
#Deduction}{\vdash}\lnot\psi\)</span> iff <span class="math inline">\(\Gamma;\psi\vdash\lnot\varphi\)</span></p>
<h3 id="corollary-24e-reductio-ad-absurdum-归谬法-反证法">Corollary 24E
(Reductio ad Absurdum) 归谬法, 反证法
<span id="ReductioAdAbsurdum"></span></h3>
<p><span class="math inline">\(\DEF\)</span> Say that a set of formulas
is <em>inconsistent</em><span id="Inconsistent"> iff for some <span class="math inline">\(\beta\)</span>, both <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\lnot\beta\)</span> are theorems of the set.</span></p>
<p>Corollary 24E(Reductio ad Absurdum): If <span class="math inline">\(\Gamma;\varphi\)</span> is inconsistent, then
<span class="math inline">\(\Gamma\href{
#Deduction}{\vdash}\lnot\varphi\)</span>.</p>
<p><span class="math inline">\(\EXAMPLE\)</span> 证明: <span class="math inline">\(\vdash\exists{x}\forall{y}\varphi\rightarrow\forall{y}\exists{x}\varphi\)</span>
Working backward:</p>
<ul>
<li>It suffices to show that <span class="math inline">\(\exists{x}\forall{y}\varphi\vdash\forall{y}\exists{x}\varphi\)</span>,
by the <a href="#DeductionTheorem">deduction theorem</a>.</li>
<li>It suffices to show that <span class="math inline">\(\exists{x}\forall{y}\varphi\vdash\exists{x}\varphi\)</span>,
by the <a href="#GeneralizationTheorem">generalization theorem</a>.</li>
<li>It suffices to show that <span class="math inline">\(\lnot\forall{x}\lnot\forall{y}\varphi\vdash\lnot\forall{x}\lnot\varphi\)</span>,
as this is the same as the preceding.</li>
<li>It suffices to show that <span class="math inline">\(\forall{x}\lnot\varphi\vdash\forall{x}\lnot\forall{y}\varphi\)</span>,
by the <a href="#Contraposition">contraposition</a> (and <a href="RuleT">rule T</a>)</li>
<li>It suffices to show that <span class="math inline">\(\forall{x}\lnot\varphi\vdash\lnot\forall{y}\varphi\)</span>,
by the <a href="#GeneralizationTheorem">generalization theorem</a>.</li>
<li>It suffices to show that <span class="math inline">\(\{\forall{x}\lnot\varphi,
\forall{y}\varphi\}\)</span> is <a href="#Inconsistent">inconsistent</a>, by the <a href="#ReductioAdAbsurdum">reductio ad absurdum</a>.</li>
<li>It suffices to show that <span class="math inline">\(\forall{x}\lnot\varphi\vdash\lnot\varphi\)</span>
and <span class="math inline">\(\forall{y}\varphi\vdash\varphi\)</span>
by <a href="#AnxiomGroups">anxiom group 2</a> and <a href="#ModusPonens">modus ponens</a></li>
</ul>
<h2 id="strategy-策略">Strategy 策略</h2>
<p>Assume that <span class="math inline">\(\varphi\)</span> is indeed <a href="#Deduction">deducible</a> from <span class="math inline">\(\Gamma\)</span> but that you are seeking a proof
of this fact. There are several cases:</p>
<ol type="1">
<li>Suppose that <span class="math inline">\(\varphi\)</span> is <span class="math inline">\((\psi\rightarrow\theta)\)</span>. Then it will
suffice to show that <span class="math inline">\(\Gamma;\psi\vdash\theta\)</span>.</li>
<li>Suppose that <span class="math inline">\(\varphi\)</span> is <span class="math inline">\(\forall{x}\psi\)</span>. If <span class="math inline">\(x\)</span> does not <a href="/1eec0e97/#OccurFree">occur free</a> in <span class="math inline">\(\Gamma\)</span>, then it will suffice to show that
<span class="math inline">\(\Gamma\vdash\psi\)</span>. (Even if <span class="math inline">\(x\)</span> should occur free in <span class="math inline">\(\Gamma\)</span>, the difficulty can be
circumvented. These will always be a variable <span class="math inline">\(y\)</span> such that <span class="math inline">\(\Gamma\vdash\forall y\psi^x_y\)</span> and <span class="math inline">\(\forall{y}\psi^x_y\vdash\forall{x}\psi\)</span>
re-replacement lemma)</li>
<li>Finally, suppose that <span class="math inline">\(\varphi\)</span>
is the negation of another formula.
<ol type="a">
<li>If <span class="math inline">\(\varphi\)</span> is <span class="math inline">\(\lnot(\psi\rightarrow\theta)\)</span>, then it
will suffice to show that <span class="math inline">\(\Gamma\vdash\psi\)</span> and <span class="math inline">\(\Gamma\vdash\lnot\theta\)</span> (by <a href="#RuleT">rule T</a>.</li>
<li>If <span class="math inline">\(\varphi\)</span> is <span class="math inline">\(\lnot\lnot\psi\)</span>, then of course it will
suffice to show that <span class="math inline">\(\Gamma\vdash\psi\)</span>.</li>
<li>The remaining case is where <span class="math inline">\(\varphi\)</span> is <span class="math inline">\(\lnot\forall x\psi\)</span>. It would suffice to
show that <span class="math inline">\(\Gamma\vdash\lnot\psi^x_t\)</span>, where t is
some <a href="/1eec0e97/#Term">term</a> <a href="#Substitutable">substitutable</a> for <span class="math inline">\(x\)</span> in <span class="math inline">\(\psi\)</span>. (Unfortunately this is not always
possible.) Or contraposition is handy here: <span class="math inline">\(\Gamma;\alpha\vdash\lnot\forall x\psi\)</span> iff
<span class="math inline">\(\Gamma;\forall
x\psi\vdash\lnot\alpha\)</span>. (A variation on this is: <span class="math inline">\(\Gamma;\forall y\alpha\vdash\lnot\forall
x\psi\)</span> if <span class="math inline">\(\Gamma;\forall
x\psi\vdash\lnot\alpha\)</span>.) If all else fails, one can try
reductio ad absurdum.</li>
</ol></li>
</ol>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体">
这里就是根据定理的语法形式给出了常用的证明策略. </font></p>
</div>
<p><span class="math inline">\(\EXAMPLE\)</span></p>
<ul>
<li>Q2A. If <span class="math inline">\(x\)</span> does not <a href="/1eec0e97/#OccurFree">occur free</a> in <span class="math inline">\(\alpha\)</span>, then <span class="math inline">\(\vdash(\alpha\rightarrow\forall
x\beta)\leftrightarrow\forall x(\alpha\rightarrow\beta)\)</span>.</li>
<li>Q3B. If <span class="math inline">\(x\)</span> does not <a href="/1eec0e97/#OccurFree">occur free</a> in <span class="math inline">\(\alpha\)</span>, then <span class="math inline">\(\vdash(\exists
x\beta\rightarrow\alpha)\leftrightarrow\forall
x(\beta\rightarrow\alpha)\)</span>.</li>
<li><span class="math inline">\(\vdash x=y\rightarrow\forall
zPxz\rightarrow\forall zPyz\)</span></li>
</ul>
<h3 id="theorem-24f-generalization-on-constants-常量概化定理">Theorem
24F (Generalization on Constants 常量概化定理)</h3>
<p>Assume that <span class="math inline">\(\Gamma\vdash\varphi\)</span>
and that <span class="math inline">\(c\)</span> is a <a href="/1eec0e97/#FirstOrderConstantSymbol">constant symbol</a> that does
not occur in <span class="math inline">\(\Gamma\)</span>. Then there is
a variable <span class="math inline">\(y\)</span> (which does not occur
in <span class="math inline">\(\varphi\)</span>) such that <span class="math inline">\(\Gamma\vdash\forall y\varphi^c_y\)</span>.
Furthermore, there is a deduction of <span class="math inline">\(\forall
y\varphi^c_y\)</span> from <span class="math inline">\(\Gamma\)</span>
in which <span class="math inline">\(c\)</span> does not occur.</p>
<div class="note success"><p><span class="math inline">\(\MYNOTE\)</span> <font face="楷体"> <span class="math inline">\(c\)</span>在<span class="math inline">\(\Gamma\)</span>里不存在, 在<span class="math inline">\(\varphi\)</span>里存在. <span class="math inline">\(y\)</span>在<span class="math inline">\(\varphi\)</span>里不存在.
整个演绎过程里可以没有<span class="math inline">\(c\)</span>.
</font></p>
</div>
<h3 id="gorollary-24g">Gorollary 24G</h3>
<p>Assume that <span class="math inline">\(\Gamma\vdash\varphi^x_c\)</span>, where the <a href="/1eec0e97/#FirstOrderConstantSymbol">constant symbol</a> <span class="math inline">\(c\)</span> does not occur in <span class="math inline">\(\Gamma\)</span> or in <span class="math inline">\(\varphi\)</span>. Then <span class="math inline">\(\Gamma\vdash\forall x\varphi\)</span>, and there
is a deduction of <span class="math inline">\(\forall x\varphi\)</span>
from <span class="math inline">\(\Gamma\)</span> in which <span class="math inline">\(c\)</span> does not occur.</p>
<h3 id="corollary-24h-rule-ei">Corollary 24H (Rule EI)</h3>
<p>Assume that the <a href="/1eec0e97/#FirstOrderConstantSymbol">constant symbol</a> <span class="math inline">\(c\)</span> does not occur in <span class="math inline">\(\varphi\)</span>, <span class="math inline">\(\psi\)</span>, or <span class="math inline">\(\Gamma\)</span>, and that <span class="math display">\[\Gamma;\varphi^x_c\vdash\psi\]</span> Then <span class="math display">\[\Gamma;\exists x\varphi\vdash\psi\]</span> and
there is a deduction of <span class="math inline">\(\psi\)</span> from
<span class="math inline">\(\Gamma;\exists x\varphi\)</span> in which
<span class="math inline">\(c\)</span> does not occur.</p>
<p>"EI" stands for "existential instantiation"(存在实例).</p>
<h2 id="alphabetic-variants-字母变换式">Alphabetic Variants 字母变换式
<span id="AlphabeticVariants"></span></h2>
<h3 id="theorem-24i-existence-of-alphabetic-variants-字母变换式存在定理">Theorem
24I (Existence of Alphabetic Variants 字母变换式存在定理)</h3>
<p>Let <span class="math inline">\(\varphi\)</span> be a formula, <span class="math inline">\(t\)</span> a <a href="/1eec0e97/#Term">term</a>
and <span class="math inline">\(x\)</span> a variable. Then we can find
a formula <span class="math inline">\(\varphi&#39;\)</span> (which
differs from <span class="math inline">\(\varphi\)</span> only in the
choice of quantified variables) such that</p>
<ol type="a">
<li><span class="math inline">\(\varphi\vdash\varphi&#39;\)</span> and
<span class="math inline">\(\varphi&#39;\vdash\varphi\)</span>;</li>
<li><span class="math inline">\(t\)</span> is <a href="#Substitutable">substitutable</a> for <span class="math inline">\(x\)</span> in <span class="math inline">\(\varphi&#39;\)</span>.</li>
</ol>
<p>这个定理中构造的<span class="math inline">\(\varphi&#39;\)</span>,
称为Alphabetic variants(字母变换式). 该定理的含义是: 在无法进行替换时,
选择正确的字母变换式可以解决问题.</p>
<h2 id="equality-相等">Equality 相等 <span id="Equality"></span></h2>
<ul>
<li>EQ1: <span class="math inline">\(\vdash\forall xx=x\)</span></li>
<li>EQ2. <span class="math inline">\(\forall x\forall y(x=y\rightarrow
y=x)\)</span></li>
<li>EQ3: <span class="math inline">\(\vdash\forall x\forall y\forall
z(x=y\rightarrow y=z\rightarrow x=z)\)</span></li>
<li>EQ4: for a two-place predicate symbol <span class="math inline">\(P\)</span>: <span class="math display">\[\vdash\forall x_1\forall x_2\forall y_1\forall
y_2(x_1=y_1\rightarrow x_2=y_2\rightarrow Px_1 x_2\rightarrow Py_1
y_2)\]</span></li>
<li>EQ5. Let f be a two-place function symbol. Then <span class="math display">\[\vdash\forall x_1\forall x_2\forall y_1\forall
y_2(x_1=y_1\rightarrow x_2=y_2\rightarrow fx_1 x_2=fy_1
y_2)\]</span></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>Logic</tag>
        <tag>Mathematical Logic</tag>
        <tag>Enderton</tag>
      </tags>
  </entry>
  <entry>
    <title>航空仪表(一) -- 基础仪表</title>
    <url>//271b6ce/</url>
    <content><![CDATA[<h2 id="起因">起因</h2>
<p>最近几乎所有的业余时间都用来飞微软的模拟飞行10(FSX),
学习作为一个飞行员如何理解航空设备. 这边做一些记录和翻译的工作,
把我学到过的航空仪表的功能记录下来. 驾驶的感觉需要训练,
但这些硬知识还是得靠死记硬背.</p>
<p>大部分内容是从<a href="https://learntofly.ca/six-pack-primary-flight-instruments/">这篇</a>翻译过来的,
加上一些维基百科上的资料, 以及一些自己的理解. <span id="more"></span></p>
<p>当前商务机或者大型机上的飞行员操作面板都是如下图这样的显示屏,
或者叫玻璃面板(Glass Panels).</p>
<img src="/271b6ce//glass_panels.jpg" class title="玻璃面板">
<p>但在那以前的飞机和在现在的小型飞机上,
基本都是像下面这个图一样的仪表面板.</p>
<img src="/271b6ce//instrument_panels.jpg" class title="仪表面板">
<p>密密麻麻的仪表中, 最基础的有6块表. 英文叫six
pack(6块腹肌也叫这个词)他们分别是:</p>
<p>The SIX PACK:</p>
<ol type="1">
<li>空速表 (Airspeed Indicator or ASI)</li>
<li>姿态仪 (Attitude Indicator or AI)</li>
<li>高度表 (Altimeter)</li>
<li>垂直速度表 (Vertical Speed Indicator or VSI)</li>
<li>航向表 (Heading Indicator or HI)</li>
<li>转弯协调仪 (Turn Coordinator or TC)</li>
</ol>
<p>下图是我们在FSX中学习飞行开的Cessna 172的6块基础仪表,
号码与上面的列表对应.</p>
<img src="/271b6ce//Cessna-172-sixpack.jpg" class title="塞斯纳172的六块表">
<p>下面单独讲讲每块表的工作原理和使用方法.</p>
<h2 id="工作原理">工作原理</h2>
<p>从数据采集方式上, 这六块表可以飞为两类. 其中3块表(高度表, 空速表,
垂直速度表)连接在动静压系统(Pitor Static Pressure System).
另外三块(姿态仪, 航向表, 转弯协调仪表)属于使用陀螺仪的一类仪表.</p>
<h3 id="动静压系统">动静压系统</h3>
<p>动静压系统(Pitot Static System)依赖于两个数据源. 一个是皮托管(Pitot
Tube), 用来测量飞机向穿过空气产生的动态压力. 一个是静压空(Static Vents),
用来测量由于飞机海拔高度变化而产生的不同的静态大气压.
下图是工作原理示意图.</p>
<img src="/271b6ce//pitot_static_system.jpg" class title="动静压系统">
<h3 id="陀螺仪类仪表">陀螺仪类仪表</h3>
<p>一个陀螺仪(Gyroscope)是(以下从维基百科抄的)一种用来感测与维持方向的装置.
基于角动量守恒的理论设计出来的.
陀螺仪主要是由一个位于轴心且可旋转的转子构成. 陀螺仪一旦开始旋转,
由于转子的角动量, 陀螺仪有抗拒方向改变的趋向.
陀螺仪通常是由真空泵或者电力驱动. 在角动量守恒的原则下,
陀螺仪具有两个基本特性: 一为定轴性(inertia 或 rigidity),
另一是逆动性(precession). 定轴性是指当陀螺转子以极高速度旋转时,
其转动得以维持并保持其轴指向一个相对固定的方向的这种物理现象,
也叫转动惯性. 逆动性是指在运转中的陀螺仪,
如果外界施一作用或力矩在转子旋转轴上, 则旋转轴并不沿施力方向运动,
而是顺着转子旋转向前90度垂直施力方向运动的物理现象.
下图是陀螺仪的原理示意图.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Gyroscope_operation.gif/220px-Gyroscope_operation.gif" alt="定轴陀螺仪"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Gyroscope_precession.gif/220px-Gyroscope_precession.gif" alt="偏轴陀螺仪"></p>
<h2 id="six-pack">Six Pack</h2>
<h3 id="空速表">#1 空速表</h3>
<p>一般空速表如图 <img src="/271b6ce//Cessna-172-Airspeed-Indicator.jpg" class title="空速表"></p>
<p>空速表测量的是飞机穿过空气时相对空气的速度.
这里有几个知识点需要提前搞清楚.</p>
<p>第一个是速度单位, 由于历史原因, 飞机上提到的速度单位是海里(Nautical
Miles)每小时也叫节(Knots). 1节约等于1.85公里每小时,
约等于1.15英里每小时.</p>
<p>第二个是我们提到空速其实是有4种不同的空速, 包括指示空速(Indicated
airspeed, IAS), 校准空速(Calibrated airspeed, CAS), 当量空速(Equivalent
airspeed, EAS), 真空速(True airspeed, TAS).
飞行员在飞行中主要使用指示空速(IAS), 航空器飞行手册和使用手册中.
性能图表上所使用的速度也是IAS. 所以以后提到的空速都是指IAS.
注意空速表不会告知对地速度, 但风速的航向分量跟空速相加等于对地速度.</p>
<p>看懂空速表需要了解如下飞机速度参数.</p>
<ul>
<li><span class="math inline">\(V_A\)</span>=maneuvering,
也就是只有这个速度以下才能使用较激烈的操作, 比如急转, 紧急下降等.</li>
<li><span class="math inline">\(V_{FE}\)</span>=flap extend,
在此速度以下能够安全的放襟翼.</li>
<li><span class="math inline">\(V_{LE}\)</span>=landing gear extended,
在此速度以下可以放起落架.</li>
<li><span class="math inline">\(V_{LO}\)</span>=landing gear operating,
在此速度下起落架能正常的运作.</li>
<li><span class="math inline">\(V_{NO}\)</span>=max structural cruising
speed, 最大结构巡航速度. 意思是说除非在平稳气流中, 不能超过这个速度.
如果超过必须保持警惕.</li>
<li><span class="math inline">\(V_{NE}\)</span>=never exceed speed,
任何时间都不能超过的速度.</li>
<li><span class="math inline">\(V_S\)</span>=stall clean configuration,
没有放襟翼的失速速度.</li>
<li><span class="math inline">\(V_{SO}\)</span>=stall landing
configuration, 放了襟翼的失速速度.</li>
<li><span class="math inline">\(V_X\)</span>=best angle,
最佳爬升角度的速度(在一定的距离内能够爬升最多高度)</li>
<li><span class="math inline">\(V_Y\)</span>=best rate,
最佳爬升速率的速度(在一定的时间内内能够爬升最多高度)</li>
</ul>
<p>再来看空速表有白绿黄三个弧, 和一条红线.</p>
<ul>
<li>绿弧是常规操作时使用的, 最小点是<span class="math inline">\(V_S\)</span>, 最大点是<span class="math inline">\(V_{NO}\)</span></li>
<li>白弧是打开襟翼之后时使用的, 最小点是<span class="math inline">\(V_{SO}\)</span>, 最大点是<span class="math inline">\(V_{FE}\)</span></li>
<li>黄弧是在平稳气流中才能使用的速度, 最小点是<span class="math inline">\(V_{NO}\)</span>, 最大点是<span class="math inline">\(V_{NE}\)</span></li>
<li>红线是<span class="math inline">\(V_{NE}\)</span>,
超过飞机可能损坏.</li>
</ul>
<h3 id="姿态仪">#2 姿态仪</h3>
<p>姿态仪也叫陀螺水平仪. 这个仪器显示的是飞机相对于水平面的位置.</p>
<img src="/271b6ce//Cessna-172-Attitude-Indicator.jpg" class title="姿态仪">
<p>我们知道飞行员的操作很大一部分是控制飞机的三个方向的行为,
通过升降舵(elevator)控制俯仰(pitch), 通过副翼(aileron)滚转(roll),
通过方向舵(rudder)控制飞机偏航(yaw).
姿态仪可以描绘俯仰和滚转这两个维度上飞机的状态.
这个表是基本是飞控的核心仪表, 飞行员大部分时间都会盯着这个表进行控制.
观察表面可以知道, 蓝色代表天空, 棕色代表地面, 中间的界限就是代表水平面.
表面上还有些刻度. 关于俯仰的刻度, 水平面上下短线代表5度, 长线代表10度.
关于滚转时的侧倾(bank)的刻度,
最上面代表天空的地方可以看到一些长短线刻度, 短线代表10,20度,
长线代表30,60度. 水平线以下的四条斜线代表15,45度.</p>
<h3 id="高度表">#3 高度表</h3>
<p>高度表测量的是海拔高度.</p>
<img src="/271b6ce//Cessna-172-Altimeter.jpg" class title="姿态仪">
<p>注意, 地面的海拔高度差别很大, 所以高度表读数并不能测量对地高度,
而是相对于海平面的高度. 飞行员必须知道当地的地面海拔,
然后计算出飞机对地的相对高度.</p>
<p>类似于一个钟表, cessna 172的高度表有三个指针.
转得最快的指针的读数是百英尺(100 feet). 最短的指针的读数是千英尺.
最长的指针也是移动最慢的指针的读数是万英尺.
(不同的高度表的指针的长短代表的含义不同) 配图里的读数是海拔1410英尺.</p>
<p>高度表的读数是通过测量大气压获得的. 但大气压是一直在变化的,
这就需要在每次飞行之前, 对高度表拔定值(altimeter setting)进行设置.
或者在飞行中你飞行的区域大气压发生变化了, 也需要调整高度表的拔定值.
高度表拔定值就是飞机所在地的海平面气压, 就是图中刻度2和3中间的数字.</p>
<h3 id="垂直速度表">#4 垂直速度表</h3>
<p>垂直速度表(VSI)测量的是爬升或者下降的速率.
读数的单位是每分钟百英尺(100 FPM).</p>
<img src="/271b6ce//Cessna-172-Vertical-Speed-Indicator.jpg" class title="垂直速度表">
<p>垂直速度表也链接到静态压系统. 当海拔变化时,
大气压也会按照一定规律变化.
对这种变化的标准比率进行校准就可以用来测量飞机的海拔高度的变化率.</p>
<p>飞行员以来高度表和垂直速度表来监控飞机的高度和高度变化.
飞行员只需要用余光扫一眼这个表, 就可以知道飞机是否在一个稳定的高度飞行,
或者是否在爬升或者下降, 并知道每分钟的变化是多少英尺.</p>
<h3 id="航向表">#5 航向表</h3>
<p>航向表(HI)是另外一个陀螺仪飞行仪表.
有时候也叫做方向陀螺仪(Directional Gyro)或者航向陀螺仪(Heading Gyro).
顾名思义, 这个仪表告知飞行员飞行的方向.</p>
<img src="/271b6ce//Cessna-172-Heading-Indicator.jpg" class title="航向表">
<p>航向表是陀螺稳定的, 而不是磁性罗盘. 磁性罗盘的读数会被滚转倾角, 转弯,
和速度变化影响. 陀螺稳定的航向表则不会. 每次起飞前,
航向表必须根据磁性罗盘的读数进行校准. 并且由于陀螺仪会积累误差,
所以当平飞, 并且飞行稳定的时候, 航向表要根据磁性罗盘经常性的进行校准.
以约15分钟的固定间隔校准到磁性罗盘, 以消除进动误差(Precession
error).</p>
<p>看这个表的面板上会有一个飞机的轮廓, 周围一圈是360度的刻度.
上面有东南西北的英文首字母的标记, 长线代表10度, 短线代表5度.</p>
<h3 id="转弯协调仪">#6 转弯协调仪</h3>
<p>这又是一个陀螺仪仪表. 这个仪表给出两种信息,
上半部分的信息是关于转弯的方向和转弯的速率的,
下半部分显示了转弯是否在协调飞行中飞行.</p>
<img src="/271b6ce//Cessna-172-Turn-Coordinator.jpg" class title="转弯协调仪">
<p>先说下半部分的协调转弯. 试想开车的时候转弯, 如果道路是水平的,
人会有向外甩的感觉. 而且由于向心力都是靠轮胎的摩擦力提供的,
如果离心力大于车轮的摩擦力, 车子就会向外打滑. 但如果道路是倾斜的,
地面的压力提供里一个向心的分量来做向心力,
如果车速跟地面倾斜角度配合得好, 人是可以完全没有向外甩的感觉的.
这就叫协调转弯. 飞行中由于没有摩擦力,
转弯的向心力都是由于飞行员操作副翼, 使飞机产生倾角(bank),
让升力提供一个向心力完成的,
但如果这个向心力跟飞机转弯的角度和速率不匹配, 飞机就不是协调飞行.
此时转弯协调仪底部的小球(也叫测斜仪 inclinometer)将不会居中,
代表了飞机在转弯时向一侧打滑.
飞行员必须使用方向舵调整机头方向以纠正这个侧滑. 直到小球保持居中,
就是协调转弯了.</p>
<p>然后说一下上半部分, 两对白线分别代表水平位置和标准速度转弯(Standard
Rate Turn)的倾角. 在这个倾角下, 飞机将以3度每秒的标准速率进行转弯.
因此360度转弯需要花2分钟. 这就允许飞行员通过时间来决定转弯的角度. 例如,
飞行员调整好飞机姿态以标准速率转弯飞行60秒后, 就能够确认飞机转弯了180度.
这个在飞行员开始仪表飞行的时候将变得尤其重要.</p>
]]></content>
      <categories>
        <category>航电</category>
        <category>模拟飞行</category>
      </categories>
      <tags>
        <tag>Avionics</tag>
        <tag>Aviation</tag>
        <tag>instrument</tag>
      </tags>
  </entry>
  <entry>
    <title>减肥课听后感</title>
    <url>//e34593ca/</url>
    <content><![CDATA[<p>听了得到上冯雪的科学减肥课. 把干货总结一下.</p>
<span id="more"></span>
<ol type="1">
<li><p>减肥的实质是改变生活方式.</p></li>
<li><p>三个目标:</p>
<ul>
<li>体重: BMI, 男18.5-24, 女18.5-23.</li>
<li>体脂: 体脂率, 男15%-18%, 女20%-25%.</li>
<li>体型: 男腰围&lt;85cm, 腰臀比小于0.9; 女腰围小于80,
腰臀比小于0.8.</li>
</ul></li>
<li><p>第一性原理: 能量守恒</p>
<ul>
<li>减肥就是打造能像缺口</li>
<li>五个出口: 基础代谢, 消化吸收消耗能量, 维持体温, 维持清醒,
运动(唯一有效可控).</li>
<li>三个入口: 宏量营养素
<ol type="a">
<li>碳水化合物: 4千卡<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>每克. 主要能量来源, 大脑唯一能量来源.
吸收转化率70%, 过量易转化为脂肪. 特殊碳水化合物: 纤维素, 无法吸收,
减肥利器.</li>
<li>脂肪: 9千卡每克, 吸收转化率96%, 难以消耗. 快进慢出.</li>
<li>蛋白质: 4千卡每克, 基本不作为能量消耗, 减肥必需,
每公斤每天补充1-1.5克.</li>
</ol></li>
</ul></li>
<li><p>唯一减肥正路: 生活方式干预. 饮食, 运动, 心里, 三角形.</p></li>
<li><p>饮食: 打造能量缺口, 摄入小于消耗.</p>
<ul>
<li>多大的缺口合适: 500-750千卡, BMI越小越缺口可以越接近500,
越大越接近750.</li>
<li>饿不代表缺少能量. 选择能量密度低的食物, 也可以吃饱.</li>
<li>如何打造缺口:
<ol type="a">
<li>有标签的食物看标签里的营养成分表, 注意标注的都是每100克能量.</li>
<li>没有标签的食物, 用手机app查询, 可以估算出大概的能量.</li>
<li>实物拍照, 制作营养日记.
开始减肥前选择工作日,周末,特殊日子记录三天.</li>
<li>指定每日餐单, 根据营养日记, 从里面减掉500-750千卡.</li>
</ol></li>
<li>如果能做到, 每周应该会稳定下降0.5-1kg体重.</li>
</ul></li>
<li><p>饮食选择:</p>
<ul>
<li>四个准则:
<ol type="a">
<li>食材越少加工越好.</li>
<li>食物越完整越好, 能不削皮就不削皮, 谷物尽量粗着吃. 既能有纤维素抗饿,
又能保留微量元素和维生素.</li>
<li>脂肪选择天然不饱和的
<ul>
<li>植物油(椰子油和棕榈油除外)</li>
<li>坚果</li>
<li>鱼肉, 首选深海鱼.</li>
<li>注意: 坚决不吃人造的<strong>反式脂肪酸</strong>, 几乎无法代谢,
且容易粘附血管.</li>
</ul></li>
<li>蛋白质越纯越好.
<ul>
<li>水里游的&gt;天上飞的&gt;地上跑的&gt;跑也跑不动的</li>
<li>肉类: 鱼肉, 虾肉, 鸽子肉, 兔肉, 鸡胸肉, 鸭胸肉, 驴肉, 牛瘦肉,
羊瘦肉, 猪后腿肉和大排肉</li>
<li>植物蛋白: 豆制品</li>
</ul></li>
</ol></li>
<li>三餐安排
<ol type="a">
<li>早饭一定要吃</li>
<li>晚饭最迟9点</li>
</ol></li>
<li>每餐安排: 2-1-1原则, 2份水果蔬菜(半斤蔬菜+4两水果),
1份肉类(2两瘦肉+1两豆腐), 1份谷物(3两). 大约一斤半, 750克.</li>
</ul></li>
<li><p>运动:</p>
<ul>
<li>效果: 运动对体重影响有限, 只通过运动减肥, 基本不可能.
必须搭配生活方式管理.</li>
<li>做什么运动:
<ol type="a">
<li>有氧: 快走, 慢跑, 游泳, 骑车, 爬山.</li>
<li>强度: <span class="math display">\[有氧运动最佳心率 = (220 - 年龄 -
净息心率)\times|40\%-60\%|+静息心率\]</span>我的最佳心率116-137.</li>
<li>时长超过30分钟.</li>
<li>HIIT燃烧脂肪效率高, 但强度很高, 难以坚持. 不推荐.</li>
<li>美国统计快走是减肥成功率最高的运动.</li>
<li>塑性: 做一定量的力量训练.</li>
</ol></li>
</ul></li>
<li><p>心里能量: 压力和睡眠是主战场</p></li>
<li><p>减肥药: 效果不佳. 决定吃就是长期服用, 也必须配合生活方式管理.</p>
<ul>
<li>Qsymia: 模仿人体交感神经, 提高人体代谢. 效果最佳,
也有很多副作用.</li>
<li>奥利司他: 通过和倡导的脂肪酶结合组织脂肪吸收. 副作用尴尬,
效果很小.</li>
<li>条件: BMI&gt;27+其他肥胖疾病, 或者BMI&gt;30</li>
</ul></li>
<li><p>手术减肥: 靠谱</p>
<ul>
<li>减肥手术不包括抽脂</li>
<li>方法有三种: 胃旁路, 部分胃切除, 在胃里放气囊, 减少胃容积. 效果很好,
90%糖尿病临床缓解.</li>
<li>条件: BMI&gt;35+糖尿病, 或者BMI&gt;40</li>
</ul></li>
<li><p>轻断食</p>
<ul>
<li>医学饮食治疗, 对频率, 断食时间, 断食当日的能量摄入有严格要求.</li>
<li>好处: <strong>帮助减肥, 治疗疾病, 延年益寿.</strong></li>
<li>机制: 断食8-12小时后, 身体里糖消耗完, 开始分解脂肪,
把分解出来的酮体作为能源物质; 这些酮体会启动神经内分泌传到信号;
细胞核收到信号后会启动一系列自我保护效应, 包括降低蛋白质合成,
提高胰岛素敏感性,增加坏细胞的自我清除等等.
节约能源+发挥潜力+自我修复.</li>
<li>如何做:
<ol type="a">
<li>轻断食的这天, 摄入热量在500-750的第范围内.
<ul>
<li>选择升糖指数低的食物, 让自己饿得慢一点.</li>
<li>保证每公斤1克蛋白质摄入.</li>
<li>保证维生素和纤维素的补充.</li>
</ul></li>
<li>什么时候吃: 6-8小时内吃饭, 后面不再吃了.</li>
<li>频次:
<ul>
<li>轮替方案, 每周不超过3天.</li>
<li>5+2方案, 一周当中任意两天.</li>
</ul></li>
</ol></li>
<li>轻断食计划
<ol type="a">
<li>第一月, 每周一天, 吃1000千卡食物, 10小时内吃完.</li>
<li>第二月, 每周两天, 吃1000千卡食物, 8小时内吃完.</li>
<li>第三月, 每周两天, 吃750千卡食物, 6小时内吃完.</li>
<li>第四月, 每周三天, 吃500千卡食物, 6小时内吃完. 后面两个月维持.</li>
</ol></li>
<li>副作用: 初期会经历饥饿感, 烦躁和注意力下降.
但这些反应会在一个月内消失.</li>
<li>禁忌: 生理期女性, 生病不要做轻断食.</li>
</ul></li>
<li><p>代餐</p>
<ul>
<li>效果: 减肥效果不错.</li>
<li>什么是好的代餐:
<ol type="a">
<li>包含一定能量: 150-350千卡</li>
<li>能量物质按比例搭配: 碳水&lt;40%, 蛋白质20%-30%, 脂肪&lt;30%.</li>
<li>微量元素要全面. 尤其是B族维生素.</li>
</ol></li>
</ul></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>1卡路里的能量或热量可将1克水在一个大气压下的温度升高1摄氏度。1卡路里约等于4.1859焦耳.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Weight Loss</tag>
      </tags>
  </entry>
  <entry>
    <title>TeX Math Syntax</title>
    <url>//6146c48/</url>
    <content><![CDATA[<h3 id="a-brief-introduction-to-latex-math-symbols">A brief introduction
to LaTeX math symbols</h3>
<span id="more"></span>
<p><a href="https://www.caam.rice.edu/~heinken/latex/symbols.pdf">原网站</a></p>
<h3 id="alphabetical-list-of-tex-commands-available-in-mathjax">Alphabetical
List of TeX Commands available in MathJax</h3>
<p><a href="http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm">原网站</a></p>
<h3 id="xy-pic-users-guide">XY-pic User’s Guide</h3>
<p><a href="https://www.math.uci.edu/~xiangwen/pdf/LaTeX-Math-Symbols.pdf">原网站</a></p>
<h3 id="mathml">MathML</h3>
<p><a href="http://www.pragma-ade.nl/general/manuals/mmlprime.pdf">原网站</a></p>
<h3 id="unicode-mathematics-in-latex-advantages-and-challenges">Unicode
mathematics in LATEX: Advantages and challenges</h3>
<p><a href="https://www.tug.org/TUGboat/tb31-2/tb98robertson.pdf">原网站</a></p>
<h3 id="short-math-guide">short math guide</h3>
<p><a href="https://www.math.hkbu.edu.hk/TeX/short-math-guide.pdf">原网站</a></p>
<h3 id="users-guide-for-the-amsmath-package">User’s Guide for the
amsmath Package</h3>
<p><a href="https://texdoc.org/serve/amsldoc.pdf/0">原网站</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>TeX</tag>
        <tag>LaTeX</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title>Python ast module</title>
    <url>//717710aa/</url>
    <content><![CDATA[<p>由于一个工作需要把大量的vbscript脚本转换成python脚本,
需要学习一下python的ast模块, 本文是一些干货的笔记. 由于当前最新的<a href="https://docs.python.org/3.8/library/ast.html">python
3.8的官方文档</a>过于简略, 主要参考和翻译<a href="https://greentreesnakes.readthedocs.io/en/latest/index.html#">绿树蛇</a>的文档和<a href="https://docs.python.org/3.10/library/ast.html">python3.10pre的文档</a>.</p>
<p>AST是Abstract Syntax Trees的缩写, 中文是抽象语法树.</p>
<h2 id="ast和code的转换">AST和code的转换</h2>
<p>python代码有三个分身,</p>
<ol type="1">
<li>以unicode字符串存在的源代码. 人类可读写, python解释器不可读.</li>
<li>以AST对象存在的抽象语法树. 人类可读写, 但很难读懂原来的语义,
用来显示python语义元素之间的关系.
是从源代码翻译成目标代码的中间产品.</li>
<li>以code object存在的可执行的目标代码. python解释器可读,
人类不可读.</li>
</ol>
<span id="more"></span>
<p>source =&gt; AST: 使用<code>ast.parse()</code>. AST =&gt; object:
使用<code>compile()</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = ast.parse(<span class="string">&quot;print(&#x27;hello world&#x27;)&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree</span><br><span class="line">&lt;_ast.Module <span class="built_in">object</span> at <span class="number">0x00000000029D0820</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(<span class="built_in">compile</span>(tree, filename=<span class="string">&quot;&lt;ast&gt;&quot;</span>, mode=<span class="string">&quot;exec&quot;</span>))</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="modes">Modes</h3>
<p>源代码到AST的编译过程可以以三种不同模式进行.
AST的根节点依赖于传递给<code>ast.parse()</code>的mode参数,
并且在从AST到目标代码的编译过程中传递给<code>compile()</code>传递相同的mode参数.</p>
<ul>
<li>exec - 默认值是<code>mode='exec'</code>.
AST的根节点是<code>ast.Module</code>,
根节点的属性<code>body</code>是一个子节点的list.</li>
<li>eval -
单独的<strong>表达式</strong>可以被编译为<code>mode='eval'</code>的AST对象,
AST的根是一个<code>ast.Expression</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>,
他的属性<code>body</code>是一个单节点,
例如<code>ast.Call</code>或者<code>ast.BinOp</code>.
把这个AST对象传递给<code>eval()</code>将会返回表达式的值.</li>
<li>single -
单独的<strong>语句</strong>或者<strong>表达式</strong>可以被编译为<code>mode='single'</code>的AST对象,
AST的根是<code>ast.Interactive</code>,
它的属性<code>body</code>是一个子节点的list. 如果这是一个表达式,
<code>sys.displayhook()</code>将会被调用并传入表达式的结果,
就如同python的交互式shell被调用了一样.</li>
</ul>
<h3 id="修正行列号">修正行列号</h3>
<p>编译出的AST对象,
每一个节点都必须有行列号属性<code>lineno</code>并且<code>col_offset</code>.
从普通源代码编译而来的AST对象已经具有了行列号.
但是在程序中动态创建的节点没有行列好,
有几个<code>helper functions</code>可以做修正行列号.</p>
<ul>
<li><code>ast.fix_missing_locations()</code>
通过父节点的行列号递归的修正所有缺失行列号的节点.</li>
<li><code>ast.copy_location()</code>用于从另一个节点拷贝行列号.
特别是当做节点替换的时候有用.</li>
<li><code>ast.increment_lineno()</code>增加一个节点和其子节点的行号,
一般用于把代码块移动到其他位置.</li>
</ul>
<h3 id="反向转化">反向转化</h3>
<p>Python标准库不提供一种从目标码到AST, 或者从AST到源码转化的办法.
但一些第三方工具可以实现这些:</p>
<ul>
<li><a href="http://astor.readthedocs.io/en/latest/"><code>astor</code></a>
可以把AST转化为可读的Python code.</li>
<li><a href="http://pypi.python.org/pypi/meta"><code>Meta</code></a>
also tries to decompile Python bytecode to an AST, but it appears to be
unmaintained.</li>
<li><a href="https://pypi.python.org/pypi/uncompyle6"><code>uncompyle6</code></a>
is an actively maintained Python decompiler at the time of writing. Its
documented interface is a command line program producing Python source
code.</li>
</ul>
<h2 id="ast节点">AST节点</h2>
<p>AST节点把代码里的每一个元素表达为一个对象.
这些对象都是不同的AST子类的实例. 后面将会对每一种node对象逐一描述.</p>
<h3 id="literals-字面量">Literals (字面量)</h3>
<h4 id="before-python-3.8">Before Python 3.8</h4>
<p>在python 3.8以前的一部字面量的类, 在python3.8的时候已经不建议使用了,
下面列出这几个类</p>
<ul>
<li>class ast.Num(n), 用来表示整数, 浮点数, 复数</li>
<li>class ast.Str(n), 用来表示字符串</li>
<li>class ast.Bytes(s), 用来表示bytes类型</li>
<li>class ast.Ellipsis, 用来表示内置常量<code>...</code> Ellipsis</li>
<li>class ast.NameConstant(value), 用来表示内置常量<code>True</code>,
<code>False</code>, 或者<code>None</code>.</li>
</ul>
<p>上面这几个在Python3.8的时候被<code>ast.Constant</code>代替,
而且在未来的python版本中有可能被删除.</p>
<h4 id="class-ast.constantvalue-kind">class ast.Constant(value,
kind)</h4>
<ul>
<li><em>New in version 3.6.</em></li>
<li><em>Changed in version 3.8: The kind field was added.</em></li>
</ul>
<p>常量. <code>value</code>可以是上面提到几种常量,
也可以是immutable容器tuples和frozensets, 但要求容器中的元素都是常量.</p>
<h4 id="f-string">f-string</h4>
<p>Python3.6引入跟f-string对应的AST节点由下面两个组成</p>
<ul>
<li>class ast.FormattedValue(value, conversion, format_spec)</li>
<li>class ast.JoinedStr(values)</li>
</ul>
<p>看下面的例子可知, JoinedStr可以被看成一个list,
元素是字符串和FormattedValue组合而成.
FormattedValue的format_spec的值是一个JoinedStr.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;f&quot;sin(&#123;a&#125;) is &#123;sin(a):.3&#125;.&quot;&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Expr(value=JoinedStr(values=[</span><br><span class="line">        Constant(value=<span class="string">&#x27;sin(&#x27;</span>, kind=<span class="literal">None</span>),</span><br><span class="line">        FormattedValue(value=Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load()), conversion=-<span class="number">1</span>, format_spec=<span class="literal">None</span>),</span><br><span class="line">        Constant(value=<span class="string">&#x27;) is &#x27;</span>, kind=<span class="literal">None</span>),</span><br><span class="line">        FormattedValue(value=Call(func=Name(<span class="built_in">id</span>=<span class="string">&#x27;sin&#x27;</span>, ctx=Load()), args=[</span><br><span class="line">            Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load()),</span><br><span class="line">          ], keywords=[]), conversion=-<span class="number">1</span>, format_spec=JoinedStr(values=[</span><br><span class="line">            Constant(value=<span class="string">&#x27;.3&#x27;</span>, kind=<span class="literal">None</span>),</span><br><span class="line">          ])),</span><br><span class="line">        Constant(value=<span class="string">&#x27;.&#x27;</span>, kind=<span class="literal">None</span>),</span><br><span class="line">      ])),</span><br><span class="line">  ], type_ignores=[])</span><br></pre></td></tr></table></figure>
<p>注意上面使用的astpp类可以在绿树蛇的<a href="https://bitbucket.org/takluyver/greentreesnakes/src/master">git
repo</a>里找到, 将来在python3.9以后可以用ast.dump直接显示类似的结果.</p>
<h4 id="容器类">容器类</h4>
<ul>
<li>class ast.List(elts, ctx)</li>
<li>class ast.Tuple(elts, ctx)</li>
<li>class ast.Set(elts)</li>
</ul>
<p>这里elts代表每个元素节点的一个list,
ctx可以取两个值ast.Load和ast.Store之一.
当容器为赋值语句的目标的时候是ast.Store, 其他的时候就是ast.Load.</p>
<ul>
<li>class ast.Dict(keys, values)</li>
</ul>
<p>这里keys和values, 分别是字典的键值的元素AST节点的list,
要按照顺序对应.</p>
<h3 id="变量">变量</h3>
<ul>
<li><p>class ast.Name(id, ctx): 变量名,
id是一个字符串代表变量名</p></li>
<li><p>class ast.Starred(value, ctx): 代表*var, value是var的AST节点</p>
<p>ctx 可以是下面三个值之一</p></li>
<li><p>class ast.Load</p></li>
<li><p>class ast.Store</p></li>
<li><p>class ast.Del</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Expr(value=Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load())),</span><br><span class="line">  ], type_ignores=[])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;a=1&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Assign(targets=[</span><br><span class="line">        Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Store()),</span><br><span class="line">      ], value=Constant(value=<span class="number">1</span>, kind=<span class="literal">None</span>), type_comment=<span class="literal">None</span>),</span><br><span class="line">  ], type_ignores=[])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;del a&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Delete(targets=[</span><br><span class="line">        Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Del()),</span><br><span class="line">      ]),</span><br><span class="line">  ], type_ignores=[])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;a,*b=it&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Assign(targets=[</span><br><span class="line">        <span class="type">Tuple</span>(elts=[</span><br><span class="line">            Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Store()),</span><br><span class="line">            Starred(value=Name(<span class="built_in">id</span>=<span class="string">&#x27;b&#x27;</span>, ctx=Store()), ctx=Store()),</span><br><span class="line">          ], ctx=Store()),</span><br><span class="line">      ], value=Name(<span class="built_in">id</span>=<span class="string">&#x27;it&#x27;</span>, ctx=Load()), type_comment=<span class="literal">None</span>),</span><br><span class="line">  ], type_ignores=[])</span><br></pre></td></tr></table></figure>
<h3 id="expressions-表达式">Expressions 表达式</h3>
<h4 id="class-ast.exprvalue">class ast.Expr(value)</h4>
<p>如果一个表达式本身作为语句出现,
并且表达式的返回值没有被使用或者被存贮,
表达式将会被放到这个类的节点中.</p>
<p>value将为其他表达式节点, 常量节点, Name节点, Lambda节点, Yield节点,
YieldFrom节点之一.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;-a&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Expr(value=UnaryOp(op=USub(), operand=Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load()))),</span><br><span class="line">  ], type_ignores=[])</span><br></pre></td></tr></table></figure>
<h4 id="一元运算">一元运算</h4>
<p>class ast.UnaryOp(op, operand)</p>
<p>运算符op是如下几个类节点之一, operand是任何表达式</p>
<ul>
<li>class ast.UAdd</li>
<li>class ast.USub</li>
<li>class ast.Not</li>
<li>class ast.Invert</li>
</ul>
<h4 id="二元运算">二元运算</h4>
<p>class ast.BinOp(left, op, right)</p>
<p>运算符op是如下几个类节点之一, left和right是任何表达式</p>
<ul>
<li>class ast.Add</li>
<li>class ast.Sub</li>
<li>class ast.Mult</li>
<li>class ast.Div</li>
<li>class ast.FloorDiv</li>
<li>class ast.Mod</li>
<li>class ast.Pow</li>
<li>class ast.LShift¶</li>
<li>class ast.RShift</li>
<li>class ast.BitOr</li>
<li>class ast.BitXor</li>
<li>class ast.BitAnd</li>
<li>class ast.MatMult</li>
</ul>
<h4 id="布尔运算">布尔运算</h4>
<p>class ast.BoolOp(op, values)</p>
<p>op是下面的Or或者And. values是参与运算的节点的list,
注意这个list里可以多余两个元素, 表示连续的and或or.</p>
<ul>
<li>class ast.And</li>
<li>class ast.Or</li>
</ul>
<h4 id="比较">比较</h4>
<p>class ast.Compare(left, ops, comparators)</p>
<p>可以用来表达两个或者多个值的比较. left是第一个比较的元素,
ops是一个比较运算符的list,
comparators是出了第一个元素以外的元素的列表.</p>
<p>可用的比较操作符有:</p>
<ul>
<li>class ast.Eq</li>
<li>class ast.NotEq</li>
<li>class ast.Lt</li>
<li>class ast.LtE</li>
<li>class ast.Gt</li>
<li>class ast.GtE</li>
<li>class ast.Is</li>
<li>class ast.IsNot</li>
<li>class ast.In</li>
<li>class ast.NotIn</li>
</ul>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;a &lt;= b &lt; c&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Expr(value=Compare(left=Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load()), ops=[</span><br><span class="line">        LtE(),</span><br><span class="line">        Lt(),</span><br><span class="line">      ], comparators=[</span><br><span class="line">        Name(<span class="built_in">id</span>=<span class="string">&#x27;b&#x27;</span>, ctx=Load()),</span><br><span class="line">        Name(<span class="built_in">id</span>=<span class="string">&#x27;c&#x27;</span>, ctx=Load()),</span><br><span class="line">      ])),</span><br><span class="line">  ], type_ignores=[])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;a == b &#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Expr(value=Compare(left=Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load()), ops=[</span><br><span class="line">        Eq(),</span><br><span class="line">      ], comparators=[</span><br><span class="line">        Name(<span class="built_in">id</span>=<span class="string">&#x27;b&#x27;</span>, ctx=Load()),</span><br><span class="line">      ])),</span><br><span class="line">  ], type_ignores=[])</span><br></pre></td></tr></table></figure>
<h4 id="函数调用">函数调用</h4>
<p>class ast.Call(func, args, keywords, starargs, kwargs)</p>
<p>func代表函数, 通常是一个Name或者Attribute对象. args是pass by
postion的参数的列表, keywords是一个keyword对象的列表表示pass by
keyword的参数.</p>
<p>class ast.keyword(arg, value)</p>
<p>arg表示形参的名字, value是传入的实参.</p>
<h4 id="class-ast.ifexptest-body-orelse">class ast.IfExp(test, body,
orelse)</h4>
<p>if表达式是如同<code>a if b else c</code>的表达式, test, body,
orelse都是一个单独的node.</p>
<h4 id="class-ast.attributevalue-attr-ctx">class ast.Attribute(value,
attr, ctx)</h4>
<p><code>d.keys</code>形式的表达式. value是一个节点, 典型的是一个Name.
attr是一个字符串表示给定attribute的名字, ctx是Load,
Store或者Del之一.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&#x27;obj.attr&#x27;</span>)</span><br><span class="line">Module(body=[</span><br><span class="line">    Expr(value=Attribute(value=Name(<span class="built_in">id</span>=<span class="string">&#x27;obj&#x27;</span>, ctx=Load()), attr=<span class="string">&#x27;attr&#x27;</span>, ctx=Load())),</span><br><span class="line">  ], type_ignores=[])</span><br></pre></td></tr></table></figure>
<h4 id="class-ast.namedexprtarget-value">class ast.NamedExpr(target,
value)</h4>
<p>python 3.8引入的赋值表达式<code>:=</code></p>
<h3 id="subscripting-下标访问">Subscripting (下标访问)</h3>
<p>class ast.Subscript(value, slice, ctx)</p>
<p>形如<code>a[1]</code>, <code>a['x']</code>的运算.
value是被下标访问的对象, 通常是一个sequence或者mapping. slice是Index,
Slice或者ExtSlice之一.</p>
<p><em>在未来的python3.9之后Index和ExtSlice都被移除了,
将合并到Slice里.</em></p>
<ul>
<li>class ast.Index(value) : 单值索引</li>
<li>class ast.Slice(lower, upper, step) : 切片</li>
<li>class ast.ExtSlice(dims) : 切片的扩展,
dims是一个Slice和Index的list.</li>
</ul>
<p>切片的扩展, dims是一个Slice和Index的list.</p>
<h3 id="comprehensions不知道标准翻译是啥-推导式">Comprehensions(不知道标准翻译是啥,
推导式?)</h3>
<ul>
<li>class ast.ListComp(elt, generators)</li>
<li>class ast.SetComp(elt, generators)</li>
<li>class ast.GeneratorExp(elt, generators)</li>
<li>class ast.DictComp(key, value, generators)</li>
</ul>
<p>分别代表list comprehensions, set comprehensions, generator
expressions, 和dictionary comprehensions.</p>
<p>elt(或key-value)是单节点, 表示将被推导的变量.
generators是一个comprehension节点的list.</p>
<h4 id="class-ast.comprehensiontarget-iter-ifs-is_async">class
ast.comprehension(target, iter, ifs, is_async)</h4>
<p>一个用于推导的for语句. target用于表示每个元素,
通常是Name或者Tuple节点, iter是可迭代的对象. ifs是一个test
expressions的列表, 每个for语句可以能有多个ifs.</p>
<p><em>New in version 3.6: is_async indicates a comprehension is
asynchronous (using an async for instead of for). The value is an
integer (0 or 1).</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&quot;[ord(c) for line in file for c in line]&quot;</span>, mode=<span class="string">&#x27;eval&#x27;</span>) <span class="comment"># Multiple comprehensions in one.</span></span><br><span class="line">Expression(body=ListComp(elt=Call(func=Name(<span class="built_in">id</span>=<span class="string">&#x27;ord&#x27;</span>, ctx=Load()), args=[</span><br><span class="line">    Name(<span class="built_in">id</span>=<span class="string">&#x27;c&#x27;</span>, ctx=Load()),</span><br><span class="line">  ], keywords=[]), generators=[</span><br><span class="line">    comprehension(target=Name(<span class="built_in">id</span>=<span class="string">&#x27;line&#x27;</span>, ctx=Store()), <span class="built_in">iter</span>=Name(<span class="built_in">id</span>=<span class="string">&#x27;file&#x27;</span>, ctx=Load()), ifs=[], is_async=<span class="number">0</span>),</span><br><span class="line">    comprehension(target=Name(<span class="built_in">id</span>=<span class="string">&#x27;c&#x27;</span>, ctx=Store()), <span class="built_in">iter</span>=Name(<span class="built_in">id</span>=<span class="string">&#x27;line&#x27;</span>, ctx=Load()), ifs=[], is_async=<span class="number">0</span>),</span><br><span class="line">  ]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astpp.parseprint(<span class="string">&quot;(n**2 for n in it if n&gt;5 if n&lt;10)&quot;</span>, mode=<span class="string">&#x27;eval&#x27;</span>)       <span class="comment"># Multiple if clauses</span></span><br><span class="line">Expression(body=GeneratorExp(elt=BinOp(left=Name(<span class="built_in">id</span>=<span class="string">&#x27;n&#x27;</span>, ctx=Load()), op=Pow(), right=Constant(value=<span class="number">2</span>, kind=<span class="literal">None</span>)), generators=[</span><br><span class="line">    comprehension(target=Name(<span class="built_in">id</span>=<span class="string">&#x27;n&#x27;</span>, ctx=Store()), <span class="built_in">iter</span>=Name(<span class="built_in">id</span>=<span class="string">&#x27;it&#x27;</span>, ctx=Load()), ifs=[</span><br><span class="line">        Compare(left=Name(<span class="built_in">id</span>=<span class="string">&#x27;n&#x27;</span>, ctx=Load()), ops=[</span><br><span class="line">            Gt(),</span><br><span class="line">          ], comparators=[</span><br><span class="line">            Constant(value=<span class="number">5</span>, kind=<span class="literal">None</span>),</span><br><span class="line">          ]),</span><br><span class="line">        Compare(left=Name(<span class="built_in">id</span>=<span class="string">&#x27;n&#x27;</span>, ctx=Load()), ops=[</span><br><span class="line">            Lt(),</span><br><span class="line">          ], comparators=[</span><br><span class="line">            Constant(value=<span class="number">10</span>, kind=<span class="literal">None</span>),</span><br><span class="line">          ]),</span><br><span class="line">      ], is_async=<span class="number">0</span>),</span><br><span class="line">  ]))</span><br></pre></td></tr></table></figure>
<h3 id="statements-语句">Statements 语句</h3>
<p>下面罗列一下所有的语句节点的类, 具体内容以后用到了再填写.</p>
<h4 id="assgin-赋值语句">Assgin 赋值语句</h4>
<ul>
<li>class ast.Assign(targets, value, type_comment)</li>
<li>class ast.AnnAssign(target, annotation, value, simple)</li>
<li>class ast.AugAssign(target, op, value)</li>
</ul>
<h4 id="other">Other</h4>
<ul>
<li>class ast.Raise(exc, cause)</li>
<li>class ast.Assert(test, msg)</li>
<li>class ast.Delete(targets)</li>
<li>class ast.Pass</li>
</ul>
<h4 id="imports">Imports</h4>
<ul>
<li>class ast.Import(names)</li>
<li>class ast.ImportFrom(module, names, level)</li>
<li>class ast.alias(name, asname)</li>
</ul>
<h4 id="control-flow">Control flow</h4>
<ul>
<li>class ast.If(test, body, orelse)</li>
<li>class ast.For(target, iter, body, orelse, type_comment)</li>
<li>class ast.While(test, body, orelse)</li>
<li>class ast.Break</li>
<li>class ast.Continue</li>
<li>class ast.Try(body, handlers, orelse, finalbody)</li>
<li>class ast.ExceptHandler(type, name, body)</li>
<li>class ast.With(items, body, type_comment)</li>
<li>class ast.withitem(context_expr, optional_vars)</li>
</ul>
<h4 id="function-and-class-definitions">Function and class
definitions</h4>
<ul>
<li>class ast.FunctionDef(name, args, body, decorator_list, returns,
type_comment)</li>
<li>class ast.Lambda(args, body)</li>
<li>class ast.arguments(posonlyargs, args, vararg, kwonlyargs,
kw_defaults, kwarg, defaults)</li>
<li>class ast.arg(arg, annotation, type_comment)</li>
<li>class ast.Return(value)</li>
<li>class ast.Yield(value)</li>
<li>class ast.YieldFrom(value)</li>
<li>class ast.Global(names)</li>
<li>class ast.Nonlocal(names)</li>
<li>class ast.ClassDef(name, bases, keywords, starargs, kwargs, body,
decorator_list)</li>
</ul>
<h4 id="async-and-await">Async and await</h4>
<ul>
<li>class ast.AsyncFunctionDef(name, args, body, decorator_list,
returns, type_comment)</li>
<li>class ast.Await(value)</li>
<li>class ast.AsyncFor(target, iter, body, orelse, type_comment)</li>
<li>class ast.AsyncWith(items, body, type_comment)</li>
</ul>
<h3 id="top-level-nodes">Top level nodes</h3>
<ul>
<li>class Module(stmt* body, type_ignore *type_ignores)</li>
<li>class Interactive(stmt* body)</li>
<li>class Expression(expr body)</li>
</ul>
<h2 id="操作ast">操作AST</h2>
<p>对于已存在的AST,
ast模块为我们提供了多种helper函数帮助我们在一个庞大的树中找到我们想要找到的枝叶.</p>
<h3 id="class-ast.nodevisitor">class ast.NodeVisitor</h3>
<p>这是一个节点访问的基类, 可以帮助我们遍历树的节点,
并且为每一个不同种类的节点调用不同的处理函数.
使用方法是首先以此类为基类创建一个访客子类, 为访客子类编写访客函数.
访客函数就是是override基类的一些方法, 形如<code>visit_classname</code>,
这里<code>classname</code>就是前一章里提到的所有节点类.</p>
<p>这个类有两个不需要被override的方法</p>
<ul>
<li>visit(node)</li>
<li>generic_visit(node)</li>
</ul>
<p><br> visit(node)是访问某个节点的主函数, 其默认执行逻辑逻辑如下:</p>
<p>{% mermaid graph TB %} id0((start)) --&gt;
id1["visit(node)方法检查输入的节点类"] id1 --&gt;
id2{"访客类是否实现了该节点<br>的visit_classname()方法?"} id2 --Y--&gt;
id3["调用visit_classname(node)方法"] id2 --N--&gt;
id4["调用generic_visit(node)方法"] id4 --&gt; id5["遍历每一个子节点"]
id3 --&gt; id6{"定制化visit方法是否<br>调用generic_visit(node)方法?"}
id6 --Y--&gt; id4 id6 --N--&gt; id7((stop)) id5 --&gt;
id8{"是否还有没访问的子节点"} id8 --Y--&gt;
id9["选择下一个子节点,<br>以其为参数调用visit(node)"] id9 --&gt; id1
id8 --N--&gt; id7 {% endmermaid %}</p>
<p>注意, 1. 如果想要修改某些节点, 请不要用NodeVisitor这个类,
而要用NodeTransformer这个类. 2. Deprecated since version 3.8: Methods
visit_Num(), visit_Str(), visit_Bytes(), visit_NameConstant() and
visit_Ellipsis() are deprecated now and will not be called in future
Python versions. Add the visit_Constant() method to handle all constant
nodes.</p>
<h3 id="其他遍历方法">其他遍历方法</h3>
<p>一些其他的helper函数可以帮我们访问到我们想要的节点.</p>
<ul>
<li>ast.walk(node): 递归的产生一个列表,
包括以node为根节点整棵树的所有节点, 但顺序无法保证.
这个一般用于想要访问或者修改某些节点, 但不关心这些节点的上下文.</li>
<li>ast.iter_child_nodes(node): 产生一个节点的所有子节点的列表,
这里包括该节点类的单节点属性和节点列表属性的所有元素.</li>
<li>当然你永远都可以直接通过一个节点的属性来访问其他节点. 这时,
所有的python关于迭代和索引的工具都是有效的. 特别是,
isinstance()对于检查到底是什么节点非常有用.</li>
</ul>
<h3 id="监测节点">监测节点</h3>
<p>ast module提供几个helper函数帮忙检测节点.</p>
<ul>
<li>ast.iter_fields(node):
为节点的node._fields里的每个属性,产生一个一个tuple, (fieldname,
value).</li>
<li>ast.get_docstring(node, clean=True):
返回一个节点(类型必须为FunctionDef, AsyncFunctionDef, ClassDef,
或者Module)的docstring. 如果没有docstring, 则返回None.</li>
<li>ast.dump(node, annotate_fields=True, include_attributes=False, *,
indent=None): <em>Changed in version 3.9</em>: Added the indent
option.</li>
</ul>
<h3 id="修改ast">修改AST</h3>
<p>修改AST的关键工具是基类class ast.NodeTransformer.
这个类的工作方式跟NodeVisitor非常像.
唯一的不同是visit_classname()方法的返回值如果是一个节点对象,
原节点将被返回的节点替代. 如果返回值是None, 原节点将被删除.
如果返回原节点, 那么原节点的替代将不会发生.</p>
<p>如果想要操作输入节点的子节点, 你必须或者手动修改子节点,
或者在返回前先调用generic_visit()方法.</p>
<p>需要小心的是, 如果你的修改和删除产生了无效的AST, python不会报错.
只有当你尝试编译AST成目标代码时(调用compile()), 会有异常抛出.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>注意<code>ast.Expression</code>跟<code>ast.Expr</code>不同.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ast</tag>
      </tags>
  </entry>
  <entry>
    <title>通过hexo + NexT + github pages + 搭建个人博客(二) -- plugin-tags</title>
    <url>//338d5118/</url>
    <content><![CDATA[<p>前一篇<a href="/9cbcca7a/" title="通过hexo + NexT + github pages + 搭建个人博客(一)">通过hexo + NexT + github pages + 搭建个人博客(一)</a></p>
<p><a href="https://hexo.io/docs/tag-plugins.html">Hexo官方文档</a>介绍了很多默认支持的Plugin
Tags.</p>
<p><a href="https://theme-next.js.org/docs/tag-plugins">NexT官方文档</a>又增加了很多Next
Theme额外支持的.</p>
<p>我把这两篇文章的所有Tags列在下列表里,
并增加一些例子留作记录以便之后使用:</p>
<span id="more"></span>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Hexo Tags<br>(点击看实例)</th>
<th>标签</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://hexo.io/docs/tag-plugins#Block-Quote">Block
Quote</a></td>
<td> {% blockquote [author[, source]] [link] [source_link_title] %}<br>content<br> {% endblockquote %} </td>
</tr>
<tr class="even">
<td><a href="https://hexo.io/docs/tag-plugins#Code-Block">Pull
Quote</a></td>
<td> {% pullquote [class] %}<br>content<br> {% endpullquote %}  <br> 效果跟blockquote没有什么区别.</td>
</tr>
<tr class="odd">
<td><a href="https://hexo.io/docs/tag-plugins#Code-Block">Code
Block</a></td>
<td> {% codeblock [title] [lang:language] [url] [link text] %} <br> or  ``` [language] [title] [url] [link text] code snippet ``` </td>
</tr>
<tr class="even">
<td><a href="#jsFiddle">jsFiddle</a></td>
<td> {% jsfiddle shorttag [tabs] [skin] [width] [height] %} </td>
</tr>
<tr class="odd">
<td><a href="#Gist">Gist</a></td>
<td> {% gist gist_id [filename] %} </td>
</tr>
<tr class="even">
<td><a href="#iframe">iframe</a></td>
<td> {% iframe url [width] [height] %} </td>
</tr>
<tr class="odd">
<td><a href="#image">image</a></td>
<td> {% img [class names] /path/to/image [width] [height] "title text 'alt text'" %} </td>
</tr>
<tr class="even">
<td><a href="#link">link</a></td>
<td> {% link text url [external] [title] %} </td>
</tr>
<tr class="odd">
<td><a href="#include-code">Include Code</a></td>
<td> {% include_code [title] [lang:language] [from:line] [to:line] path/to/file %} </td>
</tr>
<tr class="even">
<td><a href="https://hexo.io/docs/tag-plugins#YouTube">YouTube</a></td>
<td> {% youtube video_id %} </td>
</tr>
<tr class="odd">
<td><a href="https://hexo.io/docs/tag-plugins#Vimeo">Vimeo</a></td>
<td> {% vimeo video_id [width] [height] %} </td>
</tr>
<tr class="even">
<td><a href="#include-posts">Include Posts</a></td>
<td> {% post_path filename %}<br>{% post_link filename [optional text] [escape] %} </td>
</tr>
<tr class="odd">
<td><a href="#inlcude-assets">Include Assets</a></td>
<td> {% asset_path slug %}<br>{% asset_img slug [title] %}<br>{% asset_link slug [title] [escape] %}</td>
</tr>
<tr class="even">
<td>Raw</td>
<td> {% raw %} content {% endraw %} </td>
</tr>
<tr class="odd">
<td>Post摘录</td>
<td><code>&lt;!-- more --&gt;</code></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>NexT Tags<br>(点击看实例)</th>
<th>标签</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://theme-next.org/docs/tag-plugins/#Centered-Quote">Centered
Quote</a></td>
<td> {% centerquote %}Something{% endcenterquote %}<br> {% cq %}Something{% endcq %}</td>
</tr>
<tr class="even">
<td><a href="https://theme-next.org/docs/tag-plugins/#Include-Raw">Include
Raw</a></td>
<td> {% include_raw '_data/path/to/file.html' %} </td>
</tr>
<tr class="odd">
<td><a href="https://theme-next.org/docs/tag-plugins/note">Note</a></td>
<td> {% note [class] [no-icon] %} <br> Any content (support inline tags too.io).<br> {% endnote %}<br> <br>[class]   : default | primary | success | info | warning | danger.<br> [no-icon] : Disable icon in note.</td>
</tr>
<tr class="even">
<td><a href="https://theme-next.org/docs/tag-plugins/tabs">Tabs</a></td>
<td> {% tabs Unique name, [index] %}<br> < !-- tab [Tab caption] [@icon] --><br> Any content (support inline tags too).<br> < !-- endtab --><br> {% endtabs %}</td>
</tr>
<tr class="odd">
<td><a href="#mermaid_draw">Mermaid</a></td>
<td> {% mermaid type %}<br>{% endmermaid %}<br><br> type : type of the mermaid chart, visit https://github.com/knsv/mermaid for more information.</td>
</tr>
<tr class="even">
<td><a href="https://theme-next.org/docs/tag-plugins/video">Video</a></td>
<td> {% video url %} </td>
</tr>
<tr class="odd">
<td><a href="https://theme-next.org/docs/tag-plugins/group-pictures">图组</a></td>
<td> {% grouppicture [group]-[layout] %}{% endgrouppicture %} <br>{% gp [group]-[layout] %}{% endgp %}<br><br> [group]  : Total number of pictures to add in the group. <br> [layout] : Default picture under the group to show.</td>
</tr>
</tbody>
</table>
<h3 id="jsfiddle">jsFiddle <span id="jsFiddle"></span></h3>
<p>这是一款HTML,CSS,JAVASCRIPT在线调试工具,
官网地址https://jsfiddle.net/ 先注册,
然后写好代码存储之后可以在地址栏里"https://jsfiddle.net/"后面的部分就是shorttag.
例如下面这个.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% jsfiddle retzzz/w05mcnde %&#125;</span><br></pre></td></tr></table></figure>
<p>可以渲染成:</p>
<iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/retzzz/w05mcnde/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen></iframe>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% jsfiddle retzzz/w05mcnde result,html,js,css dark 600 300 %&#125;</span><br></pre></td></tr></table></figure>
<p>可以渲染成:</p>
<iframe scrolling="no" width="600" height="300" src="https://jsfiddle.net/retzzz/w05mcnde/embedded/result,html,js,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>
<h3 id="gist">Gist <span id="Gist"></span></h3>
<p>Gist是github提供的一个额外的功能, 可以快速的记录代码片段, 文档.
网址<a href="https://gist.github.com/">https://gist.github.com</a>,
每条gist实际就是一个git repository. 可以包含多个文件. 对应一个gist ID,
可以在地址栏中找到. 下面这行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% gist 8da7592dc849d364330acebe8cf88ca3 helloworld.py %&#125;</span><br></pre></td></tr></table></figure>
<p>可以渲染成:</p>
<script src="//gist.github.com/8da7592dc849d364330acebe8cf88ca3.js?file=helloworld.py"></script>
<h3 id="iframe">iframe <span id="iframe"></span></h3>
<p>iframe可以用来插入别的单独页面, 可以是本地的, 也可以上网络上的,
比如下面一行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% iframe http://player.youku.com/embed/XOTI3NDc1OTU2 500 300 %&#125;</span><br></pre></td></tr></table></figure> 插入了优酷页面, 将被渲染成</p>
<iframe src="http://player.youku.com/embed/XOTI3NDc1OTU2" width="200" height="150" frameborder="0" loading="lazy" allowfullscreen></iframe>
<!-- iframe https://www.youtube-nocookie.com/embed/7gJ8mGFjeqA 500 300 -->
<p>而这个 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% iframe /tags/index.html 500 300 %&#125;</span><br></pre></td></tr></table></figure> 使用了本地页面(注意地址以"/"开头),
将被渲染成</p>
<iframe src="/tags/index.html" width="500" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>
<h3 id="image">image <span id="image"></span></h3>
<p>拷贝zsnt.jpg到你博客源代码目录source/images下, 则下面这行
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% img class1 /images/zsnt.jpg 400 300 &quot;南通机场 &#x27;图片无法显示&#x27; &quot; %&#125;</span><br></pre></td></tr></table></figure> 将被渲染成:</p>
<img src="/images/zsnt.jpg" class="class1" width="400" height="300" title="南通机场 " alt="图片无法显示">
<h3 id="link">link <span id="link"></span></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure>
<p>这里external可以被设置成"true"或者"false",
true意味着在新标签打开链接, "false"意思是用本页打开链接.
而title是鼠标悬停时显示的提示.</p>
<p>下面两个例子: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% link &quot;Go to bing in this tab&quot; https://www.bing.com false &quot;Go to bing1&quot; %&#125;</span><br></pre></td></tr></table></figure> <a href="https://www.bing.com/" title="Go to bing1" target>Go to bing in this tab</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% link &quot;Go to bing in new tab&quot; https://www.bing.com true &quot;Go to bing2&quot; %&#125;</span><br></pre></td></tr></table></figure>
<a href="https://www.bing.com/" title="Go to bing2" target="_blank">Go to bing in new tab</a>
<p>我理解是一般情况下我们可以用markdown语法里提供的链接方式就可以了,
但是如果想要在当前tab打开链接或者想要有鼠标悬停提示,
可以使用这个tag.</p>
<h3 id="include-code">Include Code <span id="include-code"></span></h3>
<p>这个tag可以帮助把一个本地源代码中的一部分显示到页面里.
这些代码默认在<code>source/downloads/code</code>下存放,
也可以通过修改config文件里的<code>code_dir</code>来修改默认指定的位置.
比如下面这行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:python from:5 to:10 abc.py %&#125;</span><br></pre></td></tr></table></figure> 将被渲染为: <figure class="highlight python"><figcaption><span>这是一个python脚本</span><a href="/downloads/code/abc.py">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> _weakrefset <span class="keyword">import</span> WeakSet</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instance of old-style class</span></span><br></pre></td></tr></table></figure></p>
<p>这个办法比起Gist来说更加不方便, 所以建议直接用Gist.</p>
<h3 id="include-posts">Include Posts <span id="include-posts"></span></h3>
<p>这个可以帮助在不同的文章间跳转和引用.</p>
<p>比如下面这两行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_path buildblog %&#125;</span><br></pre></td></tr></table></figure> 被渲染为字符串: /9cbcca7a/</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link buildblog %&#125;</span><br></pre></td></tr></table></figure>
<p>被渲染为超链接: <a href="/9cbcca7a/" title="通过hexo + NexT + github pages + 搭建个人博客(一)">通过hexo + NexT + github pages + 搭建个人博客(一)</a></p>
<p><a href="https://hexo.io/docs/tag-plugins#Include-Posts">点击这里</a>可以跳转到官网帮助</p>
<p>这里有一件事情, 是不管是这个post_link还是前面提到的link,
或者是markdown的语法<code>[]()</code>都做不好, 就是通过html tag
id跳转到某个post的指定位置.</p>
<p>唯一比较可行的办法是通过一个plugin <a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a>简化一下permalink,
然后直接用<code>[]()</code>直接用hard code的permalink跳转, 比如
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[buildblog#image](/9cbcca7a/#image)</span><br></pre></td></tr></table></figure> 被渲染成可以直接跳转的: <a href="/9cbcca7a/#image">buildblog#image</a></p>
<h3 id="include-assets-include-assets">Include Assets
(#include-assets)</h3>
<p><a href="https://hexo.io/docs/asset-folders.html">这篇文章</a>介绍了global
asset folder和post asset folder, 当配置文件里设置了post asset folder,
并且copy一个有jpg文件进去(这里我的文件叫runway.jpg).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path runway.jpg %&#125;</span><br></pre></td></tr></table></figure>
<p>被渲染成字符串 /338d5118/runway.jpg <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img runway.jpg &quot;asset img&quot; %&#125;</span><br></pre></td></tr></table></figure> 被渲染成图片:
<img src="/338d5118//runway.jpg" class title="asset img"> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_link runway.jpg &quot;asset link&quot; %&#125;</span><br></pre></td></tr></table></figure> 被渲染成超链接: <a href="/338d5118/runway.jpg" title="asset link">asset link</a></p>
<h3 id="mermaid画图">Mermaid画图 <span id="mermaid_draw"></span></h3>
<p>Mermaid是用文本生成图表的一个工具, 配置里面需要手动激活
<figure class="highlight plaintext"><figcaption><span>_config.next.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p>
<p>比如下面这段 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid graph TD %&#125;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure> 会被渲染成:</p>
<pre class="mermaid">
graph TD
A--&gt;B;
A--&gt;C;
B--&gt;D;
C--&gt;D;
</pre>
<p>现在支持流程图, 时序图, 类图, 状态图, 甘特图. 更多帮助可以参考<a href="http://mermaid-js.github.io/mermaid">官网</a></p>
<p>这里有个坑, 如果有其他html标签的id是"mermaid", 会导致渲染无法成功.
避免使用mermaid做heading, 和任何锚点.</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>choco-install</title>
    <url>//38e06c9c/</url>
    <content><![CDATA[<p><a href="https://chocolatey.org/">Chocolatey</a>是windows上的包管理系统,
类似于Linux上的yum或者apt.</p>
<span id="more"></span>
<p>安装的时候有一个知识点由于官方文档没提, 过去一直不知道.
过去安装的时候一直按照这个<a href="https://chocolatey.org/docs/installation#non-administrative-install">官方教程</a>来安装.
里面没有详细解释如何在非管理员条件下安装chocolatey,
以及通过chocolatey安装的各种包.</p>
<p>解决方案非常简单, 设置一个环境变量<strong>ChocolateyInstall</strong>,
配置成想要安装的目录即可.</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>chocolatey</tag>
        <tag>choco</tag>
      </tags>
  </entry>
  <entry>
    <title>通过hexo + NexT + github pages + 搭建个人博客(一)</title>
    <url>//9cbcca7a/</url>
    <content><![CDATA[<p>之前一直用各种笔记记录应用记录自己的学习过程. 由于只给自己看,
所以都是比较潦草的想到哪记录到哪. 但一旦碰到过已经记录的问题时,
很少去翻自己的笔记, 原因一是公司屏蔽内网屏蔽了好多这种笔记,
另一个是大部分google起来也很容易,
查看自己写的潦草的笔记还不如google一个优秀的技术博客来得快.</p>
<p>但最近我想给自己点压力, 把学过的内容整理成完整的文章. 尽量详尽.
即便没有别人读, 将来也可以留给我儿子看:).
争取把前因后果和自己的思考过程交代清楚, 而不是只有技术要点的bullet.
因为我发现网上能帮助到我的别人的博客, 往往都是这种写的很罗嗦的文章.</p>
<p>这篇作为第一篇, 就讲讲这个博客是怎么搭建起来的.</p>
<h2 id="需求">需求</h2>
<p>我自己给要搭建的博客定了如下一些需求:</p>
<ol type="1">
<li>能够使用markdown语法编辑博客内容.</li>
<li>能够快速发布到网站.</li>
<li>支持文章中的代码片段语法高亮.</li>
<li>支持数学公式.</li>
<li>支持分级标签.</li>
<li>支持搜索.</li>
<li>尽量少的网站管理工作.</li>
</ol>
<h2 id="方案">方案</h2>
<span id="more"></span>
<p>根据这个需求我开始在google一顿狂搜. 最后决定的方案就是如同标题.
下面分别解释一下这几个都是什么.</p>
<ul>
<li><a href="http://zh.wikipedia.com/wiki/Markdown">Markdown</a>:
一种轻量级标签语言, 其目标是纯文本的源文件是人类可读的,
但是有一定程度的结构化, 可以很容易转换成机器可读的html或者LeTeX.
人类可读可以让非技术人员也可以轻松使用, 结构化可以让电脑可以很容易解析.
能结合这两点的方案基本只有这一个, 没有别可替换的方案.
当然也可以直接写LeTeX和html, 但都无法让源文件是人类可读的,
对于写博客来说太重了.</li>
<li><a href="https://hexo.io">hexo</a>: 一个博客框架(framework),
可以把markdown写作的源文件渲染(render)成静态的html页面.
写博客的人其实只想书写博客的内容,
但是却很贪心的想要让这些内容更加优美的显示出来. 字体选择, 排版, 打标签,
分类, 搜索等等这些一个博客必要的因素都可由hexo框架帮助完成.
这种类型的框架有很多选择. 比如hugo和jekyll, 点击<a href="https://www.techiediaries.com/jekyll-hugo-hexo/">这里</a>可以看到它们比较.
根据这篇文章, hexo的优点一个是快, 一个是基本没有什么缺点,
唯一的缺点是很多文档是中文的:). hexo这个框架作者好像是个台湾大学生,
使用node.js开发的.</li>
<li><a href="https://theme-next.js.org">NexT</a>:
这是hexo的一个主题(theme), 也是github上点赞最多的一个. 页面精美简洁,
非常喜欢. hexo的一个特点就是可扩展性强, 很多插件(plugin)和主题可选.</li>
<li><a href="pages.github.com">github pages</a>:
这个是github提供的一个静态页面托管服务. 免费稳定,
不管是国家还是公司都应该不会墙掉它.
只要把hexo渲染出来的静态页面上传到这里托管, 公网上就可以直接访问.</li>
<li><a href="https://www.mathjax.org/">mathjax</a>:
这是一个开源的javascript库,
可以把TeX格式的数学公式在网页上渲染成人类可读的数学公式.
这个其实不需要安装, NexT可以直接支持. 但有一些坑, 我稍后会讲.</li>
</ul>
<h2 id="实施">实施</h2>
<h3 id="hexo">hexo</h3>
<h4 id="前提">前提</h4>
<p>安装hexo, 有两个前提一个是<a href="https://git-scm.com/">git</a>,
一个是<a href="https://nodejs.org/en/">note.js</a>.
这两个的安装基本就是下载安装文件, 双击打开, 不停点next就好了.
截止于写这篇文章的时候, 我机器上安装的版本分别是 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.9.0</span><br><span class="line">$ npm -v</span><br><span class="line">6.2.0</span><br><span class="line">$ git --version</span><br><span class="line">git version 2.17.1.windows.2</span><br></pre></td></tr></table></figure></p>
<h4 id="安装hexo">安装hexo <span id="installation"></span></h4>
<p>之后只要按照hexo<a href="https://hexo.io">官网首页</a>上的提示运行下面命令就可以安装hexo
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure> 安装完可以通过下面的命令查询一下安装的版本
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo version</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Windows_NT 10.0.15063 win32 x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.9.0</span><br><span class="line">v8: 6.8.275.24-node.14</span><br><span class="line">uv: 1.22.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.32.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure></p>
<h4 id="初始化博客网站">初始化博客网站 <span id="init"></span></h4>
<p>继续按照官网文档执行下面这些命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>其中folder是你博客网站的根目录. 如果当前目录就是根目录, 可以省略.
注意最后一条命令不能省略.</p>
<p>这时候系统默认有一片hello world的博客, 你可以通过 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
在本地启动一个端口为4000的web server,
直接访问http://localhost:4000查看这个hello world页面.</p>
<p>之后要做的就是修改配置, 然后就可以通过一些hexo命令创建新的博客了,
这里可以参考官方文档的<a href="https://hexo.io/zh-cn/docs/configuration">配置</a>和<a href="https://hexo.io/zh-cn/docs/commands">命令</a>两个章节.</p>
<p>修改配置文件的时候, 注意设置语言和时区的时候注意大小写敏感,
我的设置如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure></p>
<h4 id="新建博客文章">新建博客文章 <span id="newpost"></span></h4>
<p>根据官网帮助, 使用<code>new</code>命令可以新建一个博客,
但官网关于命令中的<code>layout</code>说得不是很明白.
<code>layout</code>默认可以有3种可能: <code>post, page and draft</code>.
命令里省略<code>layout</code>就使用默认值<code>post</code>.
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="post">post</h5>
<p>一个<code>post</code>就是一篇普通的博客文章,
运行完这条命令你就可以在<code>source\_post</code>下找到这个后缀为md的文章,
使用<code>markdown</code>语法编辑你的文章就成为了源文件.</p>
<p>注意这个源文件最开头有个由三横杠<code>---</code>分割出来的头部,
里面包含一些关于这篇文章的属性信息, 你可以在<a href="https://hexo.io/docs/front-matter">官方文档</a>里找到所有可以设置的元素.</p>
<p>这里有两个要特别说明一下, tags和categories.
这两个都可以理解对文章的关键属性打标签. 不同点是, tags是纯粹的标签,
跟文章是多对多的关系.
categories是一个具有树状结构标签(所以也可以理解成分类),
每篇文章只能是这棵树的一个叶子节点. 例如我这篇文章的头部如下:
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">通过hexo</span> <span class="string">+</span> <span class="string">NexT</span> <span class="string">+</span> <span class="string">github</span> <span class="string">pages</span> <span class="string">+</span> <span class="string">搭建个人博客</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NexT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">github</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">技术</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">杂项</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Mingjian</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-02 23:12:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure> 其中对文章的分类是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">技术</span><br><span class="line"> \_杂项</span><br><span class="line">    \_搭建个人博客</span><br></pre></td></tr></table></figure></p>
<p>这个是我个人认为最好的一种组合, 既有灵活的tags,
又有结构化的categories, 可以更好的组织整理自己的知识.</p>
<h5 id="draft">draft</h5>
<p>顾名思义, 这是草稿,
你可以用<code>hexo new draft &lt;blogname&gt;</code>命令生成一个新的草稿.
之后就可以在<code>source/_draft</code>下找到这个<code>markdown</code>文件了.
既然是草稿, 就说明还没完成. 作为博客框架应该提供预览功能,
和一键发布的能力. hexo当然没有让我们失望.</p>
<ul>
<li>不论你用<code>hexo g</code>进行html渲染还是用<code>hexo d</code>部署,
或者用<code>hexo s</code>在本地运行server你都无法看到这个草稿的静态网页形式,
它只以<code>markdown</code>形式的源文件保存在本地.</li>
<li>一旦你完成了草稿, 可以用<code>hexo publish</code>来发布文章.</li>
<li>发布之前,
如果你想预览可以通过<code>dexo g --draft</code>和<code>hexo s --draft</code>在本地预览.</li>
</ul>
<h5 id="page">page</h5>
<p>如果使用<code>hexo new page &lt;pagename&gt;</code>可以生成单独的页面,
通过<code>http://localhost:4000/pagename</code>来访问.
这个官网没有说得很明白这个是用来干嘛的, 我的理解是,
可以用来生成一些帮助组织博客站点的单独页面.
比如下面两个页面是NexT必须要生成的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>运行之后可以看到下面两个文件夹被生成,
并且添加一个只有头部的<code>index.md</code>文件.
然后在<code>source\categories\index.md</code>的头部里添加元素<code>type: categories</code>,
添加完之后文件变成这样.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-03 01:59:55</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>同理,
在<code>source\tags\index.md</code>里添加<code>type: tags</code>
效果就是下面两个高亮的可以点击了. <img src="/9cbcca7a//tags_and_cats.jpg" class title="tags and cats"></p>
<h3 id="安装next">安装NexT <span id="install-next"></span></h3>
<p>可以按照<a href="https://theme-next.js.org/docs/getting-started/installation.html">官方安装帮助</a></p>
<p>可以使用git或者npm安装, 用npm最方便.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>
<p>注意Next有4种不同的页面搭配(scheme), 你可以去<a href="https://theme-next.js.org/docs/theme-settings">官方readme</a>了解.
我选择了<code>Pisces</code>.
去配置文件<code>_config.next.yml</code>里修改一下即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure></p>
<h4 id="支持数学公式">支持数学公式 <span id="math"></span></h4>
<p>NexT是内置了支持数学公式的, 但这里几个坑.
hexo默认的markdown渲染器是<code>hexo-renderer-marked</code>,
但根据<code>NexT</code>的关于数学公式的<a href="https://theme-next.js.org/docs/third-party-services/math-equations.html">文档</a>.
里面提到如果在配置文件里激活对数学公式渲染的支持,
必需把这个默认的渲染器换掉. 如果你把公式渲染配置成<code>Mathjax</code>,
就必须用<code>hexo-renderer-pandoc</code>来作为markdown渲染器.
如果你用<code>Katex</code>,
就必须用<code>hexo-renderer-markdown-it</code>或者<code>hexo-renderer-markdown-it-plus</code>.</p>
<p>我的选择就是使用<code>Mathjax + hexo-renderer-pandoc</code>.
这里面还有个坑就是, 这个渲染器依赖pandoc这个软件, 必须先去<a href="https://github.com/jgm/pandoc/releases/tag/2.2.3.2">pandoc官网</a>下载安装一个pandoc.
下面是我安装的版本. <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pandoc --version</span><br><span class="line">pandoc 2.2.3.2</span><br><span class="line">Compiled with pandoc-types 1.17.5.1, texmath 0.11.0.1, skylighting 0.7.2</span><br><span class="line">Default user data directory: C:\Users\e323819\AppData\Roaming\pandoc</span><br><span class="line">Copyright (C) 2006-2018 John MacFarlane</span><br><span class="line">Web:  http://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.</span><br><span class="line">There is no warranty, not even <span class="keyword">for</span> merchantability or fitness</span><br><span class="line"><span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure></p>
<p>之后就可以通过下面的命令替换掉渲染器. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure></p>
<p>然后到<code>_config.next.yml</code>里修改打开对数学公式的支持.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Equations Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">engine:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p><code>per_page</code>这个变量如果是false,
渲染时每篇都会把<code>mathjax</code>加载到页面里, 如果是true,
那么只有页面头部包括了元素<code>mathjax: true</code>才会加载.</p>
<p>这样配置以后试试在你的博客里加入数学公式, 比如如下公式:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$\sum_&#123;i=0&#125;^n i^2 = \frac&#123;(n^2+n)(2n+1)&#125;&#123;6&#125;\tag&#123;displayed&#125;$$</span><br></pre></td></tr></table></figure> 会生成 <span class="math display">\[\sum_{i=0}^n i^2 =
\frac{(n^2+n)(2n+1)}{6}\tag{displayed}\]</span></p>
<h4 id="本地贴图">本地贴图 <span id="image"></span></h4>
<p>如果使用网络里的图床, 只需要用相应的markdown语法链接一下就行了.
但如果想要使用本地图片, 有这么几个解决方案.</p>
<ol type="1">
<li>把图片放在<code>source/img</code>下,
然后在用<code>markdown</code>语法<code>![img](/source/img/xxx.png)</code>的形式.
缺点是所有博客的图片会混在一起, 不好管理.</li>
<li>配置<code>_config.yml</code>中的变量<code>post_asset_folder: true</code>,
这时一代你通过<code>new</code>命令建立一个新博客文章,
就会自动生成一个同名文件夹用来放置资源文件.
然后使用hexo专用的语法<code>&#123;% asset_img slug [title] %&#125;</code>.
这么做的缺点是你的markdown文件将不能在别的地方被解析.</li>
<li>跟2一样配置<code>_config.yml</code>中的变量<code>post_asset_folder: true</code>.
然后用命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure> 安装一个插件.
然后使用一般的markdown语法即可以显示. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">{% asset_img "img.jpg" "img" %}</span><br></pre></td></tr></table></figure>
缺点就是要依赖于一个额外的插件. 我个人觉得一般来说写的博客不太可能迁移,
所以用hexo默认的方案2即可. 如果确实有迁移的需求就用3.</li>
</ol>
<h3 id="部署到github-pages">部署到github pages <span id="deploy"></span></h3>
<p>到现在为止, 我们可以在本地生成非常漂亮的静态页面. 可以使用markdown,
可以渲染数学公式, 可以使用图片.
我们需要在公网上找一个地方放置我们的这些静态页面. 这个选择非常多.
我选择了<a href="pages.github.com">github page</a>. 原因是使用简单,
几乎不需花时间维护, 国内公司都没有被墙掉, 可信程度高.</p>
<p>这里我们假设你已经有<code>github</code>的账户了.
如果没有需要创建一个, 具体创建过程在这里省略.
假设账户名是<code>xyz</code>.
那么你只需要创建一个名字叫做<code>xyz.github.io</code>的新项目,
就完成了github上的操作.</p>
<p>之后需要在<code>_config.yml</code>里的deploy下面加下面的配置,
注意type前面那个<code>-</code>最好加上,
因为如果deploy西面有多个deployer的话, 没有这个横岗会报错.
repo的值如果报错可以尝试把用户名和密码加上,
就像这样<code>https://xyz:pword@github.com/xyz/xyz.github.io.git</code>.
我在一台机器上碰到这个问题这么解决了,
但在别的机器上就不加也可以提示直接输入.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/retzzz/retzzz.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>然后在你blog的主目录下安装一个git deployer插件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>这之后只要使用下面任何一个命令, 都可以完成部署. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p>
<h2 id="进阶">进阶</h2>
<p>到这里一个初步的博客就搭建完成了, 我最开始提到的基础需求都得到满足.
但其实还有好多细节可以继续丰富,
我列出一些以后再有时间可以再写一篇进阶篇:</p>
<ol type="1">
<li>添加评论功能, 让用户可以对某一个文章进行评论.</li>
<li>文章访问计数.</li>
<li>各种社交网站的超链接.</li>
<li>为页面添加固定页眉页脚.</li>
<li>替换默认图标.</li>
<li>直接所见即所得的对markdown文档进行编辑.</li>
<li>博客内部文章的互相跳转.</li>
</ol>
<h2 id="总结">总结</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next@latest</span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line">npm install hexo-image-link --save</span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line">npm install hexo-generator-searchdb save</span><br><span class="line">npm install hexo-include-markdown --save</span><br></pre></td></tr></table></figure>
<p>请访问<a href="/338d5118/" title="通过hexo + NexT + github pages + 搭建个人博客(二) -- plugin-tags">通过hexo + NexT + github pages + 搭建个人博客(二) -- plugin-tags</a></p>
<h2 id="参考网页">参考网页:</h2>
<p><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/hexo-tutor-1.html">1</a>
<a href="https://www.techiediaries.com/jekyll-hugo-hexo">2</a> <a href="http://oakland.github.io/2016/05/02/hexo-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84post">3</a>
<a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE">4</a>
<a href="https://www.tuicool.com/articles/umEBVfI">5</a> <a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog">6</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>在带有数学公式的markdown文档里的交叉引用</title>
    <url>//55e045cb/</url>
    <content><![CDATA[<p>用Markdown对数学概念做笔记最有效的地方就是交叉引用.
一个数学概念或者定理往往是建立在一大堆其他数学概念的基础上.
而这些概念又是由其他更基础的概念定义.
可以说数学之美很大一部分是不管多复杂的概念都可以逆向追溯到特别基础的一大堆概念上.
犹如用简单的钢管和螺丝造出极其复杂的机器一样.</p>
<p>但这种特性导致数学学习如果不连贯, 新概念就几乎没法读懂.
因为任何一个更基础的信息忘记了都没法理解新读到的内容.
但交叉引用可以帮助自己快速找到前面的基础概念.
大大加速了我这种不连贯读书的速度.
这篇就是介绍一下我是如何实现交叉引用.</p>
<span id="more"></span>
<p>我的环境用的<a href="https://hexo.io/">hexo</a> + <a href="#https://www.mathjax.org/">mathjax</a> + <a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>.</p>
<p>交叉引用包括两个部分, 一个是为被引用的文本添加锚点(即跳转的目的地),
另一个是在引用的地方指定想要引用的锚点(即跳转的源位置,
显示为超链接).</p>
<h2 id="添加锚点">添加锚点</h2>
<h3 id="为标题的加锚点">为标题的加锚点 <span id="HeadingAnchor"></span></h3>
<p>在标题后面直接加<span class="math inline">\(\{\)</span>#Anchor<span class="math inline">\(\}\)</span>, 比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 标题1 &#123;#Anchor1&#125;</span><br></pre></td></tr></table></figure>
<blockquote><p>注意: 普通文本中直接连着输入<code>{</code>和<code>#</code>,
渲染器会报错, 除非花括号前面是方括号. 见后面一节为普通文本加锚点.</p>
</blockquote>
<p>上面的markdown脚本被渲染成html时, 锚点变为html节点的id:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;Anchor1&quot;</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>在最新版的hexo+pandoc这个方法已经不能直接用了, 参考<a href="#hexo5-0-error">hexo 5.0更新引起的渲染错误</a>.</p>
<p>但pandoc会为标题自动添加锚点, 锚点名字就是标题内容,
空格用横杠<code>-</code>代替. 如果想自定义锚点名, 可以参考<a href="#HTML-anchor">用HTML插入锚点</a></p>
</div>
<h3 id="为普通文本加锚点">为普通文本加锚点 <span id="TextAnchor"></span></h3>
<p>用方括号加上大括号的格式: <span class="math inline">\([\)</span>文本内容<span class="math inline">\(]\{\)</span>#Anchor2<span class="math inline">\(\}\)</span>. 比如下面一段话:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It&#x27;s called the [*universe*]&#123;#Universe&#125; or domain.</span><br></pre></td></tr></table></figure>
<p>实际渲染的html脚本如下.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It&#x27;s called the <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;Universe&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>universe<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> or domain.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里要注意, 非标题的普通文本里面如果前面没有方括号,
直接连着写<code>&#123;</code>和<code>#</code>,渲染器会报错.</p>
<div class="note warning"><p>在最新版的hexo这个方法已经不能直接用, 参考<a href="#hexo5-0-error">hexo 5.0更新引起的渲染错误</a>, 解决方案参考<a href="#HTML-anchor">用HTML插入锚点</a></p>
</div>
<h3 id="数学公式的符号加锚点">数学公式的符号加锚点</h3>
<p>数学公式中加锚点需要使用<a href="http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm#cssId"><code>\cssId #1 #2</code></a>,
例如下面的公式:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\cssId</span>&#123;Overlinev&#125;&#123;<span class="keyword">\overline</span>&#123;v&#125;&#125;:<span class="keyword">\overline</span>&#123;S&#125;<span class="keyword">\to</span><span class="keyword">\&#123;</span>F,T<span class="keyword">\&#125;</span><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>渲染成: <span class="math display">\[\cssId{Overlinev}{\overline{v}}:\overline{S}\to\{F,T\}\]</span></p>
<p>实际的html脚本如下 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mjx-container</span> <span class="attr">class</span>=<span class="string">&quot;MathJax CtxtMenu_Attached_0&quot;</span> <span class="attr">jax</span>=<span class="string">&quot;CHTML&quot;</span> <span class="attr">display</span>=<span class="string">&quot;true&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ctxtmenu_counter</span>=<span class="string">&quot;5&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 122.1%; position: relative;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-math</span> <span class="attr">display</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;MJX-TEX&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 0px; margin-right: 0px;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mover</span> <span class="attr">id</span>=<span class="string">&quot;Overlinev&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-over</span> <span class="attr">style</span>=<span class="string">&quot;padding-bottom: 0.2em; margin-bottom: -0.385em;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span> <span class="attr">size</span>=<span class="string">&quot;s&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-stretchy-h</span> <span class="attr">class</span>=<span class="string">&quot;mjx-cAF&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 0.686em;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-ext</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-ext</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-stretchy-h</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-over</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-base</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mi</span> <span class="attr">class</span>=<span class="string">&quot;mjx-i&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c1D463 TEX-I&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mi</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-base</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mover</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span> <span class="attr">space</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c3A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mover</span> <span class="attr">space</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-over</span> <span class="attr">style</span>=<span class="string">&quot;padding-bottom: 0.2em; padding-left: 0.024em; margin-bottom: -0.385em;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span> <span class="attr">size</span>=<span class="string">&quot;s&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-stretchy-h</span> <span class="attr">class</span>=<span class="string">&quot;mjx-cAF&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 0.912em;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-ext</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-ext</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-stretchy-h</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-over</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-base</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mi</span> <span class="attr">class</span>=<span class="string">&quot;mjx-i&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c1D446 TEX-I&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mi</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-base</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mover</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span> <span class="attr">space</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c2192&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span> <span class="attr">space</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c7B&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mi</span> <span class="attr">class</span>=<span class="string">&quot;mjx-i&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c1D439 TEX-I&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mi</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c2C&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mi</span> <span class="attr">class</span>=<span class="string">&quot;mjx-i&quot;</span> <span class="attr">space</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c1D447 TEX-I&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mi</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-mo</span> <span class="attr">class</span>=<span class="string">&quot;mjx-n&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-c</span> <span class="attr">class</span>=<span class="string">&quot;mjx-c7D&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-c</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-mo</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-math</span>&gt;</span><span class="tag">&lt;<span class="name">mjx-assistive-mml</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span> <span class="attr">unselectable</span>=<span class="string">&quot;on&quot;</span> <span class="attr">display</span>=<span class="string">&quot;block&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">math</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1998/Math/MathML&quot;</span> <span class="attr">display</span>=<span class="string">&quot;block&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mover</span> <span class="attr">id</span>=<span class="string">&quot;Overlinev&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>v<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span> <span class="attr">accent</span>=<span class="string">&quot;false&quot;</span>&gt;</span>¯<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;/<span class="name">mover</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span>&gt;</span>:<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;<span class="name">mover</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>S<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span> <span class="attr">accent</span>=<span class="string">&quot;false&quot;</span>&gt;</span>¯<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;/<span class="name">mover</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span> <span class="attr">accent</span>=<span class="string">&quot;false&quot;</span> <span class="attr">stretchy</span>=<span class="string">&quot;false&quot;</span>&gt;</span>→<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span> <span class="attr">fence</span>=<span class="string">&quot;false&quot;</span> <span class="attr">stretchy</span>=<span class="string">&quot;false&quot;</span>&gt;</span>&#123;<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>F<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span>&gt;</span>,<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>T<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mo</span> <span class="attr">fence</span>=<span class="string">&quot;false&quot;</span> <span class="attr">stretchy</span>=<span class="string">&quot;false&quot;</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">mo</span>&gt;</span><span class="tag">&lt;/<span class="name">math</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-assistive-mml</span>&gt;</span><span class="tag">&lt;/<span class="name">mjx-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
注意其中的<code>&lt;mjx-mover id="Overlinev"&gt;</code>.</p>
<h2 id="引用锚点">引用锚点</h2>
<h3 id="文本引用">文本引用</h3>
<p>使用标准的markdown超链接语法即可: <a href="url#Anchor">文本</a>.</p>
<p>注意如果引用同一文本中的锚点, 可以在括号中直接写(#Anchor),
比如下面的markdown:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">点击这里</span>](<span class="link">#Universe</span>), 会跳转到本页前面的一个锚点.</span><br></pre></td></tr></table></figure>
<p>被渲染成如下的超链接:</p>
<p><a href="#Universe">点击这里</a>, 会跳转到本页前面的一个锚点.</p>
<p>如果引用同一网站的其他网页的锚点, 可以用相对地址, 比如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">点击这里</span>](<span class="link">/9cbcca7a/#image</span>), 可以跳转到本博客的其他页的一个锚点.</span><br></pre></td></tr></table></figure>
<p>被渲染成如下的超链接:</p>
<p><a href="/9cbcca7a/#image">点击这里</a>,
可以跳转到本博客的其他页的一个锚点.</p>
<h3 id="公式中的引用">公式中的引用</h3>
<p>使用<a href="http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm#href"><code>\href&#123; &lt;url&gt; &#125; #1</code></a></p>
<p>这里有个陷阱, 如果url也想引用同一文本中的锚点,
不能直接在<code>&#123;</code>后面直接接<code>#</code>,
需要加一个空格.比如</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\href</span>&#123;<span class="link"> #Overlinev</span>&#125;&#123;<span class="keyword">\overline</span>&#123;v&#125;&#125;=F(x)</span><br></pre></td></tr></table></figure>
<p>将被渲染成: <span class="math display">\[
\href{ #Overlinev}{\overline{v}}=F(x)
\]</span></p>
<p>注意其中的<span class="math inline">\(\overline{v}\)</span>是可以点击跳转的.<span class="math inline">\(\dashv\)</span></p>
<h3 id="hexo-5.0-更新引起的渲染问题">hexo 5.0 更新引起的渲染问题<span id="hexo5-0-error"></span></h3>
<p>在把hexo更新成5.0+以后, 我在渲染过去的Post时, 遇到了下面的问题.</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Error: expected end of comment, got end of file</span><br><span class="line">      at Object._prettifyError (C:\Users\86186\lab\nodejs\blog_example\node_modules\nunjucks\src\lib.js:36:11)</span><br><span class="line">      at Template.render (C:\Users\86186\lab\nodejs\blog_example\node_modules\nunjucks\src\environment.js:538:21)</span><br><span class="line">      at Environment.renderString (C:\Users\86186\lab\nodejs\blog_example\node_modules\nunjucks\src\environment.js:380:17)</span><br><span class="line">      at C:\Users\86186\lab\nodejs\blog_example\node_modules\hexo\lib\extend\tag.js:236:16</span><br><span class="line">      at tryCatcher (C:\Users\86186\lab\nodejs\blog_example\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">      at Function.Promise.fromNode.Promise.fromCallback (C:\Users\86186\lab\nodejs\blog_example\node_modules\bluebird\js\release\promise.js:209:30)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>这个问题是由于nunjucks模板会把<code>&#123;# ... &#125;</code>当成模板注释来渲染,
根据这个官方回答 -- <a href="https://github.com/hexojs/hexo/issues/4658">issue4658</a></p>
<p>有几个个解决方案:</p>
<ol type="1">
<li>对于单页, 可以添加<a href="https://hexo.io/docs/front-matter">Front-matter</a>
<code>disableNunjucks: true</code></li>
<li>对于整个blog, 可以在基于<a href="https://github.com/hexojs/hexo-renderer-marked#options">hexo-renderer-marked的配置</a>,
在_config.yml里添加: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">marked:</span><br><span class="line">  disableNunjucks: false</span><br></pre></td></tr></table></figure></li>
<li>当然也可以修改代码<code>node_modules/hexo/lib/hexo/post.js</code>的390行:
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">disableNunjucks</span> === <span class="string">&#x27;boolean&#x27;</span>) disableNunjucks = data.<span class="property">disableNunjucks</span>;</span><br></pre></td></tr></table></figure> 改成: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">disableNunjucks = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="用html插入锚点">用HTML插入锚点<span id="HTML-anchor"></span></h4>
<p>Nunjucks被禁掉以后, 有个副作用, 就是Hexo提供的<a href="https://hexo.io/docs/tag-plugins">Tag Plugin</a>都无法使用了.
所以实在需要这些额外的标签, 可以用加一句HTML来打锚点.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span id=&quot;anchor_name&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
        <tag>Tex</tag>
        <tag>LaTex</tag>
        <tag>Markdown</tag>
        <tag>Cross Reference</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ compilers on Windows -- msvc vs gcc vs clang</title>
    <url>//c90ca996/</url>
    <content><![CDATA[<p>平时的工作大部分是在<a href="https://www.ddci.com/products_deos_do_178c_arinc_653">DEOS</a>上进行嵌入式软件的开发和测试.
对于在通用操作系统上的软件开发得时不时自己磨练一下.
这篇列出几个常见的在Windows可用的C++编译器的介绍, 以及如何安装使用.</p>
<span id="more"></span>
<p>写这篇的时候是2018年9月, 我刚在电脑上安装了这几个compiler的最新版本.
分别是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc --version</span><br><span class="line">gcc.exe (Rev1, Built by MSYS2 project) 8.2.0</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">C:\home&gt;clang --version</span><br><span class="line">clang version 6.0.1 (tags/RELEASE_601/final)</span><br><span class="line">Target: x86_64-pc-windows-msvc</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: C:\Program Files\LLVM\bin</span><br><span class="line"></span><br><span class="line">C:\home&gt;cl -?</span><br><span class="line">Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26729 for x64</span><br></pre></td></tr></table></figure>
<h2 id="vc">VC++</h2>
<p>毕竟是主场, 先介绍原生的微软编译器, Microsoft Visual C++, 简称msvc.
过去微软免费的Visual C++编译器都是通过Visual Studio Express版本安装的,
从2017版改了个名字叫 Visual Studio Community 2017.</p>
<p>VC的安装只需要到官网下载安装包, 然后按指引安装.
下面是我安装的选项和安装地址.</p>
<img src="/c90ca996//msvc_install.jpg" class>
<p>这里重点想说的是如何不通过IDE环境编译,
直接使用编译器链接器来进行编译. 跳过IDE,
有利于学习中了解编译器的细节.</p>
<p>安装完官方的安装包之后,
可以直接点开开始菜单里下面这几个快捷方式来直接打开相应的命令行下编译环境.</p>
<img src="/c90ca996//msvc_cmd_env.jpg" class>
<p>仔细研究一下这几个快捷方式,
发现他们都是调用一个windows的批处理文件<code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat</code>,
只是参数不同.</p>
<p>在进入这个批处理, 发现其背后有一大堆批处理文件帮助设置环境变量.
其中核心的批处理是<code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\Tools\VsDevCmd.bat</code>.
可以通过看这个文件的帮助信息来了解都有哪几种类型的环境.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ &quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\Tools\VsDevCmd.bat&quot; -help</span><br><span class="line">.</span><br><span class="line">** Visual Studio &quot;15&quot; Developer Command Prompt Help **</span><br><span class="line">** Version : 15.8.4</span><br><span class="line">.</span><br><span class="line">Syntax: vsdevcmd.bat [options]</span><br><span class="line">[options] :</span><br><span class="line">    -arch=architecture : Architecture for compiled binaries/libraries</span><br><span class="line">           ** x86 [default]</span><br><span class="line">           ** amd64</span><br><span class="line">           ** arm</span><br><span class="line">           ** arm64</span><br><span class="line">    -host_arch=architecture : Architecture of compiler binaries</span><br><span class="line">           ** x86 [default]</span><br><span class="line">           ** amd64</span><br><span class="line">    -winsdk=version : Version of Windows SDK to select.</span><br><span class="line">           ** 10.0.xxyyzz.0 : Windows 10 SDK (e.g 10.0.10240.0)</span><br><span class="line">                              [default : Latest Windows 10 SDK]</span><br><span class="line">           ** 8.1 : Windows 8.1 SDK</span><br><span class="line">           ** none : Do not setup Windows SDK variables.</span><br><span class="line">                     For use with build systems that prefer to</span><br><span class="line">                     determine Windows SDK version independently.</span><br><span class="line">    -app_platform=platform : Application Platform Target Type.</span><br><span class="line">           ** Desktop : Classic Win32 Apps          [default]</span><br><span class="line">           ** UWP : Universal Windows Platform Apps</span><br><span class="line">    -no_ext : Only scripts from [VS150COMNTOOLS]\VsDevCmd\Core</span><br><span class="line">              directory are run during initialization.</span><br><span class="line">    -no_logo : Suppress printing of the developer command prompt banner.</span><br><span class="line">    -vcvars_ver=version : Version of VC++ Toolset to select</span><br><span class="line">           ** [Default]   : If -vcvars_ver=version is NOT specified, the toolset specified by</span><br><span class="line">                            [VSInstallDir]\VC\Auxiliary\Build\Microsoft.VCToolsVersion.default.txt will be used.</span><br><span class="line">           ** 14.0        : VS 2015 (v140) VC++ Toolset (installation of the v140 toolset is a prerequisite)</span><br><span class="line">           ** 14.1x       : VS 2017 (v141) VC++ Toolset, if that version is installed on the system under</span><br><span class="line">                            [VSInstallDir]\VC\MSVC\Tools\[version].  Where &#x27;14.1x&#x27; specifies a partial</span><br><span class="line">                            [version]. The latest [version] directory that matches the specified value will</span><br><span class="line">                            be used.</span><br><span class="line">           ** 14.1x.yyyyy : VS 2017 (v141) VC++ Toolset, if that version is installed on the system under</span><br><span class="line">                            [VSInstallDir]\VC\MSVC\Tools\[version]. Where &#x27;14.1x.yyyyy&#x27; specifies an</span><br><span class="line">                            exact [version] directory to be used.</span><br><span class="line">    -vcvars_spectre_libs=mode : version of libraries to use.</span><br><span class="line">           ** [Default]   : If -vcvars_spectre_libs=libraries is NOT specified, the project will use the normal</span><br><span class="line">                            libraries.</span><br><span class="line">           ** spectre     : The project will use libraries compiled with spectre mitigations.</span><br><span class="line">    -startdir=mode : configures the current directory after (successful) initialization of the environment.</span><br><span class="line">           ** none : the command prompt will exist in the same current directory as when invoked</span><br><span class="line">           ** auto : the command prompt will search for [USERPROFILE]\Source and will change directory</span><br><span class="line">                     if it exists.</span><br><span class="line">           ** If -startdir=mode is not provided, the developer command prompt scripts will</span><br><span class="line">              additionally check for the [VSCMD_START_DIR] environment variable. If not specified,</span><br><span class="line">              the default behavior will be &#x27;none&#x27; mode.</span><br><span class="line">    -test : Run smoke tests to verify environment integrity in an already-initialized command prompt.</span><br><span class="line">            Executing with -test will NOT modify the environment, so it must be used in a separate call</span><br><span class="line">            to vsdevcmd.bat (all other parameters should be the same as when the environment was</span><br><span class="line">            initialied)</span><br><span class="line">    -help : prints this help message.</span><br></pre></td></tr></table></figure>
<p>注意-arch和-host_arch的含义,
host_arch是指我们编译器本身是被编译为32位x86的指令还是64位amd64的指令.
-arch是说编译器工作的对象是要把源码编译为那种架构,
从帮助里可以看出msvc可以支持4种, 32位和64位Intel,
32位和62位的ARM处理器.</p>
<p>为了方便理解, 这里打个比方. 如果把应用程序比喻成"智能机器人".
计算机世界就是这种机器人生活的世界,
编译器也可以理解为一种特殊的智能机器人, 它的工作就是生产其他各种机器人,
可以理解为一条生产线机器人. 计算机世界中每一个机器人,
只会说一种语言(CPU架构, 系统调用, 以及其他依赖库),
所以他们可以在某个说这种语言的国家(CPU+操作系统)工作.</p>
<p>比如说一条msvc生产线生产的机器人都只能说x86&amp;windows语,
那么这些被生产出来的应用程序就只能在x86&amp;windows上工作.
但生产线调整一下,
也可以用基于msvc的另一条生产线生产出能说AMD64&amp;linux语的机器人.
当然由于msvc这条生产线作为智能机器人本身只能说都用x86&amp;windows语,
所以这条生产线只能建在x86&amp;windows这个国家.
通常我们把编译器所在的CPU和操作系统叫做host,
把做出来其他程序必须工作的CPU和操作系统叫做Target.
如果这两个一样就叫做本地编译(native compile),
如果不一样就叫做交叉编译(cross compile).</p>
<p>所以根据前面的批处理帮助,
我们可以知道我安装的当前版本的msvc支持8条生产线.
如果安装时选了linux支持, 则估计生产线要再乘以2了.</p>
<table>
<thead>
<tr class="header">
<th>host</th>
<th>target</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x86 &amp; windows</td>
<td>x86 &amp; windows</td>
</tr>
<tr class="even">
<td>x86 &amp; windows</td>
<td>AMD64 &amp; windows</td>
</tr>
<tr class="odd">
<td>x86 &amp; windows</td>
<td>ARM &amp; windows</td>
</tr>
<tr class="even">
<td>x86 &amp; windows</td>
<td>ARM64 &amp; windows</td>
</tr>
<tr class="odd">
<td>AMD64 &amp; windows</td>
<td>x86 &amp; windows</td>
</tr>
<tr class="even">
<td>AMD64 &amp; windows</td>
<td>AMD64 &amp; windows</td>
</tr>
<tr class="odd">
<td>AMD64 &amp; windows</td>
<td>ARM &amp; windows</td>
</tr>
<tr class="even">
<td>AMD64 &amp; windows</td>
<td>ARM64 &amp; windows</td>
</tr>
</tbody>
</table>
<blockquote>
<p>顺便说一句, windows的批处理的语法跟POSIX(比如linux)的shell比, 弱爆了.
以前一直不喜欢使用, 但如果仔细读msvc的这一套批处理文件,
发现高手依然可以用其写出优雅的代码.
在windows下批处理胜在不需要额外安装别的支持(比如cygwin或者msys),
所以执行的启动速度也还比较快. 所以如果编译开发环境都是windows的话,
以后可以考虑改用windows的批处理解决小问题.</p>
</blockquote>
<h2 id="gcc">GCC</h2>
<p>GCC是the GNU Compiler Collection的缩写, 是最流行的开源编译器,
不止支持C++, 还支持几乎所有编译型语言.</p>
<p>GCC原生于类unix系统(包括linux, 后面直接用linux代表所有类unix系统),
在windows上使用gcc通常有两个途径, cygwin或者MinGW.
这里说说他们的区别.</p>
<h3 id="cygwin">cygwin</h3>
<p>cygwin是想要在windows上实现完整的POSIX接口,
使任何一个在linux上课执行的程序,
拿到windows只要基于cygwin重新编译一下就可以运行.</p>
<p>如果利用刚才的类比, cygwin中的gcc相当于给gcc配置了一个翻译机器人,
这样gcc每说出一个linux语, cgwin翻译机器人立马给翻译成windows语,
这样就可以在windows国进行生产了,
而且只要用这个生产线生产出来的程序也都需要配一个cygwin翻译.
这样就能保证所有的linux上的机器人可以原样设计不动,
在windows上生产一个一模一样的.</p>
<p>这个翻译机器人就是cygwin1.dll. 所以运行通过cygwin
gcc编译出来的程序时, 一定要让正确版本的cygwin1.dll所在目录在系统PATH里.
从这里也可以看到, cygwin gcc不追求效率, 运行程序要比linux原生程序慢,
也比同样功能的windows原生程序慢.</p>
<p>cygwin安装按照官方指导来就行了.</p>
<h3 id="mingw">MinGW</h3>
<p>MinGW是Minimalist GNU for Windows的缩写, 通常读成"min gee
double-you". MinGW是改造了GCC这个编译器以及其配套工具,
让其能够生产windows应用.</p>
<p>在那个类比里, 相当于把linux国的GCC生产线改造了一下,
让它本身说windows语, 这样就可以在windows上生产机器人,
并且生产出来的别的机器人也都说windows语了.</p>
<p>这样熟悉linux上gcc的用户就可以直接到windows上使用gcc了.
但是熟悉gcc的人一般也很难适应windows的shell环境,
所以又有人给MinGW提供了一个shell外壳, 叫msys, 这样常见的linux
shell命令也可以在windows上执行.</p>
<p>刚才提到的这两个都有一个更新的可替代软件一个叫<a href="http://mingw-w64.org/doku.php">MingGW-w64</a>, 一个叫<a href="www.msys2.org">msys2</a>. 可以直接按照官方教程先安装msys2,
然后再利用pacman程序安装MinGW-w64.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -S --needed mingw-w64-x86_64-toolchain</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -S --needed mingw-w64-i686-toolchain</span><br></pre></td></tr></table></figure>
<p>抄两句别人的话就是:</p>
<blockquote>
<p>Cygwin = Lets put unix on windows, use as much native unix stuff as
possible <br> MinGW = Lets keep unix out of windows as much as
possible, us as much native windows stuff as possible.</p>
</blockquote>
<h2 id="clang">clang</h2>
<p>Clang读成"klang", 是基于LLVM的C家族语言编译器,
LLVM是一个跟GCC差不多的开源编译框架.
LLVM的产生是跟GCC暴露出来的问题紧密相关的. 比如GCC模块化做的不好,
无法给IDE提供足够的中间接口. 比如GCC的报错提示有时候完全不知所云.
比如gcc在windows上的效率很低. 还比如GCC是基于GPL协议.
对于GCC的这些缺点可以阅读<a href="http://www.aosabook.org/en/llvm.html">这篇文章</a>来详细了解.
LLVM就是针对所有GCC的这些痛点对编译框架进行了重新设计,
所以按道理来讲应该更先进. 现在苹果是LLVM的主要赞助人.
但是在windows和linux世界由于路径依赖,
Clang使用率应该是没有前面两个高.</p>
<p>网上有大量的文章对gcc vs clang vs msvc进行对比, 从比较编译效率,
到编译出来的程序的优化度, 到比较报错输出都有.</p>
<p>比如这篇<a href="https://easyaspi314.github.io/gcc-vs-clang.html">Clang vs GCC vs
MSVC: Diagnostics</a>, 比较报错信息. 还有这篇<a href="https://developercommunity.visualstudio.com/content/problem/194955/vs-produces-code-that-is-15-2x-slower-than-gcc-and.html">VS
produces code that is 1.5-2x slower than gcc and
clang</a>声称msvc编译时间比另外两个长. 比如<a href="https://www.phoronix.com/scan.php?page=article&amp;item=gcc-clang-eoy2017&amp;num=1">这篇</a>比较clang和gcc的编译后的执行效率.
<a href="https://codeday.me/bug/20170407/8526.html">这篇</a>是中文的.</p>
<p>clang的安装完全按照官网来就可以了. 没什么坑好说的.</p>
<h2 id="todo">ToDo</h2>
<p>下面这几个以后有时间都值得做一下. 1. 搞一个makefile,
可以对一个源代码同时使用三种编译器编译, 方便研究. 2.
对不太熟悉的msvc和clang, 研究一下编译链接选项. 3.
是否可以使用clang编译出可以在DEOS运行的程序. 4.
搞清楚LLVM是否可以跟VIM合作, 使VIM对C++代码的语义定位更加准确.</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>Cygwin</tag>
        <tag>MinGW</tag>
        <tag>VC</tag>
        <tag>clang</tag>
        <tag>gcc</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>汇率基本概念的学习</title>
    <url>//8c589a05/</url>
    <content><![CDATA[<p>以下是我在薛兆丰的经济学课上学习汇率之后, 对汇率的理解.</p>
<h2 id="决定汇率的三个因素">决定汇率的三个因素</h2>
<ol type="1">
<li>国际资源供求关系.</li>
</ol>
<p>汇率是由甲国人民对乙国资源的需求，以及乙国人民对甲国资源的需求共同决定的。如果一国人民对另一国资源完全没有需求，那么两国就不存在汇率；如果甲国人民对乙国资源的需求增加，在其他条件不变的情况下，甲国的货币就会相对乙国货币贬值。</p>
<span id="more"></span>
<p>用一个思想实验, 举一个简化的例子. 假设世界上有两个国家,
兔子国和老鹰国. 老鹰国能生产发动机, 兔子国不能.
如果兔子国有人想买老鹰国的发动机, 就得想办法换老鹰国的老鹰币.
但如果老鹰国没有任何人需要兔子国的产品, 没有人想要兔子币,
老鹰国发动机进口商就永远换不到老鹰币. 于是两国货币根本没有任何兑换,
也没有汇率.</p>
<p>如果老鹰国有个商人发现兔子国生产的袜子比老鹰国自己生产的质优价廉,
进口有得赚, 就想买兔子国的袜子. 一台发动机在老鹰国卖一万老鹰币,
一双袜子在兔子国卖十元兔子币.
兔子国想买发动机的人想换一万老鹰币买一台发动机,
而老鹰国袜子进口商人想换十万兔子币买一万双袜子. 老鹰国袜子进口商一算,
袜子在老鹰国一双市场价5老鹰币, 一万双市场价5万老鹰币,
如果自己能用一万老鹰币买到即便减去其他成本也是大赚.
而兔子国自己无法生产发动机, 出十万兔子币买发动机也很很不错.
双方一拍即合直接交换,
老鹰国袜子进口商用一万老鹰币换了兔子国发动机进口商的十万兔子币,
买了兔子国一万双袜子. 兔子国发动机进口商用十万兔子币换了一万老鹰币,
买了一台老鹰国的发动机. 假设没有别的交易,
老鹰币兑换兔子币汇率就是1:10.</p>
<p>如果老鹰国有人发现兔子国生产的口罩也不错, 也想换兔子币买口罩.
但是兔子国没人需要其他老鹰国的产品了.
市场上还是只有兔子国买发动机的人需要一万老鹰币.
于是老鹰国想买口罩的人和想买袜子的人都想用一万老鹰币尽可能多的换到兔子币.
这就产生了竞争, 想买口罩的人为了换取兔子币,
愿意用一万老鹰币换九万兔子币, 而不是想买袜子的人原来要求的十万.
汇率变为了1:9. 这就是由于老鹰国对兔子国资源的需求相对增加,
导致老鹰币对兔子币的货币贬值, 或者反过来说兔子币对老鹰币升值了.</p>
<ol start="2" type="1">
<li>货币发行量.</li>
</ol>
<p>这个明显, 超发货币会导致货币相对货物贬值. 如果其他条件不变,
相对其他国家货币也就会贬值.</p>
<p>还是用上面的例子老鹰国袜子进口商想买一万双袜子,
兔子国发动机进口商想买一台发动机.
兔子国由于超发了货币导致袜子涨价到20元每双.
而这样老鹰国想买袜子的人需要二十万兔子币,
而兔子国发动机买家依然只需要一万老鹰币. 如果市场上没有别的货币兑换玩家,
兔子国没办法只好接受用二十万兔子币换一万老鹰币,
那么老鹰币对兔子币就会变为1:20. 兔子币贬值了一倍.</p>
<ol start="3" type="1">
<li>外汇管制.</li>
</ol>
<p>政府通过行政手段, 强制规定汇率就是外汇管制.
问题是这个规定的汇率跟市场上自然形成的汇率有可能不一致,
如果不一致的话会发生什么?</p>
<p>接着用上面的例子, 老鹰国袜子进口商想买一万双袜子, 价值10万兔子币.
兔子国发动机进口商想买一台老鹰国发动机, 价值一万老鹰币.
但是兔子国规定他们的如果老鹰国人想交换兔子币,
必须以老鹰币对兔子币1:5来交换,
就是强制让兔子币比市场上自然形成的1:10升值了一倍. 这就使老鹰国袜子商,
如果想换10万兔子币的话需要用两万老鹰币来换, 导致他的利润下滑,
虽然还是有得赚. 而兔子国的发动机进口商可以换到两万老鹰币买两台发动机.
可见如果通过行政手段强制自己的货币升值,
会伤害出口(老鹰国袜子进口商如果利润太低可能就不做这个生意了,
在真实世界出口将会减少), 但会有利于进口(同样花费10万兔子币,
可以买两台老鹰国的发动机.).</p>
<p>如果政府规定老鹰币对兔子币必须以1:20交换,
强制让兔子币比自然汇率贬值一倍.
兔子国发动机进口商需要花20万兔子币换取老鹰国袜子进口商的一万老鹰币.
可见强制让本国货币贬值有利于出口(老鹰国袜子进口商进口价格便宜一倍,
用一万老鹰币买了两万双袜子),
但会伤害进口(花了20万兔子币才能买到一台发动机).</p>
<p>假设政府强制规定汇率1:5, 也就是强制让本国货币升值,
而且升值到自然汇率的一倍.
但是如果有个人跑过来跟老鹰国袜子进口商说你给我一万五老鹰币我给你10万兔子币,
回过头来又跟兔子国发动机进口商说12万兔子币给你换一万老鹰币,
兔子国发动机进口商发现市场上的老鹰币卖家变少只有这个人可以达成交易,
这就是外汇黑市. 可以看到外汇黑市只有在政府管制汇率时才会出现,
而且黑市的汇率在两头都会更接近自然汇率.
会让由于政府规定而损失的一方损失减少, 受益的一方受益也减少.
中间的差额被黑市商人赚走了.
政府对黑市的打击力度决定了强制汇率到底在多大程度上能实现, 打击力度越大,
黑市商人成本变高, 黑市汇率也越接近强制汇率, 打击力度越小,
黑市汇率越接近自然汇率.</p>
<h2 id="不可能三角定律">不可能三角定律</h2>
<p>不可能三角定律: 外汇自由流动, 稳定的汇率和货币发行量的自主权,
任何政府职能任意选择两个, 不可能三者兼有.</p>
<ol type="1">
<li>放弃发钞权</li>
</ol>
<p>如果政府选择稳定的汇率和外汇自由流动, 对于外贸行业来说,
这两个条件将导致他们稳定的预期.
即外贸商人可以在任何时间以一个稳定的汇率兑换到任何货币.
那么他做生意的成败就不受制于货币兑换了. 但同时政府放弃了发钞权,
本国货币只不过是外国货币的代币.</p>
<p>比如说兔子国强制规定老鹰币对兔子币的汇率是1:10, 然后允许市场自由兑换,
如果换不到可以到政府这里换. 这时候如果两国对对方货物的需求改变,
老鹰国的货币通胀或者通缩, 都会导致自然汇率变化. 而兔子国允许自由兑换,
如果想要维持稳定的汇率, 就只能通过控制本国货币发行量来稳定汇率.
比如假设老鹰国突然增发货币, 使本国货币贬值一倍,
发动机价格由原来的1万老鹰币变成2万老鹰币.
兔子国发动机进口商在市场上寻求2万老鹰币.
这时候市场的自然汇率已经变为1:5. 如果兔子国依然想要保持稳定的1:10的汇率,
就只能也发行货币, 让兔子币也贬值一倍.
否则市场上的自由兑换将会让汇率变为1:5.</p>
<p>这种政策对于小国或者小地区有可能可行,
因为他们相信大国在发行货币时更谨慎.</p>
<ol start="2" type="1">
<li>放弃稳定汇率</li>
</ol>
<p>如果政府选择自己控制发钞权, 又允许市场上自由兑换货币.
那么汇率将会是自然汇率, 是由市场上的每一笔交易决定的. 跟股票市场一样,
汇率会实时变化. 外贸商人在做生意的时候, 如果错误的估计汇率就会导致损失,
比如兔子国进口发动机签合同时汇率是1:10, 所以预计自己的成本是10万兔子币.
但结算时汇率变为1:20, 成本翻倍.</p>
<ol start="3" type="1">
<li>不允许自由兑换货币</li>
</ol>
<p>如果既想要自主发行货币, 又想要一个比较稳定的汇率,
那就一定不能允许市场自由兑换货币. 政府需要用暴力控制外汇兑换,
任何不按照政府规定的汇率兑换货币的行为(货币黑市)将会受到政府的打击.
规定的汇率跟自然汇率的差距越大, 黑市的利润越高,
政府的控制成本也将变高.</p>
<p>那么进一步问, 为什么政府会选择上面的一个政策而放弃另外两个呢?
中国的汇率政策历史上是怎样的, 当前又是怎样的?
什么原因让中国有这样的政策. 这个粗略看了一下, 感觉比较复杂.
有时间的时候, 再仔细研究.</p>
]]></content>
      <categories>
        <category>经济学</category>
        <category>汇率</category>
      </categories>
      <tags>
        <tag>exchange-rate</tag>
      </tags>
  </entry>
  <entry>
    <title>给孩子准备的离家礼物(一)</title>
    <url>//397f5023/</url>
    <content><![CDATA[<p>这里记录一些听到或看到的我认同的别人的观点. 好记性不如烂笔头,
自己说不明白就记录一些别人说的金句. 将来孩子长大了, 要离家了,
如果我的观点还没变, 拿给孩子看看. 虽然不一定有用<span class="math inline">\(\unicode{x1F602}\)</span>,
毕竟年轻人很少听老人言.</p>
<span id="more"></span>
<h2 id="关于高考-职业">关于高考, 职业</h2>
<p>以下观点主要来自微博"组织二号头目", 某些点有我自己的修正.</p>
<ol type="1">
<li><p>除了专业性极强的几个专业(比如医生, 律师),
绝大多数人在毕业5年内就开始折腾跟大学专业无关的事情.</p></li>
<li><p>普通人能去大城市就去大城市. 小地方的本质是前现代社会,
人情社会.</p></li>
<li><p>一般来讲, 高考先选学校再选专业.
毕业两年后基本没人关心你是哪个专业的了.
毕业5年后的简历是由毕业学校和之前的工作经历共同组成的.</p></li>
<li><p>大学教给你的知识有限, 最重要的是能帮助人保持自学能力,
大学里是培养自我学习能力的关键阶段.</p></li>
<li><p>头部效应很大的行业: 金融, 直播, 明星. 金字塔形的行业:
码农.</p></li>
<li><p>智力密集型, 门槛比较高的工作, 长期看不会贬值.</p></li>
<li><p>我国是政府通过压迫医生行业来给老百姓发福利.
有一定可能性将来会变好.</p></li>
<li><p>技术类工作者的优势:</p>
<ul>
<li>技术有相通性, 学了一个也就不惧怕学其他的.</li>
<li>有效治疗"怀才不遇"的错觉. 能够了解建设的难度.
不太容易成为只知道批评社会的神经病.</li>
<li>容易找工作, 骑驴找马.</li>
</ul></li>
</ol>
<h2 id="关于技能成长">关于技能成长</h2>
<ol type="1">
<li>关于奖励:
<ul>
<li>绝大多数人不响应长期激励.</li>
<li>奖励要及时并且可度量的.</li>
<li>最有效的激励叫做随机奖励. 自我奖励</li>
</ul></li>
<li>关于练习:
<ul>
<li>在挑战区的练习效果最好.</li>
<li>太简单的驴拉磨效率低.</li>
<li>最求太复杂太难的会伤害积极性.</li>
<li>好的思路是越来越难.</li>
<li>准确识别出怎样的路径是持续挑战是关键. 把基础打牢靠</li>
</ul></li>
<li>关于复杂工具:
<ul>
<li>尝试不断使用复杂工具</li>
<li>尝试用工具的思维来解决问题</li>
<li>人工智能也是工具</li>
</ul></li>
<li>关于时间:
<ul>
<li>最重要的是不断投入时间.</li>
<li>你花时间达成的目标别人也要花相同时间才能达成的事情有价值投入更多时间.</li>
</ul></li>
<li>关于坚持:
<ul>
<li>定低日常目标</li>
<li>最重要的是开始做, 只要开始了往往会大大超出目标.</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>reading notes</tag>
      </tags>
  </entry>
  <entry>
    <title>用rpm和dnf管理linux下的软件安装</title>
    <url>//980eef66/</url>
    <content><![CDATA[<p>linux下的软件安装对用户不太友好. 每次需要用的时候, 记不住命令,
都是现去搜索.
最近对Fedora-CentOS-RedHat系的软件包管理系统进行了稍微深入的学习了解.
这篇是自己的学习笔记. 目的是以后再需要使用的时候,
只需要读这一篇即可.</p>
<span id="more"></span>
<p>先明确一些概念:</p>
<ul>
<li>File: 文件. 操作系统对存储数据的一个抽象.</li>
<li>Package: 软件包或简称包, 一些文件组成的集合.</li>
<li>Group: 包组, 一些包组成的集合.</li>
<li>Repository: 资源库, 存放大量互相兼容的包的空间.
跟library的翻译要区分开.
也要跟git等配置管理软件里的repository区分开.</li>
</ul>
<h2 id="起因">起因</h2>
<p>大部分Windows上的软件在安装的时候一般只会在<code>C:\Program Files</code>或用户指定的目录创建一个自己的目录.
互相不会影响. 每个软件通常也自己负责安装自己的所有依赖的第三方软件.
有时候两个软件都依赖于同一个库,
却各自安装自己的一个拷贝(不是所有软件都这么做).
而且被安装的软件自身就会提供一个反安装程序,
能够清除自己安装上的所有文件. (这里得排除恶意流氓软件和系统软件.)
这跟windows生来就是面向桌面用户有关, 打开程序通过点击图标即可.
大部分windows用户并不关心软件到底跟那些文件有关.</p>
<p>Linux上的软件通常把跟自己相关的文件分散的安装到系统的不同路径,
而且不会把依赖的第三方软件打包在自己的安装包里. 之所以这么安排,
有一定的历史原因. Linux的用户大部分是专业人士, 对这种不方便也不敏感.</p>
<p>当然Linux也提供了对软件安装进行管理的办法, 那就是包管理软件(package
manager). 现在这种软件形成了两个流派, 一个是<a href="https://www.debian.org/">Debian</a>-<a href="https://ubuntu.com/">Ubuntu</a>派使用的<a href="https://wiki.debian.org/Teams/Dpkg">dpkg</a>+<a href="https://manpages.debian.org/bullseye/apt/apt.8.en.html">apt</a>,
一个是<a href="https://getfedora.org/">Fedora</a>-<a href="https://www.centos.org/">CentOS</a>-<a href="https://www.redhat.com/en">RedHat</a>派使用的<a href="https://rpm.org/">rpm</a>+<a href="http://yum.baseurl.org/">yum</a>或<a href="https://rpm.org/">rpm</a>+<a href="https://rpm-software-management.github.io/">dnf</a></p>
<p>这篇文章主要记录的是rpm+dnf这种流派的各个方面.</p>
<h2 id="要解决的问题">要解决的问题</h2>
<p>包管理软件应该提供的一些功能包括如下几条.</p>
<p>如果已经拥有了软件包, 用户需要</p>
<ol type="1">
<li>安装/升级/反安装 <a href="#基本操作">-&gt;</a></li>
<li>查询一个包都有哪些文件, 安装后都放在哪. <a href="#列文件">-&gt;</a></li>
<li>安装了之后, 如果有一个文件, 也应该能查询到这个文件属于哪个包. <a href="#文件找包">-&gt;</a></li>
<li>查看这个包依赖的其他包有那些, 是否被安装. <a href="#依赖">-&gt;</a></li>
<li>查看依赖于已经安装的这个包被哪些包依赖. <a href="#被依赖">-&gt;</a></li>
</ol>
<p>如果没有软件包, 用户需要:</p>
<ol type="1">
<li>如果知道软件名称, 或有个关键字, 可以在指定的资源库中查询是否有该包.
<a href="#关键字找包">-&gt;</a></li>
<li>如果知道某一个文件名, 可以在指定的资源库中查询是否有包包含该文件. <a href="#文件找包">-&gt;</a></li>
<li>可以自动下载安装某个包以及其依赖的其他包. <a href="#一键安装">-&gt;</a></li>
<li>可以单独下载该包, 不下载它依赖的其他包. <a href="#下载">-&gt;</a></li>
</ol>
<p>如果用户自己能够从源代码构建可执行文件, 用户需要:</p>
<ol type="1">
<li>做一个自己的软件包. <a href="#做包">-&gt;</a></li>
<li>建立一个自己的资源库. <a href="#做库">-&gt;</a></li>
<li>使自己的包满足别的软件的依赖. <a href="#建立依赖">-&gt;</a></li>
</ol>
<h2 id="rpm与dnf的关系">rpm与dnf的关系</h2>
<p>rpm原来是RedHat Package Manager的缩写, 后来模仿GNU改成递归式的名字RPM
Package Manager.</p>
<p>rpm可以对一个独立的软件包进行安装, 反安装, 查询, 和验证.
rpm软件包里包括当前软件的所有文件和一些叫做元数据(metadata)的信息.
元数据包括helper script, file attributes, 以及其他信息.
rpm能够告诉用户当前包依赖哪些其他的软件包.
但不能帮助用户解决这些依赖关系.</p>
<p>rpm会维护一个已安装包的数据库. 以便于用户快速查询,
这个数据库存储在<code>/var/lib/rpm</code>下,
文件以<code>__db</code>开头.</p>
<p>dnf是基于rpm开发的更高一层的包管理软件. 除了rpm能够实现的功能外,
它把软件包组织成资源库, 可以帮用户查询资源库中未安装的软件包信息,
从指定资源库获取软件包. 自动处理依赖关系以安装或卸载软件包,
以及更新系统到资源库中最新可用版本.</p>
<h2 id="rpm文件命名规范">rpm文件命名规范</h2>
<p>rpm文件名遵循<code>NAME-VERSION-RELEASE</code>规范命名,
例如<code>python-2.7.5-34.el7.x86_64.rpm</code>,
包名是<code>python</code>, 版本是<code>2.7.5</code>,
<code>34.el7.x86_64</code>中34代表当前这个版本的发布次数,
<code>el7</code>代表linux的发行版本(distribution),
<code>x86_64</code>代表cpu架构(architecture).
下面的命令可以帮助查询distribution:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --eval %&#123;?dist&#125;</span><br></pre></td></tr></table></figure>
<p>cpu架构是由构建可执行文件的环境决定,
如果软件是跨平台的(architecture-independent)可以是<code>noarch</code>
查询当前电脑的cpu架构可以用如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --eval %&#123;_arch&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于软件包的基本操作">关于软件包的基本操作</h2>
<p>下表列出了用户常用的rpm和dnf的基本操作<span id="基本操作"></span></p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 42%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">用户需求</th>
<th style="text-align: left;">rpm操作</th>
<th style="text-align: left;">dnf操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">安装</td>
<td style="text-align: left;">简单安装<br><code>rpm -i package.rpm</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></td>
<td style="text-align: left;">安装一个软件包及其所有未安装的依赖包<br><code>dnf install package</code><span id="一键安装"></span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">输出更多信息以及进度条<br><code>rpm -ivh package.rpm</code><br><code>-v, --verbose</code>,
<code>-h, --hash</code></td>
<td style="text-align: left;">同时安装多个软件包<br><code>dnf install package1 package2 ...</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">输出更多信息以及百分比<br><code>rpm -iv --percent package.rpm</code></td>
<td style="text-align: left;">仅下载不安装<br><code>dnf download package</code><span id="下载"></span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">同时下载所有未安装的依赖包<br><code>dnf download --resolve package</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">更新</td>
<td style="text-align: left;">删除旧版本之后安装新版本<br><code>rpm -Uvh new-package.rpm</code></td>
<td style="text-align: left;">更新单个包<br><code>dnf update package</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">更新成更旧的版本<br><code>rpm -Uvh --oldpackage old-version.rpm</code></td>
<td style="text-align: left;">检查需要更新的包<br><code>dnf check-update</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">如果没有旧版本则不安装(Freshen)<br><code>rpm -Fvh new-package.rpm</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">批处理更新(Freshen)<br><code>rpm -Fvh /fedora/updates/*.rpm</code></td>
<td style="text-align: left;">更新所有包及其依赖<br><code>dnf update</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">删除</td>
<td style="text-align: left;">简单删除<br><code>rpm -e package</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></td>
<td style="text-align: left;">删除包及其所有依赖的包<br><code>dnf remove package ...</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">查询</td>
<td style="text-align: left;">简单查询<br><code>rpm -q package</code></td>
<td style="text-align: left;">搜索包<br><code>dnf search package</code><span id="关键字找包"></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">列出所有安装的包<br><code>rpm -qa</code></td>
<td style="text-align: left;"><code>dnf list all</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">查询已安装包的所有信息<br><code>rpm -qi package</code><br><code>-i, --info</code></td>
<td style="text-align: left;"><code>dnf info package</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">查询未安装包的所有信息<br><code>rpm -qip package.rpm</code><br><code>-p, --package</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">查询当前已安装包依赖于哪些文件或包<br><code>rpm -qR package</code><br><code>-R, --requires</code><span id="依赖"></span></td>
<td style="text-align: left;">查询已安装或未安装包依赖于哪些文件或包<br><code>dnf repoquery --requires package</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">查询当前未安装包依赖于哪些文件或包<br><code>rpm -qpR package.rpm</code></td>
<td style="text-align: left;">查询已安装或未安装包依赖于哪些包<br><code>dnf repoquery --requires --resolve package</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">查询哪些包依赖于当前已安装的包<br><code>rpm -q --whatrequires package</code>
<span id="被依赖"></span></td>
<td style="text-align: left;">查询已安装或未安装包依赖于哪些文件或包<br><code>dnf repoquery --whatrequires package</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">查询文件属于哪个包<br><code>rpm -qf file</code>
<span id="文件找包"></span></td>
<td style="text-align: left;"><code>dnf provides file</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">列出已安装包安装了哪些文件<br><code>rpm -ql package</code>
<span id="列文件"></span></td>
<td style="text-align: left;">列出已安装包安装了哪些文件<br><code>dnf repoquery -l package</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">列出未安装包需要安装哪些文件<br><code>rpm -qlp package</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">包组相关操作</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">列出系统已安装包组和可用包组数量<br><code>dnf groups summary</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">列出系统已安装包组和可用包组<br><code>dnf group list</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">给出指定包组的信息<br><code>dnf group info "group name"</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">安装包组内所有包<br><code>dnf group install group_name</code><br><code>dnf group install groupid</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">删除包组内所有包<br><code>dnf group remove group_name</code><br><code>dnf group remove groupid</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">更新包组内所有包<br><code>dnf group update group_name</code></td>
</tr>
</tbody>
</table>
<h2 id="dnf关于资源库的基本操作">dnf关于资源库的基本操作</h2>
<p>dnf的主要配置文件是<code>/etc/dnf/dnf.conf</code>,
该文件包含两部分:</p>
<ul>
<li>"main"部分保存着dnf的全局设置.</li>
<li>"repository"部分保存着资源库的设置, 可以有一个或多个资源库.</li>
</ul>
<p>另外在<code>/etc/yum.repos.d</code>目录里保存着一个或多个以<code>.repo</code>为后缀的资源库相关文件，它们也可以定义不同的资源库.
这些配置文件都为INI文件格式, 所有变量的帮助可以在<a href="https://dnf.readthedocs.io/en/latest/conf_ref.html#">DNF
Configuration Reference</a>中找到.</p>
<p>通过命令对资源库的常用操作在下面列出:</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">操作</th>
<th style="text-align: left;">命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">列出所有已激活的资源库</td>
<td style="text-align: left;"><code>dnf repolist</code>,
添加<code>--all</code>或者<code>--disabled</code>选项可以选择列出所有的或者未激活资源库.
再加<code>-v</code>可以显示更多信息.</td>
</tr>
<tr class="even">
<td style="text-align: left;">显示当前的main配置信息</td>
<td style="text-align: left;"><code>dnf config-manager --dump</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">显示某个资源库的配置信息</td>
<td style="text-align: left;"><code>dnf config-manager --dump repoid</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">添加资源库</td>
<td style="text-align: left;"><code>dnf config-manager --add-repo repository_url</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">激活资源库</td>
<td style="text-align: left;"><code>dnf config-manager --set-enable repository</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">禁用资源库</td>
<td style="text-align: left;"><code>dnf config-manager --set-disable repository</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">查看<code>config-manager</code>手册</td>
<td style="text-align: left;"><code>man dnf-config-manager</code></td>
</tr>
</tbody>
</table>
<h2 id="如何建立rpm包">如何建立RPM包</h2>
<p>如果用户可以自己从源代码构建可执行文件, 那么就可以自己建立RPM包.
有一篇<a href="https://rpm-packaging-guide.github.io/">RPM Packaging
Guide</a>和<a href="https://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/index.html">Fedora
RPM Guide</a>里面有详细的介绍.</p>
<h2 id="如何建立本地资源库">如何建立本地资源库</h2>
<p>TBD</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://rpm-packaging-guide.github.io/">RPM Packaging
Guide</a></li>
<li><a href="https://dnf.readthedocs.io/en/latest/api.html">DNF, the
next-generation replacement for YUM</a></li>
<li><a href="https://linux-audit.com/determine-file-and-related-package/">Discover
to which package a file belongs to</a></li>
<li><a href="https://docs.openeuler.org/zh/docs/20.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8DNF%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85.html">使用DNF管理软件包</a></li>
<li><a href="http://www.linuxfly.org/post/130/">[原]自己制作rpm软件包</a></li>
<li><a href="https://linux.cn/article-12161-1.html">DNF 和 Yum
的区别，为什么 Yum 会被 DNF 取代？</a></li>
<li><a href="https://docs.fedoraproject.org/en-US/epel/">Extra Packages
for Enterprise Linux (EPEL)</a></li>
<li><a href="https://www.tecmint.com/create-local-yum-repository-on-centos-8/">How
to Set Up a Local Yum/DNF Repository on CentOS 8</a></li>
<li><a href="http://ftp.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html">RPM
File Format</a></li>
<li><a href="https://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/index.html">Dedora
RPM Guide</a></li>
<li><a href="https://fedoranews.org/alex/tutorial/rpm/">Fedora News RPM
Tutorial</a></li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>rpm命令中,
上面个提到的<code>package.rpm</code>都可以是网络地址,
比如<code>ftp://user:pass@ftpserver/directory/package.rpm</code>或者<code>http://webserver/dir/remote-package.rpm</code><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>rpm命令中, 使用<code>--test</code>跟其他选项组合,
可以虚拟的执行该动作, 配合<code>-vv</code>选项, 可以用来调试.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>这里package可以是仅仅上上文<a href="#rpm文件命名规范">rpm文件命名规范</a>里提到的NAME,
也可以带上VERSIO和(或)RELEASE<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>技术</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rpm</tag>
        <tag>dnf</tag>
        <tag>package management</tag>
      </tags>
  </entry>
  <entry>
    <title>linux tips</title>
    <url>//c078c8ce/</url>
    <content><![CDATA[<p>用来记录使用linux过程中发现的过去不知道的小知识. 持续更新.</p>
<span id="more"></span>
<h3 id="在centosfedoraredhat上usr-merge">在CentOS/Fedora/RedHat上/usr
merge</h3>
<p>在CentOS上的根目录的几个目录是/usr下同名目录的符号链接:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin -&gt; usr/bin</span><br><span class="line">sbin -&gt; usr/sbin</span><br><span class="line">lib -&gt; usr/lib</span><br><span class="line">lib64 -&gt; usr/lib64</span><br></pre></td></tr></table></figure></p>
<p>之前一直不知道原因, 通过<a href="https://www.freedesktop.org/wiki/Software/systemd/TheCaseForTheUsrMerge/">这篇文章The
Case for the /usr Merge</a>. 了解到.
过去，/bin和/sbin目录中的程序用于挂载usr分区.
现在这项工作由initramfs完成, 因此拆分目录不再有任何作用.
发行版不再需要将实用程序分散到不同的目录中,
将它们全部存储在/usr中可以简化文件系统层次结构.</p>
<hr>
<h3 id="在linux-manual中查看目录结构">在linux manual中查看目录结构</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man hier</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="usrbin与usrlocalbin的区别">usr/bin与usr/local/bin的区别</h3>
<p>usr/local/bin存放不被包管理工具管理的用户程序.
比如直接从源代码编译的binary文件.</p>
<hr>
<h3 id="修改terminal里输出的语言为英语">修改terminal里输出的语言为英语</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<p>可以加到.bashrc里</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python decorator(装饰器)</title>
    <url>//df491dd4/</url>
    <content><![CDATA[<p>Python的装饰器语法是一种<a href="https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E6%B3%95%E7%B3%96">语法糖</a>.
虽然没有它也能写代码, 但这东西既有助于书写时候减少代码量,
也有助于代码阅读.
有时候甚至让我觉得Python比其他动态语言更接近于自然语言的主要原因之一是因为有装饰器的存在.
装饰器在程序语言中的作用类似于自然语言的<strong>定语和状语</strong>,
不影响句子主干, 但能使原来简单的句子富于变化, 更凝练的表达更多的信息.
<span id="more"></span></p>
<p>这篇文章目标是要把所有跟装饰器相关的知识一次性讲清楚,
目标是即便是python初学者通过本文就可以完全理解装饰器.
本文语法基于python3, 代码在python3.9上测试通过.</p>
<h2 id="预备知识">预备知识</h2>
<p>在学习装饰器之前也需要理解一些Python的基础知识.</p>
<ol type="1">
<li>要知道并且理解python里万物皆对象.
也了解对象可以具有自己的属性(attribute).</li>
<li>了解表达式(expression)和语句(statement)的区别.</li>
<li>可调用对象(callable objects)就是能做调用(call)这个动作的对象. 函数,
实例方法, 类, 具有<code>__call__</code>方法的类实例都属于可调用对象.
调用(call)这个动作在python里意味着以某些对象作为输入(input)参数执行一段代码,
并返回其他一个或多个对象.</li>
<li>名字(name)在python里仅仅是识别对象的一个标签(或者叫标识符identifier),
一个对象可以有多个标签, 一个标签在不同时间也可以被贴在不同对象上.</li>
<li>python里的函数定义语法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 相当于让解释器生成一个函数对象,
然后给他起了个<code>myfun</code>的名字. 如果再对myfun赋值: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfun = other_object</span><br></pre></td></tr></table></figure>
相当于让myfun这个名字(标签)指向(贴到)别的对象上.</li>
<li>函数体内部也可以定义别的函数对象.</li>
<li>函数对象可以作为参数传入别的<strong>可调用对象</strong>的调用,
或者作为返回值从别的调用传出.</li>
</ol>
<h2 id="装饰器是如何工作的">装饰器是如何工作的</h2>
<p>先看看decorator(装饰器)在<a href="https://docs.python.org/3/glossary.html#term-decorator">官方文档</a>中的定义:
<blockquote><p>A function returning another function, usually applied as a function
transformation using the <span class="citation" data-cites="wrapper">@wrapper</span> syntax. Common examples for
decorators are classmethod() and staticmethod().</p>
<p>The decorator syntax is merely syntactic sugar, the following two
function definitions are semantically equivalent:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br><span class="line">f = <span class="built_in">staticmethod</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>The same concept exists for classes, but is less commonly used
there.</p>
</blockquote></p>
<p>这个定义有点粗糙, 不精确, 不完整, 也不好理解. 这不是一个好的定义.
下面我自己尝试解释一下.</p>
<p>首先装饰器的句法就是在函数定义语句之前或者类定义语句之前的相邻的行上书写<code>@expression</code>(<code>@</code>符号+表达式+换行符).</p>
<p>为了强调<code>@</code>后是个<strong>表达式(expression)</strong>,
我将其称作<strong>装饰器表达式</strong>,
对这个表达式的要求有如下几条规则,
在本文中我称其为装饰器协议<span id="decoratorProtocol">(非官方名称,
我自己取的名字):</span></p>
<ol type="1">
<li>该表达式的解析(evaluation)必须是一个可调用对象(callable
object).</li>
<li>这个可调用对象能够接受被修饰的对象(紧挨着装饰器后面的函数,类,方法)作为唯一的输入参数.</li>
<li>这个可调用对象应用调用运算后应该返回一个跟被修饰对象相同类型的对象.(非必须,
但是如果不这样, 装饰器行为难以理解和阅读.)</li>
</ol>
<p>在本文中, 根据被修饰的对象,
我把装饰器分为函数装饰器(用来装饰函数和方法)和类装饰器(用来装饰类).
这种说法其实有些歧义,
很多文章把装饰器表达式是函数还是类来作装饰器分类标准.
但实际上装饰器表达式可以是任意表达式, 只要满足上面<a href="#decoratorProtocol">装饰器协议</a>. 官方<a href="https://www.python.org/dev/peps/pep-3129/">PEP-3129</a>明确给出"Class
Decorator的说法". 但事实上, 分类不重要, 重要的是明白其如何工作.</p>
<p>以函数装饰器为例, 看起来是这样 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@deco_exp</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">...</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>这个被翻译器解释为如下的赋值语句: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">...</span>)</span><br><span class="line">    ...</span><br><span class="line">myfun = deco_exp(myfun)</span><br></pre></td></tr></table></figure></p>
<p>我们分析一下解释后的语句干了什么, 这其实就是</p>
<ol type="1">
<li>首先由<a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions">函数定义语句</a>,
生成了一个函数对象, 并且用名字myfun指向这个对象,</li>
<li>然后对装饰器表达式<code>deco_exp</code>进行解析(evaluate),
其返回值是一个可调用对象.</li>
<li>紧接着对这个可调用对象使用<a href="https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-call">调用表达式</a>,
调用的返回值与被修饰的函数同一类型, 也是个函数.</li>
<li>根据赋值语句,
让原来的名字myfun指向了前面返回的函数对象(可以是新对象也可以是原来的对象).</li>
</ol>
<p>从这个分析可以看出前面两种等价的表达里, 装饰器方式,
比后面的复制方式精炼得多.</p>
<div class="note warning"><p>通过这种解释,
我们也能知道对表达式的解析这个动作是跟函数定义同层进行的,
所以如果在这一个时刻,
表达式依赖得某些变量并没有定义或者没有获得正确的赋值,
装饰器不会正常工作.</p>
</div>
<p>最后我们大体上能理解为什么这种语法叫装饰器,
通常来讲装饰器不会改变被修饰对象的行为, 而是做一些辅助工作,
最后一步使myfun还指向一个同样功能,
但是已经添加了辅助工作的同样类型的对象. 如果你没有这么做,
调用后返回了完全不同的对象,
表面上看起来就是装饰器使被装饰的对象的行为完全变化,
这不是装饰器这种语法被设计的本意.</p>
<h2 id="装饰器表达式">装饰器表达式</h2>
<p>常用的装饰器表达式一般有如下几种可能:</p>
<ol type="1">
<li>函数名</li>
<li>函数调用</li>
<li>类名</li>
<li>实例名</li>
<li>类方法</li>
</ol>
<p>下面我们举一些例子来分别对各种方式的装饰器进行展示.</p>
<h3 id="函数名做装饰器">函数名做装饰器</h3>
<p>用函数名做装饰器表达式, 是最简单也是最常见的用法. 比如这个函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_attrib</span>(<span class="params">f</span>):</span><br><span class="line">    f.__tmp_attrib__ = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<p>这个函数给对象添加了一个属性后将其返回. 如果用函数名字做装饰器. 比如:
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@add_attrib</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">myfun</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun</span><br><span class="line">&lt;function myfun at <span class="number">0x0000000002A551F0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(myfun)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun.__tmp_attrib__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure> 我们可以看到, myfun被添加了一个属性. 这个装饰器等价于:
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">myfun = add_attrib(myfun)</span><br></pre></td></tr></table></figure> 之所以说以函数名做装饰器表达式简单,
是因为这里跳过了表达式解析(evaluation)的阶段, 直接进行了函数调用.
理解起来更简单.</p>
<p>前面这个例子比较特殊的地方还在于其返回的是输入对象,
所以也可以用来做类装饰器. 比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@add_attrib</span><br><span class="line"><span class="meta">... </span><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.MyClass&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass.__tmp_attrib__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myobj = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myobj.__tmp_attrib__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这个装饰器等价于: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">MyClass = add_attrib(MyClass)</span><br></pre></td></tr></table></figure></p>
<p>因为类装饰器非常少见, 后面也为了缩短篇幅, 就不再举类装饰器的例子.</p>
<p>我们看一个返回的不是原对象的例子: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twice</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs) + f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br></pre></td></tr></table></figure>
以twice这个函数名作为装饰器表达式, 其作用是把被装饰器修饰的函数执行两遍,
然后结果相加. 比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@twice</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@twice</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">n</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> n*(<span class="number">1</span>+n)//<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="number">10</span>)</span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure>
<p>仔细分析一下这个twice函数, 其返回一个函数对象inner.
所以这个等价的赋值语句: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">concat = twice(concat)</span><br></pre></td></tr></table></figure>
使得concat指向名为inner的一个函数对象.
这个内部的函数对象将"被修饰的函数"调用了两遍并相加.
在代码阅读上修饰器的方式明显比赋值的方式可读性更好.
但这里也有一个不和谐的地方.
我们被修饰的对象的属性因为这个赋值发生了一些变化. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat.__name__</span><br><span class="line"><span class="string">&#x27;inner&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>.__name__</span><br><span class="line"><span class="string">&#x27;inner&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat</span><br><span class="line">&lt;function twice.&lt;<span class="built_in">locals</span>&gt;.inner at <span class="number">0x0000000002A55670</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span></span><br><span class="line">&lt;function twice.&lt;<span class="built_in">locals</span>&gt;.inner at <span class="number">0x0000000002A554C0</span>&gt;</span><br></pre></td></tr></table></figure>
这种不和谐就好比是自然语言中我们给句子加个状语,
结果动词也还要加个词缀一样难受.
python给我们提供了一个解决方案来克服这个问题.
给inner前面加一个装饰器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twice</span>(<span class="params">f</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs) + f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
<p>这个时候再测试一下concat: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> &gt;&gt;&gt; @twice</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat</span><br><span class="line">&lt;function concat at <span class="number">0x00000000006C2D30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat.__name__</span><br><span class="line"><span class="string">&#x27;concat&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
这样装饰器看起来就像是真的在"装饰"后面的函数,
而不是修改了被装饰的函数.</p>
<p>有两个python内置(built-in)的装饰器, <a href="https://docs.python.org/3/library/functions.html#classmethod"><code>classmethod</code></a>和<a href="https://docs.python.org/3/library/functions.html#staticmethod"><code>staticmethod</code></a>,
用来帮助用户生命类方法和静态方法.</p>
<h3 id="函数调用做装饰器">函数调用做装饰器</h3>
<p>前面看到的<code>@functools.wraps(f)</code>装饰器实际上就是以函数调用作为装饰器.
我们看一个例子:</p>
<p>我们改写一下<code>add_attrib</code>这个函数,
让其输入参数可以作为属性的值. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_attrib</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">f</span>):</span><br><span class="line">        f.__tmp_attrib__ = value</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure> 这时, 下面这个装饰器
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@add_attrib(<span class="params"><span class="literal">False</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*arg</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arg)</span><br></pre></td></tr></table></figure> 等价于 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def concat(*arg):</span><br><span class="line">    return &#x27;&#x27;.join(arg)</span><br><span class="line">concat = add_attrib(False)(concat)</span><br></pre></td></tr></table></figure>
这里先对<code>add_attrib(False)</code>解析, 得到一个inner的函数对象.
再对这个函数对象实施调用操作, 类似于<code>inner(concat)</code>,
返回一个加了<code>__tmp_attrib__</code>属性的concat函数对象.</p>
<p>从被修饰的对象的角度看, 这就像是装饰器带了参数,
所以很多教程也把这个叫做带参数的装饰器.</p>
<h3 id="类名做装饰器">类名做装饰器</h3>
<p>如果以类名做装饰器, 那么下面的等效语句中 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfun = deco_exp(myfun)</span><br></pre></td></tr></table></figure>
deco_exp是类名, 复制后myfun将指向类的一个类实例.
如果被修饰的对象(myfun原来指向的对象)是函数,
类应该实现一个<code>__call__</code>方法来使这个类实例成为可调用对象,
这样用户在对myfun进行调用操作时, 就不会感觉到有什么不同.</p>
<p>举个例子, 下面这个<code>Timer</code>类,
帮助用户记录从函数声明到函数调用的时间和函数的执行时间. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.decl_start = time.time()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        call_start = time.time()</span><br><span class="line">        r = self.func(*args, **kwargs)</span><br><span class="line">        call_end= time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Decl: &#123;&#125; secs&quot;</span>.<span class="built_in">format</span>(<span class="built_in">round</span>(call_start - self.decl_start,<span class="number">2</span>)))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exec: &#123;&#125; secs&quot;</span>.<span class="built_in">format</span>(<span class="built_in">round</span>(call_end - call_start,<span class="number">2</span>)))</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">delay</span>):</span><br><span class="line">    time.sleep(delay)</span><br></pre></td></tr></table></figure>
结果看起来是这样 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun(<span class="number">2</span>)</span><br><span class="line">Decl: <span class="number">4.1</span> secs</span><br><span class="line">Exec: <span class="number">2.0</span> secs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun(<span class="number">3</span>)</span><br><span class="line">Decl: <span class="number">9.3</span> secs</span><br><span class="line">Exec: <span class="number">3.01</span> secs</span><br></pre></td></tr></table></figure></p>
<h3 id="类实例做装饰器">类实例做装饰器</h3>
<p>改造一下前面的<code>Timer</code>类,
使其可以根据不同的参数输出不同的时间.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, timer_type</span>):</span><br><span class="line">        self.timer_type = timer_type</span><br><span class="line">        self.decl_start = time.time()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,  func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            call_start = time.time()</span><br><span class="line">            r = func(*args, **kwargs)</span><br><span class="line">            call_end= time.time()</span><br><span class="line">            <span class="keyword">if</span> self.timer_type == <span class="string">&#x27;decl&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Decl: &#123;&#125; secs&quot;</span>.<span class="built_in">format</span>(<span class="built_in">round</span>(call_start - self.decl_start,<span class="number">2</span>)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Exec: &#123;&#125; secs&quot;</span>.<span class="built_in">format</span>(<span class="built_in">round</span>(call_end - call_start,<span class="number">2</span>)))</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer(<span class="params"><span class="string">&#x27;decl&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">delay</span>):</span><br><span class="line">    time.sleep(delay)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer(<span class="params"><span class="string">&#x27;exec&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun2</span>(<span class="params">delay</span>):</span><br><span class="line">    time.sleep(delay)</span><br></pre></td></tr></table></figure>
<p>效果如下: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun(<span class="number">2</span>)</span><br><span class="line">Decl: <span class="number">5.63</span> secs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun2(<span class="number">3</span>)</span><br><span class="line">Exec: <span class="number">3.01</span> secs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun</span><br><span class="line">&lt;function myfun at <span class="number">0x00000000006F1E50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfun2</span><br><span class="line">&lt;function myfun2 at <span class="number">0x00000000006F1F70</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>分析一下其等效的赋值表达式. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfun = Timer(<span class="string">&#x27;decl&#x27;</span>)(myfun)</span><br></pre></td></tr></table></figure>
<code>Timer('decl')</code>先被解析, 返回一个类实例对象,
然后使该实例做调用行为, <code>obj.__call__</code>被调用,
返回一个内部的临时函数,
这个函数由于有<code>@functools.wraps</code>装饰器加持,
使myfun名字看起来还是原来定义的原来定义的原来定义的原来定义的原来定义的原来定义的原来定义的原来定义的myfun函数.
但实际上新的myfun函数对象会根据类实例的<code>timer_type</code>属性打印不通的时间.</p>
<h2 id="类方法做装饰器">类方法做装饰器</h2>
<p>类方法也可以做装饰器, 时函数名做装饰器的一个特例.
通常装饰的对象也是类方法(不绝对). 例如 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bang</span>(<span class="params">func</span>) :</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">self, *args, **kwargs</span>) :</span><br><span class="line">            <span class="keyword">return</span> func(self, *args, **kwargs) + <span class="string">&#x27;!&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">    @bang</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, word</span>) :</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>() :</span><br><span class="line"><span class="meta">    @A.bang</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, word</span>) :</span><br><span class="line">        <span class="keyword">return</span> word + word</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"><span class="built_in">print</span>(a.bar(<span class="string">&#x27;Python&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(b.foo(<span class="string">&#x27;Python&#x27;</span>))</span><br></pre></td></tr></table></figure> 会打印出结果
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python!</span><br><span class="line">PythonPython!</span><br></pre></td></tr></table></figure></p>
<div class="note warning"><p>当被装饰对象是类方法时, 最后方法依然会被bind到类上,
所以装饰器表达式被调用之后的返回值(也就是<a href="#decoratorProtocol">装饰器协议</a>里第三步)是一个可调用对象,
并且第一个参数期望得到类实例(self).</p>
<p>这个装饰器在类定义语法以外使用的话会很有可能有不一样的结果.
需要特别注意.</p>
</div>
<h2 id="多个装饰器">多个装饰器</h2>
<p>python允许给函数或者类前面添加多个装饰器,
原理就是嵌套使用等价赋值表达式. 比如我们把两个装饰器连起来用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@add_attrib</span></span><br><span class="line"><span class="meta">@twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*arg</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arg)</span><br></pre></td></tr></table></figure>
<p>这个等价于如下赋值语句, <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">concat = add_attrib(twice(concat))</span><br></pre></td></tr></table></figure> 其结果如下 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat</span><br><span class="line">&lt;function concat at <span class="number">0x0000000002A55670</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat.__tmp_attrib__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>再举例一个有变量的 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Timer(<span class="params"><span class="string">&#x27;exec&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@add_attrib(<span class="params"><span class="literal">False</span></span>)</span></span><br><span class="line"><span class="meta">@twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*arg</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arg)</span><br></pre></td></tr></table></figure> 等价于 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*arg</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arg)</span><br><span class="line">concat = Timer(<span class="string">&#x27;exec&#x27;</span>)(add_attrib(<span class="literal">False</span>)(twice(concat)))</span><br></pre></td></tr></table></figure></p>
<p>等价于下面的解析顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">timer_obj = Timer(<span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line">add_attrib_inner = add_attrib(<span class="literal">False</span>)</span><br><span class="line">twice_inner = twice(concat)</span><br><span class="line">twice_inner = add_attrib_inner(twice_inner)</span><br><span class="line">timer_inner = timer_obj(twice_inner)</span><br><span class="line">concat = timer_inner</span><br></pre></td></tr></table></figure>
<p>这里就更能一目了然的看出来装饰器在可读性上给python提供了多大的帮助.</p>
<h2 id="总结">总结</h2>
<p>有关装饰器的知识知道这么多就基本足够了.
虽然装饰器<code>@</code>后面的表达式还可以是任意复杂的表达式.
但过于复杂了也就不符合装饰器语法产生的初衷了.</p>
<p>如果想知道的更多, 可以参考</p>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0318/">PEP-318
Decorators for Functions and Methods</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3129/">PEP-3129 Class
Decorators</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0614/">PEP-614 Relaxing
Grammar Restrictions On Decorators</a></li>
</ul>
<p>有一个很好的练习就是看看functools.wraps这个装饰器为什么可以使被装饰的对象看起来跟原来一样.</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>decorator</tag>
      </tags>
  </entry>
  <entry>
    <title>在启动时用subst映射目录到虚拟盘</title>
    <url>//3c98bdf2/</url>
    <content><![CDATA[<p>subst可以把一个目录虚拟成一个驱动盘, 比如 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subst I: &quot;C:\Users\Username\OneDrive - XXX&quot;</span><br></pre></td></tr></table></figure></p>
<p>但有个问题, 重启电脑之后上一次的配置失效, 需要重新设置.
如何才能让电脑记住之前的设置呢?</p>
<p><a href="https://superuser.com/questions/29072/how-to-make-subst-mapping-persistent-across-reboots">StackExchange上的这篇</a>给出几个解决方案.</p>
<span id="more"></span>
<p>其中一个是通过chocolatey安装了psubst. 但这个在我的电脑上无法工作,
怀疑是公司的防火墙引起的.</p>
<p>我用了下面这个解决方案, 亲测可行. 在注册表里添加下面的项.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REGEDIT4</span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]</span><br><span class="line">&quot;F Drive&quot;=&quot;subst F: D:\\mount\\db&quot;</span><br><span class="line">&quot;G Drive&quot;=&quot;subst G: D:\\mount\\log&quot;</span><br></pre></td></tr></table></figure> 注意: 启动之后不会立即起作用, 可能要等几秒到几十秒.</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>choco</tag>
        <tag>subst</tag>
        <tag>psubst</tag>
      </tags>
  </entry>
  <entry>
    <title>《流利的Python》第二版(Fluent Python edition 2)读书笔记</title>
    <url>//7112fecc/</url>
    <content><![CDATA[<div class="note info"><p>之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程,
可以通过这本书作为线索, 学习一下最新的python语言特性.
这读书笔记会专注于记录那些我不熟悉的新特性(或者老特性),
或者能够给我启发的内容.</p>
</div>
<span id="more"></span>
<p>《流利的Python》第二版是基于python3.10版本的, 是一本对Python
3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读,
更pythonic的代码. 主要包括下面五个部分:</p>
<ul>
<li>数据结构</li>
<li>函数对象</li>
<li>面向对象</li>
<li>控制流</li>
<li>元编程</li>
</ul>
<h2 id="preface">Preface</h2>
<h3 id="how-the-book-is-organized">How the Book Is Organized</h3>
<h4 id="part-i-数据结构">Part I, 数据结构</h4>
<p>第一章介绍的是Python数据模型,
解释为啥双下划线方法是所有类型对象一致行为的关键.
剩下的章节介绍容器类型的使用:包括sequences, mappings, sets, 和str vs
bytes. 也介绍了标准库里的一些更高级的构造类: named tuple
factories和@dataclass装饰器. Python3.10加入的模式匹配(Pattern
matching)会在第2,3,5章介绍, 包括sequence patterns, mapping patterns,
和class patterns. Part I最后一章介绍对象的生命周期: references,
mutability, garbage collection.</p>
<div class="note info"><p>Part I 里面最感兴趣的是标准库里的容器类,
和python3.10的matching语法.</p>
</div>
<h4 id="part-ii-函数对象">Part II, 函数对象</h4>
<p>函数作为语言中的第一类对象: 什么意思,
它是如何影响一些流行的设计模式，以及如何通过利用闭包来实现函数装饰器.
这里还介绍了Python中可调用对象的一般概念, 函数属性, 自省(introspection),
参数注释和Python3中新的非本地声明。第8章介绍了函数签名中的主要新主题--类型提示(pyte
hints).</p>
<div class="note info"><p>Part II 里面最感兴趣的是类型提示.</p>
</div>
<h4 id="part-iii-类与协议">Part III 类与协议</h4>
<p>这部分解释了如何构建容器类, 抽象基类, 协议, 多继承, 运算符重载.
第15章继续讨论类型提示.</p>
<h4 id="part-iv-控制流">Part IV 控制流</h4>
<p>这部分介绍了超过条件,循环,子过程这种传统控制流的语言结构和库.
包括生成器, 上下文访问管理器(visit context managers)和协程,
<code>yield from</code>语法. 第18章包括了使用pattern matching的例子.
第19章是新章节, 介绍了并行编程的一个可选项.
关于异步编程的章节也被重写了.</p>
<div class="note info"><p>Part IV最感兴趣的是协程, with语句.</p>
</div>
<h4 id="part-v-元编程metaprogramming">Part V
元编程(Metaprogramming)</h4>
<p>这部分首先回顾了一个技术, 可以构建一种类, 该类具有能够动态构建的属性,
能处理半结构化数据(比如JSON数据集). 然后介绍了familiar属性机制,
然后深入探讨对象属性访问如何在 Python 中使用描述符在底层工作.
解释了函数, 方法和描述符之间的关系. 在第五部分中,
字段验证库的逐步实现揭示了导致最后一章的高级工具的细微问题:
类装饰器和元类.</p>
<div class="note info"><p>全部感兴趣.</p>
</div>
<h2 id="part-i-数据结构data-structures">1. PART I 数据结构(Data
Structures)</h2>
<h3 id="chapter-1-the-python-data-model">1.1. Chapter 1 The Python Data
Model</h3>
<div class="note info"><p>这一章的内容就是介绍双下划线特殊方法, 没有什么新颖的.
这里就是学到一个新词dunder, 比如说<code>__getitem__</code>,
可以读为"dunder-getitem". dunder是"double underscore before and
after"的缩写. 所以说下面三个是同义词special method, magic method, dunder
method.</p>
</div>
<p>下面几个图总结得很有条理, 这里记录一下. <img src="/7112fecc//Figure1_2.png" class width="800" title="Figure 1-2 Collections UML"> <img src="/7112fecc//Table1_1.png" class width="800" title="Table 1-1 Special Method Names (operators excluded)">
<img src="/7112fecc//Table1_2.png" class width="800" title="Table 1-2 Special Method Names for operators"></p>
<h3 id="chapter-2-an-array-of-sequences">1.2. Chapter 2 An Array of
Sequences</h3>
<p>这一章主要讲各种序列(sequence)对象, 主题包括</p>
<ul>
<li>list推导式(comprehension)和生成器表达式(generator expressions)</li>
<li>tuple用作记录(record) vs tuple用作不可变list</li>
<li>序列解包(unpacking)和序列模式(pattern)</li>
<li>切片对象的读和写</li>
<li>特殊的序列类型, 比如array和queue</li>
</ul>
<h4 id="overview-of-built-in-sequences">1.2.1. Overview of Built-in
Sequences</h4>
<p>两种分类方法:</p>
<ul>
<li>容器序列(list, tuple, collections.deque) vs 平铺序列(str, bytes,
array.array)</li>
<li>可变序列(list, bytearray, array.array) vs 不可变序列(tuple, str,
bytes)</li>
</ul>
<h4 id="list-comprehensions-and-generator-expressions">1.2.2. List
Comprehensions and Generator Expressions</h4>
<p>这两个概念对应的语法几乎是一样的,
唯一的区别就是前者用<code>[]</code>后者用<code>()</code>. 实际上,
前者生成一个list, 后这生成一个generator对象.</p>
<h4 id="tuples-are-not-just-immutable-lists">1.2.3. Tuples Are Not Just
Immutable Lists</h4>
<p>Tuples as Records也就是类似于c语言的struct, 只不过没有field名字,
只靠位置来访问. 可以方便的通过一个赋值语句来解包.</p>
<p>Tuples as Immutable Lists给出了几条用tuple替代list的优势,
主要就是长度已知和速度更快.</p>
<p>下面这张比较list, tuple两种对象方法和属性的表值得收藏.</p>
<img src="/7112fecc//Table2_1.png" class width="800" title="Table 2-1 Methods and attributes found in list or tuple">
<h4 id="unpacking-sequences-and-iterables">1.2.4. Unpacking Sequences
and Iterables</h4>
<p>序列解包, 可以避免使用索引(index)运算.
解包操作可以被使用到所有iterable对象上, 不光sequence对象.</p>
<p>最基本的解包操作就是并行赋值(parallel assignment).</p>
<p>另一个解包操作就是在函数调用时, 给一个参数加前缀<code>*</code>.
例子如下: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = <span class="built_in">divmod</span>(*t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>加*前缀拆包还有以下几个用途</p>
<h5 id="using-to-grab-excess-items">1.2.4.1. Using * to Grab Excess
Items</h5>
<p>主要用于并行赋值(parallel assignment), 抓取额外的元素.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h5 id="unpacking-with-in-function-calls-and-sequence-literals">1.2.4.2.
Unpacking with * in Function Calls and Sequence Literals</h5>
<p>在函数调用时, 解包之后的可迭代对象可以被用作相应位置的输入参数.
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b, c, d, *rest</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> a, b, c, d, rest</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(*[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, *<span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, (<span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure></p>
<p>也可以用在定义list, tuple, set的文本(Literal)里, 比如:
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>, *(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="nested-unpacking">1.2.4.3. Nested Unpacking</h5>
<p>嵌套的tuple可以直接嵌套式解包, 比如: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;São Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;&quot;</span>:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;<span class="string">&quot;latitude&quot;</span>:&gt;<span class="number">9</span>&#125;</span> | <span class="subst">&#123;<span class="string">&quot;longitude&quot;</span>:&gt;<span class="number">9</span>&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> name, _, _, (lat, lon) <span class="keyword">in</span> metro_areas:</span><br><span class="line">        <span class="keyword">if</span> lon &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;lat:<span class="number">9.4</span>f&#125;</span> | <span class="subst">&#123;lon:<span class="number">9.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h4 id="pattern-matching-with-sequences">1.2.5. Pattern Matching with
Sequences</h4>
<p>python 3.10加入的新语法match/case 语句 在这本书里根据pattern的类型,
被拆分到各个章节. 这节只介绍sequence的pattern.</p>
<p>看下面这个例子: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_command</span>(<span class="params">self, message</span>):</span><br><span class="line">    <span class="keyword">match</span> message:</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;BEEPER&#x27;</span>, frequency, times]:</span><br><span class="line">            self.beep(times, frequency)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;NECK&#x27;</span>, angle]:</span><br><span class="line">            self.rotate_neck(angle)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;LED&#x27;</span>, ident, intensity]:</span><br><span class="line">            self.leds[ident].set_brightness(ident, intensity)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;LED&#x27;</span>, ident, red, green, blue]:</span><br><span class="line">            self.leds[ident].set_color(ident, red, green, blue)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">raise</span> InvalidCommand(message)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>关键字<code>match</code>后面的表达式是主语(subject),
Python将要尝试把主语匹配到每个<code>case</code>分句中的pattern上.</li>
<li>第一个pattern会跟任何包含三个元素的sequence进行匹配,
第一个元素必须是字符串'BEEPER'. 第二个和第三个可以是任何值,
他们会被按顺序绑定到变量<code>frequency</code>和<code>times</code>.</li>
<li>第二个pattern匹配任何具有两个元素且第一个是字符串'NECK'的主语.</li>
<li>第三个pattern将匹配任何具有三个元素且第一个元素是字符串'LED'的主语.
如果元素个数不匹配, Python会继续尝试匹配下一个<code>case</code>.</li>
<li>第四个pattern将匹配首元素是'LED'的5元素主语.</li>
<li>最后一句是默认<code>case</code>.
任何在前面pattern中找不到匹配的主语将匹配这一条,
<code>_</code>是个特殊变量, 后面会讲到.</li>
</ol>
<p>这里比较了match/case跟C语言里的switch/case的区别, 作者认为:</p>
<ol type="1">
<li>原来python中的<code>if/elif/elif/.../else</code>语句块是switch/case的一个很好的替代品,
而且避免了c语言中常碰到的fallthrough和dangling else问题.
前者是忘记写break时产生的,
后者是if-else不写大括号导致嵌套if语句的是else匹配跟预想的不一致.</li>
<li>match/case比switch/case强大, 一个重要的改进就是解构(destructuring),
也就是可以在匹配时直接对主语进行拆包(unpacking)</li>
</ol>
<p>通常来讲, 当下列条件都满足, 一个sequence
pattern匹配到主语(subject):</p>
<ol type="1">
<li>主语是一个sequence;</li>
<li>主语跟pattern有相同数量的元素;</li>
<li>每一个对应的元素匹配, 包括嵌套的元素.</li>
</ol>
<p>例如pattern
<code>[name, _, _, (lat, lon)]</code>匹配一个具有4个元素的sequence,
并且其最后一个元素是具有两个元素的sequence.</p>
<p>几点额外的用法和说明:</p>
<ol type="1">
<li>sequence pattern可以是list, tuple, 或嵌套的tuples和lists的组合.
在pattern里方括号和园括号没有区别.</li>
<li>一个sequence
pattern可以匹配大多数collection.abc.Sequence的子类的实例, 但str, bytes,
bytearray除外. 这三个类型如果做match语句主语,
会像整数一样被当作单一值处理.</li>
<li>标准库里下面这些类型与sequence patterns兼容:
<code>list, tuple, memoryview, range, array.array, collections.deque</code>.</li>
<li>与前面讲的拆包不同的地方是,
不能对非sequence得可迭代对象解构(destructuring).</li>
<li>符号<code>_</code>在这里是特殊的, 它将匹配在该位置的任何元素,
但是不绑定名字.
<code>_</code>也是唯一可以多次出现在pattern里的元素.</li>
<li>可以用<code>as</code>关键字绑定pattern的一部分到一个变量,
比如<code>case [name, _, _, (lat, lon) as coord]:</code></li>
<li>可以在pattern里添加类型信息,
例如<code>case [str(name), _, _, (float(lat), float(lon))]:</code>,
这里语法跟构造器调用的语法一样, 但是含义不一样.</li>
<li><code>*_</code>可以用来表示任意数量的元素,
例如<code>case [str(name), *_, (float(lat), float(lon))]:</code>可以匹配任何以字符串开头,
以两个浮点类型元素的嵌套sequence结尾的主语.
也可以用<code>*extra</code>来替换<code>*_</code>,
这么做<code>extra</code>会绑定到一个0到多个元素的<code>list</code>对象.
在一个sequence pattern里, <code>*</code>只能出现一次.
但嵌套的sequence可以分别使用,
例如<code>case ['lambda', [*parms], *body] if body:</code></li>
<li>一个可选的以<code>if</code>开头的守卫从句可以用来添加匹配条件.
但if语句只有当匹配了pattern才会被执行.
case之后的语句块只有匹配pattern且守卫表达式为真时才会被执行, 例如:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> record:</span><br><span class="line">    <span class="keyword">case</span> [name, _, _, (lat, lon)] <span class="keyword">if</span> lon &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;lat:<span class="number">9.4</span>f&#125;</span> | <span class="subst">&#123;lon:<span class="number">9.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="slicing">1.2.6. Slicing</h4>
<p>这里作者讲了一个有趣的知识点,
执行<code>seq[start:stop:step]</code>在python内部调用了<code>seq.__getitem__(slice(start,stop,step)]</code>.
所以可以给一个slice对象命名, 比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>invoice = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>0.....6.................................40........52...55........</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1909 Pimoroni PiBrella $17.50 3 $52.50</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1489 6mm Tactile Switch x20 $4.95 2 $9.90</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1510 Panavise Jr. - PV-201 $28.00 1 $28.00</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SKU = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DESCRIPTION = <span class="built_in">slice</span>(<span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>UNIT_PRICE = <span class="built_in">slice</span>(<span class="number">40</span>, <span class="number">52</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>QUANTITY = <span class="built_in">slice</span>(<span class="number">52</span>, <span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ITEM_TOTAL = <span class="built_in">slice</span>(<span class="number">55</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>line_items = invoice.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item[UNIT_PRICE], item[DESCRIPTION])</span><br><span class="line">...</span><br><span class="line">    $<span class="number">17.50</span> Pimoroni PiBrella</span><br><span class="line">     $<span class="number">4.95</span> 6mm Tactile Switch x20</span><br><span class="line">    $<span class="number">28.00</span> Panavise Jr. - PV-<span class="number">201</span></span><br><span class="line">    $<span class="number">34.95</span> PiTFT Mini Kit 320x240</span><br></pre></td></tr></table></figure>
<p>另外还有一个给切片对象赋值, 如果赋值左边时一个切片对象,
右边必须是一个可迭代对象. 例如 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="using-and-with-sequences">1.2.7. Using + and * with
Sequences</h4>
<p>几个知识点:</p>
<ol type="1">
<li>对sequence进行<code>+</code>和<code>*</code>, 会创建新的对象,
而不会修改操作数.</li>
<li>构造多维数组时, 有个陷阱, 这个我过去也碰到过, 正确做法:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>错误做法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>下面是关于对sequence类型应用<code>+=</code>,
<code>*=</code>这种增量赋值(Augmented Assignment)的几个知识点</p>
<ol type="1">
<li>对于<code>a += b</code>, 如果实现了<code>__iadd__</code>,
那么这个dunder函数将被调用. 如果用于可变序列(mutable sequences),
那么该对象将被修改(类似于<code>a.extend(b)</code>).
<code>a</code>讲指向原来的对象.</li>
<li>如果没有实现<code>__iadd__</code>, 但是实现了<code>__add__</code>,
那么<code>a += b</code>跟<code>a = a + b</code>效果相同.
所以<code>a += b</code>运行之后<code>a</code>指向的<code>a + b</code>产生的新对象.
对于不可变序列对象(immutable sequences), 这个是必然结果.</li>
<li><code>+=</code>在底层相当于两步操作, 所以有可能完成一半之后报错,
比如下面这个例子:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">69</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">40</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">69</span>, <span class="number">50</span>, <span class="number">40</span>])</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>避免在tuple里使用可变类型元素.</li>
<li>网站<code>pythontutor.com</code>可以帮助分析内存分配.
直接分析字节码也不是很难.</li>
</ol>
<h4 id="list.sort-versus-the-sorted-built-in">1.2.8. list.sort Versus
the sorted Built-in</h4>
<p>list.sort不创建新对象, 内置函数sorted创建新的对象.
两个参数reverse是逆序不用说,
key是以可迭代对象的每个元素为唯一参数的一个函数,
这个函数返回排序时用来比较的对象. 举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>)</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br></pre></td></tr></table></figure>
<div class="note info"><p>一个额外的知识点,
利用bisect内置库模块可以在维持排序的情况下做插入和快速搜索.</p>
</div>
<h4 id="when-a-list-is-not-the-answer">1.2.9. When a List is Not the
Answer</h4>
<p>list类型非常易用, 但针对一些特定的需求, 有时候有更好的选择.
这一小章节就是介绍其他选项的, 我也经常过度使用list,
所以这章认真读一下.</p>
<h5 id="arrays">1.2.9.1. Arrays</h5>
<p>如果list只包含数字, 那么<code>array.array</code>是很有效的替代品.</p>
<ol type="1">
<li>Arrays支持所有可变序列的操作, 比如<code>.pop</code>,
<code>.insert</code>, `.extend.</li>
<li>有课外的快速读写(saving, loading)的操作,
比如<code>.frombytes</code>, <code>.tofile</code></li>
<li>跟C array一样节省.</li>
<li>无法像list一样自排序, 需要使用built-in
<code>sorted</code>函数来做排序.
例如<code>a = array.array(a.typecode, sorted(a))</code>.
使用<code>bisect.insort</code>可以在保持排序的情况下添加元素.</li>
</ol>
<p>下表是跟list的方法对比. 这本书这种对比特别直观, 点赞收藏.</p>
<img src="/7112fecc//Table2_3.png" class width="800" title="Table 2-3 Methods and attributes found in list or array">
<h5 id="memory-views">1.2.9.2. Memory Views</h5>
<p><code>memoryview</code>居然是个built-in的类,
可以让不同的sequence类型共享内存.
<code>memoryview.cast</code>方法可以通过指定内存空间内每个元素的大小,
和对元素进行重新分组来修改读写元素的方式.
这个方法返回另一个<code>memoryview</code>对象,
但跟源对象共享同一块内存.</p>
<h5 id="numpy">1.2.9.3. NumPy</h5>
<p>NumPy提供高级的数组和矩阵运算,
它是Python能够成为主流的科学计算程序语言的原因.
SciPy是基于NumPy的一个库, 提供大量科学计算算法, 包括线性代数, 微积分,
统计等.</p>
<p>NumPy和SciPyye也是一些其他工具的基础, 比如</p>
<ol type="1">
<li>Pandas提供了有效的非数字类型的数组操作, 提供了导入/导出到其它格式,
像.csv, .xls, SQL, HDF5等等.</li>
<li>scikit-learn是当前最广泛使用的机器学习工具集.</li>
<li>Dask项目, 提供了在一组机器上并行计算Numpy, Pandas,
scikit-learn过程的能力.</li>
</ol>
<h5 id="deques-and-other-queues">1.2.9.4. Deques and Other Queues</h5>
<p><code>collections.deque</code>类是一个线程安全(thread-safe)的双向序列.
可以从两端快速插入和删除. <code>deque</code>可以被固定最大长度,
叫做绑定的<code>deque</code>(bounded deque). 如果绑定的deque满了,
那么从一端加入新元素, 将导致另一端的第一个元素被删除.</p>
<p>下表是list和deque方法对比:</p>
<img src="/7112fecc//Table2_4.png" class width="800" title="Table 2-4 Methods implemented in list and deque">
<p>除了<code>deque</code>,
其他的python标准库里如下一些模块还包括了其他的一些队列类:</p>
<ol type="1">
<li>queue: 这个模块提供了thread-safe的同步类,
包括<code>SimpleQueue</code>, <code>Queue</code>,
<code>LifoQueue</code>, <code>PriorityQueue</code>.
除了<code>SimpleQueue</code>, 其他几个类可以在构建时提供一个最大长度.
但跟<code>deque</code>不同的是, 队列满了之后不会删除元素,
而是会阻塞线程, 直到有其他线程给队列腾出空间.
这对于线程间同步非常有用.</li>
<li>multiprocessing: 这个模块实现了它自己的SimpleQueue和绑定的Queue,
跟模块queue里的很像, 但是是为了进程间交互设计的.
为了任务管理提供了一个特别的<code>multiprocessing.JoinableQueue</code>类.</li>
<li>asyncio: 提供了<code>Queue</code>, <code>LifoQueue</code>,
<code>PriorityQueue</code>, 和<code>JoinableQueue</code>.
跟模块<code>queue</code>里的很像, 但是为了异步编程的任务管理设计.</li>
<li>heapq: 跟前三个模块不同, <code>heapq</code>没有实现队列类,
但是提供了一些像<code>heappush</code>, <code>heappop</code>的函数,
让用户可以像使用heap queue或者priority queue一样使用一个可变队列(mutable
sequence).</li>
</ol>
<h3 id="chapter-3-dictionaries-and-sets">1.3. Chapter 3 Dictionaries and
Sets</h3>
<p>Python的一些核心基础结构是由内存中的字典结构构成的, 比如:</p>
<ol type="1">
<li>类和实例的属性.</li>
<li>模块名字空间.</li>
<li>函数的keyword参数.</li>
<li><code>__builtins__.__dict__</code>存储所有的内置类型, 对象,
和函数.</li>
</ol>
<p>哈希表(Hash tables)是Python高性能<code>dict</code>的基础引擎.
<code>set</code>, <code>frozenset</code>也是基于哈希表.</p>
<h4 id="modern-dict-syntax">1.3.1. Modern dict Syntax</h4>
<h4 id="dict-comprehensions">1.3.1.1. dict Comprehensions</h4>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dial_codes = [</span><br><span class="line"><span class="meta">... </span>    (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> dial_codes&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial</span><br><span class="line">&#123;<span class="string">&#x27;Bangladesh&#x27;</span>: <span class="number">880</span>, <span class="string">&#x27;Brazil&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;China&#x27;</span>: <span class="number">86</span>, <span class="string">&#x27;India&#x27;</span>: <span class="number">91</span>, <span class="string">&#x27;Indonesia&#x27;</span>: <span class="number">62</span>,</span><br><span class="line"><span class="string">&#x27;Japan&#x27;</span>: <span class="number">81</span>, <span class="string">&#x27;Nigeria&#x27;</span>: <span class="number">234</span>, <span class="string">&#x27;Pakistan&#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Russia&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;United States&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code: country.upper()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> country, code <span class="keyword">in</span> <span class="built_in">sorted</span>(country_dial.items())</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> code &lt; <span class="number">70</span>&#125;</span><br><span class="line">&#123;<span class="number">55</span>: <span class="string">&#x27;BRAZIL&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;INDONESIA&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;RUSSIA&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;UNITED STATES&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unpacking-mappings">1.3.1.2. Unpacking Mappings</h4>
<p>从Python3.5版本开始映射类型的解包(mapping
unpacking)可以用有两种方式的应用:</p>
<ol type="1">
<li>在函数调用的时候, 可以应用<code>**</code>到多个参数上.</li>
<li><code>**</code>可以被用于<code>dict</code>的文本里.</li>
</ol>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">**kwargs</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> kwargs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dump(**&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, y=<span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, **&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="merging-mappings-with">1.3.1.3. Merging Mappings with
<code>|</code></h4>
<p>Python
3.9版本支持使用<code>|</code>和<code>|=</code>来合并mapping类型.
前者创建一个新的mapping对象, 新对象的类型默认跟左边的操作数相同,
后者更新现存的mapping.</p>
<h4 id="pattern-matching-with-mappings">1.3.1.4. Pattern Matching with
Mappings</h4>
<p><code>match/case</code>语句的主语(subject)可以是mapping对象.
Pattern看起来跟mapping文本很像,
可以匹配任何<code>collections.abc.Mapping</code>的子类的实例.</p>
<p>pattern
matching是用来处理嵌套的mappings和sequences的结构化记录非常强大的工具.
比如处理JSON, 半结构化数据库比如MongoDB, EdgeDB, PostgreSQL.</p>
<p>下面是个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">get_creators</span>(<span class="params">record: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">match</span> record:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;api&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;authors&#x27;</span>: [*names]&#125;:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> names</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;api&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;author&#x27;</span>: name&#125;:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [name]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>&#125;:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Invalid &#x27;book&#x27; record: <span class="subst">&#123;record!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;movie&#x27;</span>, <span class="string">&#x27;director&#x27;</span>: name&#125;:  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [name]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> _:  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Invalid record: <span class="subst">&#123;record!r&#125;</span>&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = <span class="built_in">dict</span>(api=<span class="number">1</span>, author=<span class="string">&#x27;Douglas Hofstadter&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">type</span>=<span class="string">&#x27;book&#x27;</span>, title=<span class="string">&#x27;Gödel, Escher, Bach&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(b1)</span><br><span class="line">[<span class="string">&#x27;Douglas Hofstadter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = OrderedDict(api=<span class="number">2</span>, <span class="built_in">type</span>=<span class="string">&#x27;book&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        title=<span class="string">&#x27;Python in a Nutshell&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        authors=<span class="string">&#x27;Martelli Ravenscroft Holden&#x27;</span>.split())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(b2)</span><br><span class="line">[<span class="string">&#x27;Martelli&#x27;</span>, <span class="string">&#x27;Ravenscroft&#x27;</span>, <span class="string">&#x27;Holden&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>: <span class="number">770</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> get_creators</span><br><span class="line">ValueError: Invalid <span class="string">&#x27;book&#x27;</span> record: &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>: <span class="number">770</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(<span class="string">&#x27;Spam, spam, spam&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">12</span>, <span class="keyword">in</span> get_creators</span><br><span class="line">ValueError: Invalid record: <span class="string">&#x27;Spam, spam, spam&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的几点是</p>
<ol type="1">
<li>pattern里面key的顺序不会影响匹配,
即便主语是<code>OrderedDict</code>.</li>
<li>跟sequence pattern对比, mapping pattern允许部分匹配.</li>
<li>因为允许部分匹配,
所以不需要用<code>**extra</code>匹配额外的key-value对.
但如果你想要捕获额外的key-value对, 作为一个dict,
最后一个变量可以用双星号变量, 而且不能是<code>**_</code>.</li>
</ol>
<h4 id="standard-api-of-mapping-types">1.3.1.5. Standard API of Mapping
Types</h4>
<p><code>dict</code>的接口是由<code>collections.abc</code>模块提供的<code>Mapping</code>和<code>MutableMapping</code>描述的,
见下图:</p>
<img src="/7112fecc//Figure3_1.png" class width="800" title="Figure 3-1 UML class diagram for the MutableMapping">
<p>想要自定义mapping类型, 可以扩展<code>collections.UserDict</code>,
或者通过composition包裹一个<code>dict</code>, 而不是这些ABCs的子类.
<code>collections.UserDict</code>类和标准库中的所有具体mapping类在其实现中都封装了基本dict.
而dict又构建在哈希表上. 因此. 它们都有一个限制.
即键必须是可散列(hashable)的(value不需要是可散列的，只需要key).</p>
<h5 id="what-is-hashable">1.3.1.5.1. What is Hashable</h5>
<p>定义: 如果一个对象具有一个哈希值,
并且这个值在对象的整个生命周期内不变(这需要一个<code>__hash__()</code>方法).
并且可以跟其他对象进行比较(这需要一个<code>__eq__()</code>方法),
那么这个对象就是可散列的(hashable).
两个相等的可散列对象必须具有相同的哈希值.</p>
<ul>
<li>可散列对象包括: 数值类型, flat immutable类型(str, bytes),
所有元素都是可散列的的immutable容器(frozenset, tuple if all its items
are hashable).</li>
<li>不可散列对象包括: mutable容器类(list, dict)</li>
</ul>
<p>其他几个知识点:</p>
<ol type="1">
<li>同一个对象的哈希值只有同一个python进程里能确保相等. 在不同的机器,
不同python版本, 不同python的实现, 不同的python进程里都不能确保相同.</li>
<li>用户定义类型默认是hashable,
因为默认他们的哈希值就是他们的<code>id()</code>,
而<code>__eq__()</code>方法继承了根类<code>object</code>,
简单比较对象ID. 如果对象实现了<code>__eq__()</code>方法,
那么它只有实现了<code>__hash__()</code>方法, 并且其每次能返回相同值,
它才是hashable. 所以实践中,
这两个dunder方法仅使用那些在对象生命周期内保持不变的属性.</li>
</ol>
<h5 id="overview-of-common-mapping-methods">1.3.1.5.2. Overview of
Common Mapping Methods</h5>
<p>下面这个表给出了<code>dict</code>和它的两个流行的变体<code>defaultdict</code>和<code>OrderedDict</code>.
这两个变体定义在<code>collections</code>模块.</p>
<img src="/7112fecc//Table3_1.png" class width="800" title="Table 3-1. Methods of the mapping types">
<p>未完待续</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>reading note</tag>
      </tags>
  </entry>
  <entry>
    <title>python iterable(可迭代对象) vs iterator(迭代器) vs sequence(序列) vs generator(生成器)</title>
    <url>//b55edfb5/</url>
    <content><![CDATA[<p>这四个概念是Python为了解决容器对象遍历问题抽象出来的概念.
三者之间的关系是:</p>
<p><span class="math display">\[
\text{generator}\subset\text{iterator}\subset\text{iterable}.
\]</span> <span class="math display">\[
\text{sequence}\subset\text{iterable}.
\]</span></p>
<span id="more"></span>
<h2 id="可迭代对象-iterable">可迭代对象 iterable</h2>
<p>Python<a href="https://docs.python.org/3/glossary.html#term-iterable">官方文档</a>的定义如下:</p>
<blockquote><p>An object capable of returning its members one at a time.</p>
</blockquote>
<p>定义非常抽象, 中文翻译的也算精准,
凡是能够一次返回一个成员的容器对象都是可迭代对象.
理解上可以把<strong>可迭代对象</strong>对应数学上的<strong>可数集</strong>.(容器对象对应数学上的集合)</p>
<p>可数集分为有限可数集和无限可数集, iterable也分两类:
sequence和iterator. 其中序列(sequence)对应数学里的有限可数集,
迭代器(iterator)可以类比于无限可数集(其实也是有限的,
只不过长度未知).</p>
<p>后面再分别细说这两种对象, 先说一下可迭代对象的用处.
最常用的是用在<code>for</code>语句里(所以有些文章会把iterable定义为可以用在<code>for</code>语句<code>in</code>后面的对象).
当然还有很多其他语句里可以使用iterable.
比如built-in函数<code>zip()</code>,<code>map()</code>等,
或者推导式(comprehension). 但本质上还是<code>for</code>语句的变体.
这里解释一下for语句在python里的本质.</p>
<p>下面的<code>for</code>语句: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> member <span class="keyword">in</span> iterable_obj:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># statement_block</span></span><br></pre></td></tr></table></figure></p>
<p>实际上python是按照如下进行实现的: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先获得Iterator对象:</span></span><br><span class="line">iterator_obj = <span class="built_in">iter</span>(iterable_obj)</span><br><span class="line"><span class="comment"># 循环:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值:</span></span><br><span class="line">        member = <span class="built_in">next</span>(iterator_obj)</span><br><span class="line">        <span class="comment"># statement_block</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>这里built-in函数<a href="#iter"><code>iter()</code></a>和<a href="#next"><code>next()</code></a>后面再详细解释.</p>
<p>判断一个对象是否是iterable, python的collections可以通过下面的方法.
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(obj,Iterable)</span><br></pre></td></tr></table></figure>
这个方法的实现是通过判断对象是否具有<code>__iter__()</code>方法(直到python3.9)来确定其返回值.
但这个判断方法并不符合python对iterable的定义.也就是说并不是所有的iterable都具有<code>__iter__()</code>方法.
所以我不推荐这个方法. <a href="#sequenceProtocol">后面</a>会讲到这种方法无法判断的例外.</p>
<p>想要确定一个对象是否是iterable,
即可以通过for语句遍历(即数学上可数的), 可以用如下函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def isIterable(x):</span><br><span class="line">    try:</span><br><span class="line">        iter(x)</span><br><span class="line">        return True</span><br><span class="line">    except:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>可见可迭代对象等定义在执行中等价于可以传递给built-in函数<code>iter()</code>并且不抛出异常的对象.
这里dd额buit-in函数<code>iter()</code>和特殊方法<code>__iter__()</code>将在<a href="#iter">后面</a>介绍.</p>
<h2 id="序列-sequence">序列 sequence <span id="sequence"></span></h2>
<p>Python<a href="https://docs.python.org/3/glossary.html#term-sequence">官方文档</a>的定义如下:</p>
<blockquote><p>An iterable which supports efficient element access using integer
indices via the <code>__getitem__()</code> special method and defines a
<code>__len__()</code> method that returns the length of the
sequence.</p>
</blockquote>
<p>即能够做下面两种行为的iterable被叫做序列:</p>
<ol type="1">
<li>能够通过<strong>整数</strong>索引来做成员访问.
即具有方法<code>__getitem__()</code>并其参数可以是整数.</li>
<li>能够获得长度, 即具有方法<code>__len__()</code>.
这也是为什么前面说sequence可以类比于有限可数集. 因为其具有长度.</li>
</ol>
<p>这两个特殊方法加上整数索引合起来叫做序列协议(sequence
protocol)<span id="sequenceProtocol">.
实现了序列协议的iterable对象就可以叫做序列. 比如python built-in
sequence类型<code>list</code>, <code>str</code>, <code>tuple</code> and
<code>bytes</code>.
注意<code>dict</code>虽然也有方法<code>__getitem__()</code>和<code>__len__()</code>,
但被认为是mapping而不是sequence,
因为不满足上面说的通过<strong>整数</strong>索引.
但是<code>dict</code>是可迭代对象(iterable),
因为其可以逐一返回其容器内对象.</span></p>
<h2 id="迭代器-iterator">迭代器 iterator <span id="iterator"></span></h2>
<p>Python<a href="https://docs.python.org/3/glossary.html#term-iterator">官方文档</a>的定义如下:</p>
<blockquote><p>An object representing a stream of data. Repeated calls to the
iterator's <code>__next__()</code> method (or passing it to the built-in
function <code>next()</code>) return successive items in the stream.
When no more data are available a StopIteration exception is raised
instead. At this point, the iterator object is exhausted and any further
calls to its <code>__next__()</code> method just raise StopIteration
again. Iterators are required to have an <code>__iter__()</code> method
that returns the iterator object itself so every iterator is also
iterable and may be used in most places where other iterables are
accepted.</p>
</blockquote>
<p>迭代器是一种数据流的抽象. 迭代器的具体实现也是有两个行为:</p>
<ol type="1">
<li>实现<code>__next__()</code>方法,
这个方法返回的是数据流中的下一个成员. 当所有成员都遍历过了,
再次调用方法<code>__next__()</code>,
必须抛出<code>StopIteration</code>异常代表迭代器耗尽. python
built-in函数<code>next(obj)</code><span id="next">等效于调用<code>obj.__next__()</code>.</span></li>
<li>实现<code>__iter__()</code>方法返回一个迭代器对象.
通常返回迭代器对象自身.</li>
</ol>
<p>这两个方法合起来叫做迭代器协议(iterator protocol),
也就是说只要实现了这个协议的对象都成为迭代器.
可见满足迭代器协议的对象一定也满足迭代协议.</p>
<p>讲到这里就可以回到文章刚开始提起<code>for</code>循环的本质
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先获得Iterator对象:</span></span><br><span class="line">iterator_obj = <span class="built_in">iter</span>(iterable_obj)</span><br><span class="line"><span class="comment"># 循环:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值:</span></span><br><span class="line">        member = <span class="built_in">next</span>(iterator_obj)</span><br><span class="line">        <span class="comment"># statement_block</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>里面的built-in函数<code>next()</code>已经知道是什么意思了.
现在说一下<code>iter()</code><span id="iter">.</span></p>
<p>Python<a href="https://docs.python.org/3/library/functions.html#iter">官方文档</a>对这个内置函数描述如下:</p>
<blockquote><p>iter(object[, sentinel]) Return an iterator object. The first
argument is interpreted very differently depending on the presence of
the second argument. Without a second argument, object must be a
collection object which supports the iteration protocol (the
<code>__iter__()</code> method), or it must support the sequence
protocol (the <code>__getitem__()</code> method with integer arguments
starting at 0). If it does not support either of those protocols,
TypeError is raised. If the second argument, sentinel, is given, then
object must be a callable object. The iterator created in this case will
call object with no arguments for each call to its
<code>__next__()</code> method; if the value returned is equal to
sentinel, StopIteration will be raised, otherwise the value will be
returned.</p>
</blockquote>
<p>即这个函数会返回一个iterator对象.</p>
<p><strong>如果没有第二个参数</strong>, 只有第一个参数</p>
<ol type="1">
<li>如果对象满足迭代协议, <code>obj.__iter__()</code>将被调用,
其返回值作为<code>iter(obj)</code>的返回值.</li>
<li>如果对象满足序列协议,
Python会自动通过<code>__getitem__</code>和<code>__len__</code>方法自动产生一个迭代器,
这种情况大致上<code>iter(obj)</code>等价于如下代码:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iter</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">sequence_iter</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">            self.i = <span class="number">0</span></span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            self.i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.i &lt;= <span class="built_in">len</span>(self.obj):</span><br><span class="line">                <span class="keyword">return</span> self.obj[self.i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line">    <span class="keyword">return</span> sequence_iter(obj)</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>如果上面两条协议都不满足, 那么将抛出异常TypeError.</li>
</ol>
<p><strong>如果给了第二个参数sentinel</strong>,
第一个参数必须是一个可调用对象(callable object).
<code>iter()</code>语义变成"通过对可调用对象的调用返回一系列值,
直到卫兵(sentinel)被调用的对象返回. iter(obj,
sentinel)大致上等价于如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iter</span>(<span class="params">obj, sentinel</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">sentinel_iter</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            v = self.obj()</span><br><span class="line">            <span class="keyword">if</span> v == sentinel:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">return</span> sentinel_iter(obj)</span><br></pre></td></tr></table></figure>
<h2 id="生成器-generator">生成器 generator</h2>
<p>Python<a href="https://docs.python.org/3/glossary.html#term-generator">官方文档</a>的定义如下:</p>
<blockquote><p>A function which returns a generator iterator. It looks like a normal
function except that it contains yield expressions for producing a
series of values usable in a for-loop or that can be retrieved one at a
time with the <code>next()</code> function.</p>
<p>Usually refers to a generator function, but may refer to a generator
iterator in some contexts. In cases where the intended meaning isn’t
clear, using the full terms avoids ambiguity.</p>
</blockquote>
<p>这里generator在使用上是有歧义的, 既可能指生成器函数(generator
function), 也可能指生成器迭代器(generator iterator).
本文里用generator指后者, 前者直接用生成器函数.</p>
<p>所以生成器是一种特殊迭代器, 由生成器函数产生的迭代器. 因而<span class="math inline">\(\text{generator}\subset\text{iterator}\)</span>.
生成器函数跟普通函数只有一点不一样,
生成器函数含有<code>yield</code>表达式.
反复调用生成器函数可以产生一系列的值. 调用生成器函数, 函数体不会执行,
而是返回一个生成器. 然后当我满按照迭代器的使用, 遍历其成员的时候,
生成器的<code>__next__()</code>方法通过执行生成器函数的函数体来产生一系列值.</p>
<p>下面的代码是一个generator, 可见其符合迭代器协议.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def generator_fun():</span><br><span class="line">    i = 0</span><br><span class="line">    while True:</span><br><span class="line">        yield i</span><br><span class="line">        if i &gt;= 5:</span><br><span class="line">            return</span><br><span class="line">        i += 1</span><br><span class="line"></span><br><span class="line">generator = generator_fun()</span><br><span class="line">print(hasattr(generator, &#x27;__iter__&#x27;)) #True</span><br><span class="line">print(hasattr(generator, &#x27;__next__&#x27;)) #True</span><br><span class="line">for i in generator:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h2 id="转化">转化</h2>
<p>iterator转化为sequence可以通过类似于<code>list(obj)</code>或者推导式(comprehension)来实现.
sequence转为为iterator可以通过<code>iter(obj)</code>来实现.</p>
<h2 id="总结">总结</h2>
<ul>
<li>iterable是可以放在for语句里的对象.也可以定义为可以传递给<code>iter()</code>的对象.</li>
<li>iterable可以通过iter(obj)转化为iterator</li>
<li>iterable包含两类iterator和sequence</li>
<li>sequence要符合sequence protocol,
即含有<code>__getitem__()</code>和<code>__len__()</code>方法,
可整数索引.</li>
<li>iterator要符合iterator protocol,
即含有<code>__next__()</code>和<code>__iter__()</code>方法</li>
<li>generator是一种特殊的iterator, 调用含有yield语句的generator
function(生成器函数), 将返回一个generator.</li>
</ul>
<h2 id="专有名词翻译">专有名词翻译</h2>
<table>
<thead>
<tr class="header">
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>comprehension</td>
<td>推导式</td>
</tr>
<tr class="even">
<td>generator</td>
<td>生成器</td>
</tr>
<tr class="odd">
<td>generator function</td>
<td>生成器函数</td>
</tr>
<tr class="even">
<td>generator iterator</td>
<td>生成器迭代器</td>
</tr>
<tr class="odd">
<td>iterable</td>
<td>可迭代对象(可遍历对象)</td>
</tr>
<tr class="even">
<td>iterator</td>
<td>迭代器</td>
</tr>
<tr class="odd">
<td>sequence</td>
<td>序列(队列)</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>iterable</tag>
        <tag>iterator</tag>
        <tag>generator</tag>
        <tag>sequence</tag>
      </tags>
  </entry>
  <entry>
    <title>python name binding and resolution</title>
    <url>//b3fc01a3/</url>
    <content><![CDATA[<p>这篇主要是翻译了一些官方文档<a href="https://docs.python.org/3/reference/executionmodel.html">The
Python Language Reference第四章</a>的干货,
加入一些自己理解的形象化描述以及一些例子代码.
写这篇的原因是工作原因做了一个从把VBScript转换成Python的工具,
需要复习一遍python的一些基础知识.</p>
<span id="more"></span>
<h1 id="干货">干货</h1>
<ol type="1">
<li>七种代码块</li>
<li>七种绑定方法</li>
<li>一旦在代码块中给名字绑定对象,
那么该代码块中出现的这个名字(即便在绑定之前)都被视为是本地变量.
除非用<code>global</code>或者<code>nonlocal</code>解除这种限制.</li>
<li>如果名字出现的代码块里没有绑定该名字,
则逐层到外层代码块中寻找绑定.</li>
<li>有一个例外, 就是类, 在类方法中使用的没有绑定的变量,
将直接到全局名字空间中查找,
而不是到最接近的外层代码块(类定义本身的名字空间)查找.
类定义的名字空间将变为类的属性字典</li>
</ol>
<h1 id="执行模型-execution-model">4. 执行模型 (Execution model)</h1>
<h2 id="程序的结构">4.1. 程序的结构</h2>
<p>概念: <strong>代码块</strong> (Code Block)</p>
<p><strong>代码块</strong>是指能够作为执行单元的python的程序片段.
Python程序是由<strong>代码块</strong>构建的. 具体的讲,
只有下面列出的这七种代码块:</p>
<ol type="1">
<li>模块 module (也叫顶级代码块,top level code block),
包括通过解释器参数<code>-m</code>执行作为顶级脚本的模块(即<code>__main__</code>模块)</li>
<li>函数体</li>
<li>类定义</li>
<li>在交互模式下输入的每一个命令</li>
<li>输入给解释器的脚本文件(script file)</li>
<li>通过解释器参数<code>-c</code>输入给解释器的脚本命令(script
command)</li>
<li>输入给<code>eval()</code>和<code>exec()</code>的字符串参数里的代码.</li>
</ol>
<h2 id="名字和名字的绑定naming-and-binding">4.2. 名字和名字的绑定(Naming
and binding)</h2>
<h3 id="名字的绑定binding-or-names">4.2.1 名字的绑定(Binding or
names)</h3>
<p>概念: <strong>名字</strong>, <strong>绑定</strong></p>
<p>python的一个基本抽象是对象(object),
python里除了名字以外的所有的东西都是一种对象.
<strong>名字</strong>就是对象的引用.
代码里的每个名字是通过一个叫<strong>名字绑定</strong>操作的代码行为导入的.</p>
<p>{% blockquote %} 可以把名字理解为给python里的对象贴上的标签.
贴标签这个动作就叫做名字的<strong>绑定</strong>. {% endblockquote %}</p>
<p>python里所有的名字绑定操作也只有下面这七种:</p>
<ol type="1">
<li>函数形参</li>
<li><code>import</code>语句</li>
<li>类和函数的定义(绑定类或者函数名字到定义的代码块对象)</li>
<li>赋值语句, 当赋值目标如果是一个标识符(identifier)</li>
<li><code>for</code>语句里的目标(包括推导式(comprehension))</li>
<li><code>with</code>语句或者<code>except</code>语句里的<code>as</code>.</li>
<li><code>from ... import *</code>语句将绑定除了以下划线开头的所有导入模块的名字.
(仅能在顶级代码块中使用)</li>
</ol>
<p>反向操作是<code>del</code>语句.</p>
<p>{% quote %} <code>del</code>语句相当于把标签从对象上撕下来. {%
endquote %}</p>
<p>概念: <strong>变量</strong>(variable), <strong>本地变量</strong>,
<strong>全局变量</strong>, <strong>自由变量</strong></p>
<p>名字也叫做<strong>变量</strong>,
绑定也可以叫做对变量的<strong>定义</strong>(define).
如果一个名字在一个代码块中被绑定,
除非被声明为<code>nonlocal</code>或者<code>global</code>,
这个名字将成为代码块的<strong>本地变量</strong>(local variable).
那么发生在一个代码块中的名字绑定也叫做一个变量在该代码块中被定义.
模块(module)代码块中绑定的变量既是顶级代码块的本地变量也可以叫做<strong>全局变量</strong>(global
variable). 如果一个变量在代码块中被用到但是没有在该代码块中被定义,
这个变量被叫做<strong>自由变量</strong>(free variable).</p>
<p>一段程序脚本中出现的每一个名字将使用下面的解析规则来确定该名字的绑定对象.</p>
<h3 id="名字的解析-resolution-of-names">4.2.2. 名字的解析 resolution of
names</h3>
<p>{% quote %}
名字的<strong>解析</strong>的意思就是通过一个标准的过程分析出在程序代码中出现的任何一个名字所引用的对象.
{% endquote %}</p>
<p>概念: 变量的<strong>可见范围</strong>(scope).</p>
<p>可见范围定义了在一个代码块里一个名字的可见性.</p>
<p>{% quote %} 我理解,
所有使用一个名字能够正确被解析的语句可以被理解为看见这个名字,
即这个名字对于该语句是可见的. 所以可见范围可以理解为,
所有可以看见这个名字的代码. {% endquote %}</p>
<p>如果一个代码块内定义了一个本地变量,
那么这个变量的可见范围就是这个代码块. 如果定义发生在一个函数代码块中,
可见范围会包括被包含在该函数代码块中的其他代码块,
除非里面的代码块重新绑定这个名字到不同的对象.
比如函数的本地变量对函数内部定义的其他函数和类是可见的,
除非内部的函数又给这个变量赋值. (注意相对于函数代码块,
类代码块使用不同的规则, 后面会介绍)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>  x = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;inner=&#x27;</span>+<span class="built_in">str</span>(x))</span><br><span class="line"><span class="meta">... </span>  inner()</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(<span class="string">&#x27;outer=&#x27;</span>+<span class="built_in">str</span>(x))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">inner=<span class="number">2</span></span><br><span class="line">outer=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>{% quote %} 可见范围前面的定语只能是名字,
一个名字可以有多个嵌套的可见范围.
每个可见范围里该名字可以绑定到不同的对象. {% endquote %}</p>
<p>有了以上这些概念, 就很容易定义<strong>解析</strong>的程序了.
当一个代码块中某条语句使用了一个名字,
这个名字将被解析为最包括这个语句的这个名字的最小可视范围里的绑定.</p>
<p>概念: 代码块的<strong>环境</strong>(environment)</p>
<p>对一个代码块来说,
所有对其可见的可见范围(包含该代码块的含有名字绑定的其他代码块)的集合叫做该代码块的环境.</p>
<p>{% quote %} 代码块的环境就是代码块所有可用的名字. 注意, 由于像if语句,
for语句内部的语句不构成代码块.
在其内部绑定的名字的可视范围是包含该if语句或者for语句的代码块. {%
endquote %}</p>
<p>当一个名字在所有可见范围内都找不到绑定, 那么对其解析失败.
一个<code>NameError</code>异常将被引发. 如果在函数中含有一个名字的绑定,
使该名字成为一个本地变量. 但是用该变量的语句在绑定之前,
那么<code>NameError</code>异常的一个子类<code>UnboundLocalError</code>异常将被引发.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span>  a = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> test</span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;a&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>如果一个名字的绑定操作发生在一个代码块的任何位置,
在该代码块中所有对这个名字的使用都将被视作对当前块的引用
(这句话我理解就是名字被视作当前块的局部变量).
因此在绑定名称之前在块中使用名称时, 这可能导致错误. 这个规则很微妙.
Python缺少声明, 并且允许名称绑定操作发生在代码块内的任何位置.
可以通过扫描代码块的整个文本寻找名称绑定操作来确定代码块的局部变量。</p>
<p>概念: 名字空间(namespace).</p>
<p>在一个代码块内绑定的所有名字的集合叫代码块的名字空间.</p>
<p>全局名字空间(global namespace)是在一个包含当前代码块的模块的名字空间.
内建名字空间(builtins namespace),
是指模块<code>builtins</code>的全局名字空间. 顶级名字空间(top-level
namespace)是指全局名字空间和内建名字空间的合集,
全局名字空间具有更高优先级.</p>
<p>在一个代码块里使用<code>global</code>语句声明的名字,
将被视为全局变量, 在顶级名字空间中寻找绑定.
<code>global</code>语句跟同一个代码块中的绑定操作具有相同的可见范围,
所以如果自由变量的最小可视范围内有<code>global</code>语句,
自由变量将没视作全局变量.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span>  a = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> test</span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;a&#x27;</span> referenced before assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">global</span> a</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span>  a = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">global</span> a</span><br><span class="line"><span class="meta">... </span>  test2()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>另一个跟可见范围相关的语句是<code>nonlocal</code>语句,
用其声明的变量将不使用最近函数可见范围内的绑定, 而是用之前的一次绑定.
如果给定的名字没有在任何函数可见范围绑定,
异常<code>SyntaxError</code>将被引发, 即使名字在全局名字空间中绑定.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">nonlocal</span> a</span><br><span class="line">...</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span></span><br><span class="line">SyntaxError: no binding <span class="keyword">for</span> <span class="keyword">nonlocal</span> <span class="string">&#x27;a&#x27;</span> found</span><br></pre></td></tr></table></figure>
<p>模块的名字空间在模块第一次被导入(import)的时候自动创建.
一个脚本的主模块总是被叫做<code>__main__</code>.</p>
<p>名字解析规则的两个特例类定义代码块和作为<code>exec()</code>或者<code>eval()</code>字符串参数的代码块.</p>
<p>先说类定义代码块.
一个例外的规则就是在类定义中使用的没有绑定的本地变量,
将直接到全局名字空间中查找,
而不是像前面描述的规则到最接近的外层可见范围(类定义本身的名字空间)查找.
类定义的名字空间将变为类的属性字典. 因此下面的例子里直接在方法里面使用a,
将会引发<code>NameError</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>  a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.x()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> x</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>还有一点类定义代码块下的名字的可见范围被限制在类定义代码块本身,
而无法像函数代码块那样向下延伸到类方法的代码块.
这也包含推导式(comprehensions)或者生成器(generator),
因为他们本质上就是用函数可见范围来实现的. 例如下面的代码将执行成功:
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>  a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>  b = a</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>  a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>  b = [A.a + i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure></p>
<p>但下面的代码将执行失败: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>    a = <span class="number">42</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="built_in">list</span>(a + i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> A</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p>
<h3 id="内建名字和受限执行">4.2.3. 内建名字和受限执行</h3>
<p><strong>CPython的执行细节</strong>:
Python用户不应该碰<code>__builtins__</code>对象. 这是一个实现细节.
如果确实想要覆盖内建名字空间中的值,
用户应该导入buitins模块并适当修改其attribute.</p>
<p>事实上, 一个代码块关联的内建名字空间,
是通过在该代码块的全局名字空间里查找名字<code>__builtins__</code>来实现的.
这个名字空间应该或者是一个字典, 或者是一个模块(后一种情况,
使用模块的字典). 默认情况下, 在<code>__main__</code>模块里,
<code>__builtins__</code>是内建模块<code>builtins</code>; 在其他模块里,
<code>__builtins__</code>是`builtins模块本身的字典的别名.</p>
<p>file1: main.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> othermodule</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(__name__, __builtins__ <span class="keyword">is</span> builtins))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(__name__, __builtins__ <span class="keyword">is</span> builtins.__dict__))</span><br></pre></td></tr></table></figure></p>
<p>file2: othermodule.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(__name__, __builtins__ <span class="keyword">is</span> builtins))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(__name__, __builtins__ <span class="keyword">is</span> builtins.__dict__))</span><br></pre></td></tr></table></figure></p>
<p>执行main.py可以得到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">othermodule:False</span><br><span class="line">othermodule:True</span><br><span class="line">__main__:True</span><br><span class="line">__main__:False</span><br></pre></td></tr></table></figure>
<h3 id="与动态特性的交互">4.2.4. 与动态特性的交互</h3>
<p>自由变量的名字解析在运行时发生, 而不是编译时.</p>
<p>导致<code>eval()</code>和<code>exec()</code>函数无权访问用于解析名子的完整环境.
名字仅可能在调用者的局部名字空间或者全局名字空间里解析.
自由变量并不是在最小可视范围内解析, 而是在全局变量里解析.
这两个函数都可以通过可选的参数来覆盖全局和局部名字空间.
如果只设置一个名字空间, 全局和局部都使用该名字空间.</p>
<h2 id="异常exceptions">4.3. 异常(Exceptions)</h2>
<p>异常是一个打破代码块正常控制流的方法, 以便处理错误或其他特殊情况.
在检测到错误的地方引发了异常; 它可以由周围的代码块来处理,
也可以由直接或间接调用发生错误的代码块的代码块来处理。</p>
<p>Python解释器在检测到运行时错误（例如除以零）时会引发异常.
Python程序还可以使用<code>raise</code>语句显式引发异常.
异常处理程序通过<code>try...except</code>语句指定.
语句的<code>finally</code>子语句可用于指定清理代码.
该子语句不会处理异常, 无论先前代码中是否发生异常,
该清理代码都会执行.</p>
<p>Python使用错误处理的模型是"终结"(termination)模型:
即异常处理程序可以找出发生了什么并继续在外部执行,
但是它无法修复错误并重试失败的操作(除非重新输入有问题的代码的顶部).</p>
<p>当根本没有处理异常时, 解释器终止程序的执行, 或返回其交互式主循环.
在这两种情况下, 除非异常为SystemExit, 否则它将打印堆栈回溯.</p>
<p>异常由类实例标识. 根据实例的类来选择except子语句:
except子语句必须引用实例的类或其基类. 该实例可以被异常处理程序接收,
并且可以携带有关异常条件的其他信息。</p>
<p>注意: 异常消息(Exception messages)不是Python API的一部分.
当Python版本更新, 它们的内容可能会在没有警告的情况下改变.
将在多个版本的解释器下运行的代码不应该依赖于异常消息.</p>
<h2 id="专有名词翻译">专有名词翻译</h2>
<table>
<thead>
<tr class="header">
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>attributes</td>
<td>属性(翻译与property无法区分, 直接使用英文)</td>
</tr>
<tr class="even">
<td>builtin</td>
<td>内建</td>
</tr>
<tr class="odd">
<td>clause</td>
<td>子语句</td>
</tr>
<tr class="even">
<td>code block/block</td>
<td>代码块</td>
</tr>
<tr class="odd">
<td>comprehension</td>
<td>推导式</td>
</tr>
<tr class="even">
<td>generator</td>
<td>生成器</td>
</tr>
<tr class="odd">
<td>identifier</td>
<td>标识符</td>
</tr>
<tr class="even">
<td>import</td>
<td>导入</td>
</tr>
<tr class="odd">
<td>namespace</td>
<td>名字空间</td>
</tr>
<tr class="even">
<td>module</td>
<td>模块</td>
</tr>
<tr class="odd">
<td>model</td>
<td>模型</td>
</tr>
<tr class="even">
<td>object</td>
<td>对象</td>
</tr>
<tr class="odd">
<td>scope</td>
<td>可见范围</td>
</tr>
<tr class="even">
<td>top-level</td>
<td>顶级</td>
</tr>
<tr class="odd">
<td>variable</td>
<td>变量</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>name-resolution</tag>
      </tags>
  </entry>
  <entry>
    <title>Gvim和Neovim共享配置安装 - Windows篇</title>
    <url>//e6b373ae/</url>
    <content><![CDATA[<p>装一台新电脑,
想把Gvim或者Neovim的所有相关软件都安装得跟以前一样还真是有很多坑.
记录一下以方便按图索骥. 目标是同一套配置可以使用在两个编辑器上.
现在Neovim的开发明显更活跃, 长期看将来是要转到Neovim上.
但现在Neovim还是有bug. 所以两个换着用直到Neovim明显超出Gvim的那一天.</p>
<span id="more"></span>
<h2 id="windows下安装.">Windows下安装.</h2>
<h3 id="下载软件.">下载软件.</h3>
<p>先安装git, python3, python3的具体版本需要跟Gvim的匹配.</p>
<p>需要下载下列软件,
解压到<code>C:\Users\%USERNAME%\AppData\Local\Programs</code>,
确保所有可执行文件所在目录都被设置在系统变量Path里.</p>
<ol type="1">
<li><strong>gvim</strong>, 下载地址:<a href="https://github.com/vim/vim-win32-installer/releases">https://github.com/vim/vim-win32-installer/releases</a>.
下载最新版的zip包. 注意看gvim依赖的python版本. (这里没有直接使用安装包,
如果用安装包, 下面的右键菜单操作需要删除gvim的部分.)</li>
<li><strong>Neovim</strong>, 下载地址:<a href="https://github.com/neovim/neovim/releases/">https://github.com/neovim/neovim/releases/</a>,
下载最新nightly版zip包.</li>
<li><strong>ripgrep</strong>, 下载地址:<a href="https://github.com/BurntSushi/ripgrep/releases">https://github.com/BurntSushi/ripgrep/releases</a>.
也可以通过<a href="https://chocolatey.org/">chocolatey</a>来安装.</li>
<li><strong>Universal Ctags</strong>, 下载地址:<a href="https://github.com/universal-ctags/ctags-win32/releases">https://github.com/universal-ctags/ctags-win32/releases</a>.</li>
<li><strong>gtags</strong>, 下载地址: <a href="https://www.gnu.org/software/global/download.html">https://www.gnu.org/software/global/download.html</a>.</li>
</ol>
<p>使用下面这个registry文件, 把Gvim和Neovim都加到右键菜单里:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\gvim]</span><br><span class="line">@=&quot;Edit with Gvim&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\vim\\vim82\\gvim.exe\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\gvim\command]</span><br><span class="line">@=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\vim\\vim82\\gvim.exe\&quot; \&quot;%1\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\gvim]</span><br><span class="line">@=&quot;Open Gvim Here&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\vim\\vim82\\gvim.exe\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\gvim\command]</span><br><span class="line">@=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\vim\\vim82\\gvim.exe\&quot; \&quot;%1\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\gvim]</span><br><span class="line">@=&quot;Open Gvim here&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\vim\\vim82\\gvim.exe\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\gvim\command]</span><br><span class="line">@=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\vim\\vim82\\gvim.exe\&quot; \&quot;%v\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\nvim-qt]</span><br><span class="line">@=&quot;Edit with Neovim&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Neovim\\bin\\nvim-qt.exe\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\nvim-qt\command]</span><br><span class="line">@=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Neovim\\bin\\nvim-qt.exe\&quot; \&quot;%1\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\nvim-qt]</span><br><span class="line">@=&quot;Open Neovim Here&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Neovim\\bin\\nvim-qt.exe\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\nvim-qt\command]</span><br><span class="line">@=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Neovim\\bin\\nvim-qt.exe\&quot; \&quot;%1\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\nvim-qt]</span><br><span class="line">@=&quot;Open Neovim here&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Neovim\\bin\\nvim-qt.exe\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\nvim-qt\command]</span><br><span class="line">@=&quot;\&quot;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Neovim\\bin\\nvim-qt.exe\&quot; \&quot;%v\&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="下载字体">下载字体</h4>
<p>我一直使用<a href="https://github.com/FuDesign2008/randomTheme.vim">randomTheme.vim</a>,
使每个打开的窗口的配色和字体不一样. 一个是带来新鲜感避免视觉疲劳,
一个是方便区分各个窗口打开的是什么.
randomTheme.vim本身提供一些适合编程的字体:</p>
<ol type="1">
<li>Cascadia.ttf</li>
<li>Consolas.ttf</li>
<li>dejavu-fonts-ttf-2.37</li>
<li>FiraCode_2</li>
<li>Inconsolata</li>
<li>JetBrainsMono-1.0.3</li>
<li>SourceCodePro</li>
<li>Ubuntu_Mono</li>
</ol>
<p>我还要下载两个:</p>
<ol start="9" type="1">
<li><a href="http://www.fonts101.com/fonts/view/Uncategorized/51239/Monaco.aspx">Monaco</a></li>
<li><a href="https://dejavu-fonts.github.io/Download.html">DejaVu</a></li>
</ol>
<p>右键菜单选择安装即可.</p>
<h3 id="配置">配置</h3>
<h4 id="配置目录">配置目录</h4>
<p>为了使Gvim和Neovim共享一套配置.
配置文件一概使用Neovim的配置目录<code>C:\Users\%USERNAME%\AppData\Local\nvim</code>,
其中的配置文件有<code>init.vim</code>和<code>ginit.vim</code>.
然后通过下列命令为Gvim创建配置文件的符号链接.</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">mklink C:\Users\<span class="variable">%USERNAME%</span>\_vimrc C:\Users\<span class="variable">%USERNAME%</span>\AppData\Local\nvim\init.vim</span><br><span class="line">mklink /D C:\Users\<span class="variable">%USERNAME%</span>\vimfiles C:\Users\<span class="variable">%USERNAME%</span>\AppData\Local\nvim</span><br></pre></td></tr></table></figure>
<p>其中<code>init.vim</code>, 我自己一直维护在github私库里.</p>
<p>这里重点说一下Neovim和Gvim配置上有区别的几个地方, 以及如何统一:</p>
<ol type="1">
<li>标准路径: Neovim提供了一种方式访问标准路径,
参考<code>help stdpath</code>. 所以配置<code>init.vim</code>,
使Gvim也使用这些路径. 下面列出跟此相关的一些配置:</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:cachedir</span> = <span class="built_in">expand</span>(stdpath(<span class="string">&#x27;cache&#x27;</span>))</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:configdir</span> = <span class="built_in">expand</span>(stdpath(<span class="string">&#x27;config&#x27;</span>))</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:datadir</span> = <span class="built_in">expand</span>(stdpath(<span class="string">&#x27;data&#x27;</span>))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">&quot;vim will share same folder with nvim</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;win32&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:cachedir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/Temp/nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:configdir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:datadir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/nvim-data&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:cachedir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.cache/nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:configdir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.config/nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:datadir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.local/share/nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="variable">s:configdir</span>. <span class="string">&#x27;/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;some plugins&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !has(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:vimswap</span> = <span class="built_in">expand</span>(<span class="variable">s:datadir</span> . <span class="string">&#x27;/swap&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> !isdirectory(<span class="variable">s:vimswap</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">mkdir</span>(<span class="variable">s:vimswap</span>, <span class="string">&quot;p&quot;</span>, <span class="number">0700</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">let</span> &amp;dir=<span class="variable">s:vimswap</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&quot;persistent_undo&quot;</span>)</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s:undo_path</span> = <span class="built_in">expand</span>(<span class="variable">s:configdir</span> . <span class="string">&#x27;/undo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">&quot; create the directory and any parent directories</span></span><br><span class="line">    <span class="comment">&quot; if the location does not exist.</span></span><br><span class="line">    <span class="keyword">if</span> !isdirectory(<span class="variable">s:undo_path</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">mkdir</span>(<span class="variable">s:undo_path</span>, <span class="string">&quot;p&quot;</span>, <span class="number">0700</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !has(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> &amp;undodir=<span class="variable">s:undo_path</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="comment">&quot;Create file which contains undo information so you can undo previous actions even</span></span><br><span class="line">    <span class="comment">&quot;after you close and reopen a file.</span></span><br><span class="line">    <span class="keyword">set</span> <span class="built_in">undofile</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_CacheDirectory</span> = <span class="variable">s:cachedir</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>Python相关, 我使用的几个插件要用python,
Gvim和Neovim在Python支持上完全不同. 这里只说Python3.</p>
<ul>
<li>Gvim首先要求编译时有+Python3/dyn特性,
即至此动态链接(静态我在linux式了一下不成功, windows安装包也不提供静态).
然后需要设置pythonthreehome和pythonthreedll两个option.
最后linux上vim内Python的sys.path跟外面还不一样,
所以需要设置PYTHONHOME和PYTHONPATH环境变量.
配置完了需要自己用<code>:py3 print("hello world")</code>试试.</li>
<li>Neovim, 设置g:python3_host_prog全局变量,
用<code>:checkhealth</code>命令检查.</li>
</ul></li>
</ol>
<p>以下是我的配置: <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;win32&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g:python3_host_prog</span>=<span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/Programs/Python/Python39/python.exe&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span> $PYTHONHOME=<span class="string">&#x27;/usr/local/bin&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> $PYTHONPATH=<span class="string">&#x27;/usr/local/lib/python39.zip:/usr/local/lib/python3.9:/usr/local/lib/python3.9/lib-dynload:/home/honeywell/.local/lib/python3.9/site-packages:/usr/local/lib/python3.9/site-packages&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g:python3_host_prog</span>=<span class="string">&#x27;/bin/python3&#x27;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;win32&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> &amp;pythonthreehome=<span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/Programs/Python/Python39&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> &amp;pythonthreedll=<span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/Programs/Python/Python39/python39.dll&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span> $PYTHONHOME=<span class="string">&#x27;/usr/local/bin&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> $PYTHONPATH=<span class="string">&#x27;/usr/local/lib/python39.zip:/usr/local/lib/python3.9:/usr/local/lib/python3.9/lib-dynload:/home/honeywell/.local/lib/python3.9/site-packages:/usr/local/lib/python3.9/site-packages&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> &amp;pythonthreehome=<span class="built_in">expand</span>(<span class="string">&#x27;/bin&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> &amp;pythonthreedll=<span class="built_in">expand</span>(<span class="string">&#x27;/usr/local/lib/libpython3.9.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>有很多选项Neovim无需配置, Gvim需要配置, 我列出一些:</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot;only for vim</span></span><br><span class="line"><span class="keyword">if</span> !has(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span></span><br><span class="line">    <span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line">    <span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line">    <span class="keyword">set</span> backspace=<span class="built_in">indent</span>,eol,start</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:vimswap</span> = <span class="built_in">expand</span>(<span class="variable">s:datadir</span> . <span class="string">&#x27;/swap&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> !isdirectory(<span class="variable">s:vimswap</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">mkdir</span>(<span class="variable">s:vimswap</span>, <span class="string">&quot;p&quot;</span>, <span class="number">0700</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">let</span> &amp;dir=<span class="variable">s:vimswap</span></span><br><span class="line">    <span class="comment">&quot;Completion mode setting</span></span><br><span class="line">    <span class="keyword">set</span> wildmenu</span><br><span class="line">    <span class="keyword">set</span> wildmode=full</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> incsearch</span><br><span class="line">    <span class="keyword">set</span> hlsearch</span><br><span class="line"></span><br><span class="line">    <span class="comment">&quot; Toggle Menu and Toolbar</span></span><br><span class="line">    <span class="comment">&quot; @see http://liyanrui.is-programmer.com/articles/1791/gvim-menu-and-toolbar-toggle.html</span></span><br><span class="line">    <span class="keyword">set</span> guioptions+=<span class="keyword">b</span></span><br><span class="line">    <span class="keyword">set</span> guioptions-=<span class="keyword">m</span></span><br><span class="line">    <span class="keyword">set</span> guioptions-=T</span><br><span class="line">    <span class="keyword">map</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;C-F12&gt;</span> :<span class="keyword">if</span> &amp;guioptions =~# <span class="string">&#x27;T&#x27;</span> <span class="symbol">&lt;Bar&gt;</span></span><br><span class="line">           \<span class="keyword">set</span> guioptions-=T <span class="symbol">&lt;Bar&gt;</span></span><br><span class="line">           \<span class="keyword">set</span> guioptions-=<span class="keyword">m</span> <span class="symbol">&lt;bar&gt;</span></span><br><span class="line">       \<span class="keyword">else</span> <span class="symbol">&lt;Bar&gt;</span></span><br><span class="line">           \<span class="keyword">set</span> guioptions+=T <span class="symbol">&lt;Bar&gt;</span></span><br><span class="line">           \<span class="keyword">set</span> guioptions+=<span class="keyword">m</span> <span class="symbol">&lt;Bar&gt;</span></span><br><span class="line">       \<span class="keyword">endif</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h4 id="插件安装">插件安装</h4>
<p>安装其他插件之前需要先下载插件管理器, 我选了下面这款:</p>
<p><a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim">plug.vim</a></p>
<p>放在<code>C:\Users\%USERNAME%\AppData\Local\nvim\autoload</code>下面</p>
<p>打开Neovim或者Gvim, 运行<code>:PlugInstall</code>.
以下是我现在在用的兼容Neovim和Gvim的插件. (只有一个不兼容, 下节介绍)
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="variable">s:configdir</span>. <span class="string">&#x27;/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;scrooloose/nerdTree&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;FuDesign2008/randomTheme.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;flazz/vim-colorschemes&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;tpope/vim-surround&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;easymotion/vim-easymotion&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;Yggdroot/LeaderF&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;Yggdroot/LeaderF&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;.\install.bat&#x27;</span> &#125;</span><br><span class="line">Plug <span class="string">&#x27;ludovicchabant/vim-gutentags&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;skywind3000/gutentags_plus&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;octol/vim-cpp-enhanced-highlight&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: &#123; -&gt; fzf#install() &#125; &#125;</span><br><span class="line">Plug <span class="string">&#x27;junegunn/fzf.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdcommenter&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;junegunn/vim-easy-align&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;dimasg/vim-mark&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;andymass/vim-matchup&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;kshenoy/vim-signature&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;terryma/vim-expand-region&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;jeetsukumaran/vim-indentwise&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;will133/vim-dirdiff&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;neoclide/coc.nvim&#x27;</span>, &#123;<span class="string">&#x27;branch&#x27;</span>: <span class="string">&#x27;release&#x27;</span>&#125;</span><br><span class="line">Plug <span class="string">&#x27;skywind3000/vim-quickui&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mbbill/undotree&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mhinz/vim-signify&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure></p>
<h4 id="vim插件修改">Vim插件修改</h4>
<p><code>RandomTheme.vim</code>插件不支持Neovim的启动,
原因是<code>Neovim</code>的GUI机制跟<code>Gvim</code>不一样,
<code>init.vim</code>是在GUI之前加载的,
所以提供了另一个配置文件<code>ginit.vim</code>来配置GUI.
修改<code>plugged\randomTheme.vim\plugin\randomtheme.vim</code>里的函数<code>s:SetFont</code>成:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function!</span> <span class="title">s</span>:SetGuiFont<span class="params">(guifont)</span></span><br><span class="line">    <span class="keyword">let</span> splitted = <span class="keyword">split</span>(<span class="variable">a:guifont</span>, <span class="string">&#x27;:h&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(splitted) != <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">let</span> font = splitted[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> size = splitted[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;x11&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g:favorite_gui_font</span> = font . <span class="string">&#x27;\ &#x27;</span> . size</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g:favorite_gui_font</span> = font . <span class="string">&#x27;:h&#x27;</span> . size</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;gui_running&#x27;</span>)</span><br><span class="line">        <span class="comment">&quot; for ubuntu vim-gonme</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;x11&#x27;</span>)</span><br><span class="line">            <span class="keyword">let</span> commandStr = <span class="string">&#x27;set guifont=&#x27;</span> . font . <span class="string">&#x27;\ &#x27;</span> . size</span><br><span class="line">            <span class="keyword">execute</span> commandStr</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">let</span> commandStr = <span class="string">&#x27;set guifont=&#x27;</span> . font . <span class="string">&#x27;:h&#x27;</span> . size</span><br><span class="line">            <span class="keyword">execute</span> commandStr</span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>) &amp;&amp; <span class="built_in">exists</span>(<span class="string">&#x27;g:GuiLoaded&#x27;</span>)</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">g:favorite_gui_font</span></span><br><span class="line">        <span class="keyword">execute</span> <span class="string">&#x27;:GuiFont! &#x27;</span> . <span class="variable">g:favorite_gui_font</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>然后再在<code>ginit.vim</code>里加下面一句话:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">execute</span> <span class="string">&#x27;:GuiFont! &#x27;</span> . <span class="variable">g:favorite_gui_font</span></span><br></pre></td></tr></table></figure>
<p>可以windows上完美适配NeoVim.</p>
<p>这个问题我提交给<code>randomTheme.vim</code>作者, 在<a href="https://github.com/FuDesign2008/randomTheme.vim/issues/7">issue#7</a>里.</p>
<h4 id="python插件安装">Python插件安装</h4>
<p>下面两个Python插件需要安装 1. <a href="https://github.com/neovim/pynvim">pynvim</a>, nvim的Python支持. 2.
<a href="https://pygments.org/">Pygments</a>, gtags只支持6种语言,
其他语言的tags需要这个工具.</p>
<p>使用<code>pip</code>直接安装就可以了. <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">pip install neovim</span><br><span class="line">pip install Pygments</span><br></pre></td></tr></table></figure></p>
<h4 id="其他依赖">其他依赖</h4>
<p>为满足插件COC的依赖, 需要额外安装javascript环境<a href="nodejs.org">node.js</a>, 注意也要安装neovim的插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install neovim</span><br></pre></td></tr></table></figure>
<h2 id="linux下安装">Linux下安装</h2>
<p>Linux下安装的复杂程度高一些, 而且不同发布版安装也不一样,
回头再写一篇Linux的.</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim标签系统</title>
    <url>//88014cac/</url>
    <content><![CDATA[<p>vim在代码间跳转的默认配置就是标签(tags)系统.</p>
<h2 id="标签系统">标签系统</h2>
<p>可以通过<code>:h tags</code>, 查看vim官方文档.</p>
<h3 id="跟标签相关的几个概念">跟标签相关的几个概念</h3>
<span id="more"></span>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>标签(tag)</td>
<td>在标签文件里的一个标识符, 可以用来跳转,
比如一个文件名或者变量名.</td>
</tr>
<tr class="even">
<td>标签文件(tags file)</td>
<td>由第三方程序生成的含有一系列标签的外部文件.
这个第三方程序通常是ctags.</td>
</tr>
<tr class="odd">
<td>标签栈(tag stack)</td>
<td>一系列跳转按照时间顺序形成的栈. 注意这里要跟跳转列表(jump
list)区分开. 前者仅仅是标签跳转的位置列表, 后者是前者的超集,
包括所有的vim motion命令的跳转结果.</td>
</tr>
<tr class="even">
<td>标签匹配表(Tag match list)</td>
<td>当标签文件里出现多个匹配的标签时,
这些标签会按照优先级组织成一张列表.</td>
</tr>
<tr class="odd">
<td>预览窗口(Preview window)</td>
<td>这是一个每个tab页只能有一个的特殊窗口, 通常比较小,
用来预览其他文件里的标签定义.</td>
</tr>
</tbody>
</table>
<h3 id="跟标签相关的常用命令">跟标签相关的常用命令</h3>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 29%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:ta[g] &#123;name&#125;</code></td>
<td><code>CTRL-]</code></td>
<td>跳转到光标所在处的关键词的定义的位置</td>
</tr>
<tr class="even">
<td><code>:[count]po[p]</code></td>
<td><code>CTRL-T</code></td>
<td>在标签栈里向更老的位置跳转</td>
</tr>
<tr class="odd">
<td><code>:[count]ta[g]</code></td>
<td></td>
<td>在标签栈里向更新的位置跳转</td>
</tr>
<tr class="even">
<td><code>:tags</code></td>
<td></td>
<td>显示整个标签栈的内容,
标有<code>&gt;</code>的是下一个tag命令要跳转的标签,
所以当前显示的内容是&gt;行的上一行.</td>
</tr>
<tr class="odd">
<td><code>:ts[elect] [name]</code></td>
<td><code>g]</code></td>
<td>不直接跳转, 而是给出匹配表让用户选择.</td>
</tr>
<tr class="even">
<td><code>:tj[ump] [name]</code></td>
<td><code>g CTRL-]</code></td>
<td>如果只有一个匹配直接跳转, 如果多个匹配, 列出列表.</td>
</tr>
<tr class="odd">
<td><code>:tn, :tp, :tr, :tl</code></td>
<td></td>
<td>在匹配表中前后跳转</td>
</tr>
<tr class="even">
<td><code>:pta[g]</code></td>
<td><code>CTRL-W &#125;</code></td>
<td>在预览窗口里显示光标所在处关键词的定义</td>
</tr>
<tr class="odd">
<td><code>:pp[op]</code></td>
<td></td>
<td>等于:pop, 在标签栈里向更老的位置跳转, 但结果显示在预览窗口里.</td>
</tr>
<tr class="even">
<td><code>:pts[elect] [name]</code></td>
<td></td>
<td>等于 <code>:tselect</code>, 但结果显示在预览窗口</td>
</tr>
<tr class="odd">
<td><code>:ptj[ump]</code></td>
<td><code>CTRL-W g&#125;</code></td>
<td>等于<code>:tjump</code> 但结果显示在预览窗口</td>
</tr>
<tr class="even">
<td><code>:ptn, :ptp, :ptr, :ptl</code></td>
<td></td>
<td>在匹配表中前后跳转, 结果显示在预览窗口</td>
</tr>
<tr class="odd">
<td><code>:pc[lose]</code></td>
<td><code>CTRL-W z</code></td>
<td>关闭预览窗口</td>
</tr>
<tr class="even">
<td><code>:sta[g] [name]</code></td>
<td><code>CTRL-W ]</code></td>
<td>等于<code>:tag</code>, 但结果在分裂(split)的窗口中显示</td>
</tr>
<tr class="odd">
<td></td>
<td><code>CTRL-W g]</code></td>
<td>等于<code>:tselect</code>, 但结果在分裂(split)的窗口中显示</td>
</tr>
<tr class="even">
<td></td>
<td><code>CTRL-W g CTRL-]</code></td>
<td>等于<code>:tjump</code>, 但结果在分裂(split)的窗口中显示</td>
</tr>
</tbody>
</table>
<h2 id="标签文件结构">标签文件结构</h2>
<p>这个可以用<code>:h ctags</code>看vim官方文档. 这个话题很复杂,
将来有机会慢慢研究</p>
<h2 id="标签生成工具">标签生成工具</h2>
<p>用<a href="https://ctags.io/">Universal CTags</a>代替<a href="http://ctags.sourceforge.net/">Exuberant Ctags</a>,
后者已经停止开发多年.</p>
<h2 id="插件">插件</h2>
<p>使用插件<a href="https://github.com/ludovicchabant/vim-gutentags">gutentags</a>.
这个插件几乎让ctags的标签文件变得对用户不可见,
完全不用操心生成标签文件的事情.</p>
<h2 id="参考">参考</h2>
<p>skywind的<a href="http://www.skywind.me/blog/archives/2084">Vim 8 下
C/C++ 开发环境搭建</a></p>
<p>返回<a href="/3254a4b3/" title="vim技巧总结">vim技巧总结</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 监控文件是否在vim外部被修改的机制</title>
    <url>//d0cb08b6/</url>
    <content><![CDATA[<p>使用vim或者neovim编辑文件时, 如果文件被外部应用修改,
vim的监控机制是怎样的?</p>
<p>过去用gvim, 每次焦点返回vim时, gvim都会提示我文件修改了是否要重载.
但是换到neovim上就不会提醒了.</p>
<span id="more"></span>
<p>我原来以为是neovim的bug. 研究了一下, 根据<a href="https://github.com/neovim/neovim/issues/1936">issue1936</a>.
实际机制是这样的.</p>
<p>无论是vim还是neovim,
在终端上执行默认都只在save的时候检查打开的文件是否被别人修改了.gvim增加了一个在获得焦点之后自动检查的机制.
neovim由于gui跟terminal分离, 所以不同的gui实现方式不一样,
neovim-qt并没有实现自动检查. 解决方案是在init.vim里加下面两句.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocmd FocusGained * :checktime</span><br><span class="line">set autoread</span><br></pre></td></tr></table></figure>
<p>第一句是在获得焦点事件时自动检查文件时间戳. 如果在vim外被修改,
则提示用户. 可以选择重载或者继续编辑.
第二句的变量是说如果发现文件在vim外被修改, 在vim内没有修改, 则自动重载,
而不是提示用户.</p>
<p>返回<a href="/3254a4b3/" title="vim技巧总结">vim技巧总结</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim plugin介绍之LeaderF</title>
    <url>//dc9af5aa/</url>
    <content><![CDATA[<p>LeaderF现在基本是Vim最好的模糊查找插件.
其基本功能和演示可以参考作者Yggdroot的几篇文章介绍:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/29137923">让人相见恨晚的vim插件：模糊查找神器LeaderF</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53680291">vim 的模糊查找插件
LeaderF 新功能介绍</a></li>
<li><a href="https://github.com/Yggdroot/LeaderF">LeaderF官网</a></li>
</ul>
<p>本文是用来记录个人对工具的理解和学习过程.
记录各种应用场景里如何使用LeaderF, 如何配置.</p>
<h2 id="什么是模糊查找">什么是模糊查找</h2>
<p>模糊查找的应用场景特别常见. 就是在海量信息中查找你想要的信息.</p>
<span id="more"></span>
<p>传统的办法是, 首先你要确定你要找的信息的内容, 然后遍历所有信息,
找到你要的. 比如说,你在一个有上千个文件的文件夹中找到你需要的文件,
首先你需要记住文件名, 然后文件夹中的 文件按照字母顺序排序,
然后你按照字母顺序找到你要的文件.</p>
<p>模糊查找的解决方案是这样的, 你不需要全部记住你要找的信息,
只需要记住里面的一部分, 甚至几个字母.
然后你按照你的记忆敲入你记住的部分,
然后查找软件会把所有匹配上的信息列出来, 你输入的越多, 列出来的越少.
最后知道你看到你要找的信息, 直接选中就行. 这种方法特别符合人性,
机械记忆弱爆(内存少), 但图像记忆特别强. 所以记不住全部,
但一看见就认识.</p>
<p>LeaderF基础功能就是及其快速的模糊查找. 但跟很多别的模糊查找软件不同,
LeaderF对于刚才说的海量信息提供给用户多种选择, 既可以是海量文件,
也可以是海量文本. 后面会介绍各种使用场景, 和配置方法.</p>
<h2 id="文件检索">文件检索 <span id="LeaderF-file"></span></h2>
<p>就是前面说的那个场景, 有一大堆文件,
输入几个字母就可以筛选出少数几个文件, 然后把你想要的那个挑出来.
VIM过去有一个流行的插件叫<a href="https://github.com/kien/ctrlp.vim">CtrlP</a>. 就是实现这个功能.
不过根据作者的说法, 那个插件效率比较差.</p>
<h3 id="快捷键配置">快捷键配置</h3>
<p>只需要设置 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutF</span> = <span class="string">&#x27;&lt;c-p&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
就可以用这个老插件的快捷键Ctrl-P调出查找窗口,
然后输入你记忆中的文件名片段就可以了. 其默认快捷键是<leader>f,
也是这个软件名字的由来, 但是我习惯把这个快捷键map到别的功能上,
只用Ctrl-P.</leader></p>
<h3 id="根目录配置">根目录配置</h3>
<p>但这里还有个问题, 你需要告诉LeaderF到底在哪些目录中查找文件.
这里就需要配置两个全局变量<code>g:Lf_RootMarkers</code>和<code>g:Lf_WorkingDirectoryMode</code>.
前者是告诉LeaderF什么样的目录是你项目的根目录,
后者是告诉LeaderF按照什么规则找根目录. 我一般配置成下面这样:
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WorkingDirectoryMode</span> = <span class="string">&#x27;AF&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_RootMarkers</span> = [<span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.svn&#x27;</span>, <span class="string">&#x27;.hg&#x27;</span>, <span class="string">&#x27;.project&#x27;</span>, <span class="string">&#x27;.root&#x27;</span>]</span><br></pre></td></tr></table></figure> 这个设置的意思是,
如果一个目录含有任何具有list中指定的名字的子目录或者文件,
可以认定其为根目录. 搜索根目录的办法是, 1.
先找当前文件的所有祖先目录里最近的根目录,
如果找到就使用这个根目录为查找起点. (A的含义) 2. 如果没找到任何根目录,
看看当前打开的文件是否在VIM的工作目录(working directory)下,
或者任何其子目录下. 如果是, 就是用工作目录作为查找起点. (F的含义) 3.
如果当前文件不在工作目录和其后代目录下,
则以当前文件所在目录为查找起点.(default)</p>
<p>通常这么配置完了, 如果你工作在任何SCM管理的项目上(比如git,
subversion, hg), 都无需做额外配置,
否则可以自己手动在根目录下建立一个空的.root文件或者.project文件就可以正常使用了</p>
<h3 id="索引方式">索引方式 <span id="LeaderF-file-index"></span></h3>
<p>LeaderF提供给用户3种不同的文件索引方式.</p>
<ol type="1">
<li>如果LeaderF发现根目录是一个git或者hg的仓库(repository),
使用git或者hg作为索引文件的工具. 这个是LeaderF的默认配置.
选项<code>g:Lf_UseVersionControlTool</code>如果被用户设置成<code>0</code>,
则LeaderF不会使用git或者hg.</li>
<li>如果第一条不满足,
即或者选项<code>g:Lf_UseVersionControlTool==0</code>,
或者根目录不是一个git仓库, 或者hg仓库.
则LeaderF会检查是否有配置外部第三方工具.
选项<code>g:Lf_DefaultExternalTool</code>是用来配置这项的.
这个选项可以是'rg', 'pt', 'ag', 'find'之一, 顺序代表优先级.
关于这些工具, 下面一节有介绍. LeaderF默认是不配置的,
即默认不使用第三方工具.</li>
<li>使用python脚本索引文件, 这个比前两个来得慢, 但因为都是异步操作,
如果文件量不大的话基本无感.</li>
<li>如果<code>g:Lf_ExternalCommand</code>被设置了, 前面所有的选项都作废,
只根据这个命令来索引. 这个一般用不到.</li>
</ol>
<p>我的配置是 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseVersionControlTool</span>=<span class="number">1</span> <span class="comment">&quot;这个是默认选项, 可以不写</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_DefaultExternalTool</span>=<span class="string">&#x27;rg&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="忽略文件">忽略文件</h3>
<p>有一个应用场景也很常见, 如果索引的文件里有很多文件是你不想要关注的.
但是你一检索, 他们会跳出来产生干扰. 比如编译生成的object文件.
比如某些SCM工具的辅助文件等等,
有什么办法可以通过提前设置而忽略掉这些文件么.</p>
<p>如果LeaderF使用前面说的第一种索引, 即用git或者hg索引,
这时LeaderF会通过repo的<code>.gitignore</code>或者<code>.hgignore</code>来忽略文件.
如果用其他的索引方法,
就要通过一个选项<code>g:Lf_WildIgnore</code>来设置忽略的文件. 当然,
对于不同的项目需要忽略的文件可能不一样.
这时候就可以用类似下面的<code>autocmd</code>命令来为不同的项目配置不同的忽略文件.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> BufNewFile,BufRead <span class="keyword">X</span>:/yourdir* <span class="keyword">let</span> <span class="variable">g:Lf_WildIgnore</span>=&#123;<span class="string">&#x27;file&#x27;</span>:[<span class="string">&#x27;*.vcproj&#x27;</span>, <span class="string">&#x27;*.vcxproj&#x27;</span>],<span class="string">&#x27;dir&#x27;</span>:[]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>, 如果配置了之后还不工作,
可以尝试在现实文件列表之后按<code>F5</code>刷新一下缓存.</p>
<h3 id="运行leaderf之后的操作">运行LeaderF之后的操作</h3>
<p>可以通过<code>help leaderf-prompt</code>查看所有的操作,
比较常用的我列在下面: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;C-C&gt;, &lt;ESC&gt; : 退出</span><br><span class="line">&lt;C-R&gt; : 在模糊查询和正则表达式模式间切换</span><br><span class="line">&lt;C-F&gt; : 在全路径搜索和名字搜索模式间切换</span><br><span class="line">&lt;Tab&gt; : 切换成normal模式</span><br><span class="line">&lt;C-V&gt;, &lt;S-Insert&gt; : 从剪切板里copy字符串进行查询</span><br><span class="line">&lt;C-U&gt; : 清除已经打出的字符</span><br><span class="line">&lt;C-J&gt;, &lt;C-K&gt; : 在结果列表中移动</span><br><span class="line">&lt;Up&gt;, &lt;Down&gt; : 从历史记录里调出上一次/下一次的输入pattern</span><br><span class="line">&lt;2-LeftMouse&gt; or &lt;CR&gt; : 打开在光标处的文件或者被选择的多个文件</span><br><span class="line">&lt;F5&gt;  : 刷新缓存</span><br><span class="line">&lt;C-P&gt; : 预览选中结果</span><br><span class="line">&lt;C-Up&gt; : 在预览popup窗口里滚动向上</span><br><span class="line">&lt;C-Down&gt; : 在预览popup窗口里滚动向下</span><br></pre></td></tr></table></figure> 一旦按<code>tab</code>,
则会进入normal模式, 可以使用大部分normal模式命令,
但是还是有一些normal模式下的LeaderF命令,
你可以在normal模式下按<code>F1</code>来显示这些命令. 支持选择多个文件,
也可以分裂窗口打开文件.</p>
<h3 id="其他有用选项">其他有用选项</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g:Lf_ShowHidden 设置1则显示隐藏文件. 默认值0.</span><br><span class="line">g:Lf_PreviewInPopup 设置成1, 预览(preview)会在弹出(popup)窗口里显示, 而不会在原来的文件所在的窗口里显示. 默认值是0.</span><br><span class="line">g:Lf_WindowHeight 设置窗口高度</span><br><span class="line">g:Lf_CacheDirectory 设置缓存路径</span><br><span class="line">g:Lf_StlColorscheme 设置状态栏配色方案</span><br><span class="line">g:Lf_PreviewResult 设置哪几个功能自动显示preview</span><br><span class="line">g:Lf_ReverseOrder 设置为1, 结果从下到上显示, 跟fzf/CtrlP一致, 默认是0, 从上倒下显示.</span><br></pre></td></tr></table></figure>
<p>我的配置是 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:cachedir</span> = <span class="built_in">expand</span>(stdpath(<span class="string">&#x27;cache&#x27;</span>))</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s:configdir</span> = <span class="built_in">expand</span>(stdpath(<span class="string">&#x27;config&#x27;</span>))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">&quot;vim will share same folder with nvim</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;win32&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:cachedir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/Temp/cache/nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:configdir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/AppData/Local/nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:cachedir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.cache/nvim&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s:configdir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.config/nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_PreviewInPopup</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WindowHeight</span> = <span class="number">0.30</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_CacheDirectory</span> = <span class="variable">s:cachedir</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_StlColorscheme</span> = <span class="string">&#x27;powerline&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_PreviewResult</span> = &#123;</span><br><span class="line">        \ <span class="string">&#x27;File&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Buffer&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Mru&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Tag&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;BufTag&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        \ <span class="string">&#x27;Function&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        \ <span class="string">&#x27;Line&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        \ <span class="string">&#x27;Colorscheme&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Rg&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Gtags&#x27;</span>: <span class="number">0</span></span><br><span class="line">        \&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于popup preview窗口, 这个是使用了vim8.1和neovim的floating
window的新功能, 我试用了一下, gvim上表现还不错. neovim-qt上
popup窗口的颜色在某些colorscheme下会非常难以辨识字符,
而且不确定是neovim本身的问题, 还是LeaderF的问题.
但popup窗口的优点也难以割舍, 它可以让你不变动当前位置的情况下预览.</p>
<p>注意, 这里讲的选项, 有些对本文后面讲的其他功能部分也有用.</p>
<h2 id="正则表达式字符串检索">正则表达式/字符串检索
<span id="LeaderF-rg"></span></h2>
<p>正则表达式或者字符串检索, 也即是常说的grep操作,
就是在指定的文件集合中查找那些包含已知的字符串或者包含能匹配上正则表达式字符串的行.</p>
<p>如果是读/写代码, 这个应用场景明显比查找文件使用率还高.
但这种查找一旦文件多了计算量将会非常大. 比如在linux源代码中查找一个变量.
所以通常用一种类grep的专门的软件实现.</p>
<p>这里LeaderF无法直接实现这个功能. 而是需要一个外援.
能够实现这个功能的软件很多, 包扩GNU grep, ack, ag, rg, tp等等.
访问这里<a href="https://beyondgrep.com/feature-comparison/">Feature
comparison of ack, ag, git-grep, GNU grep and
ripgrep</a>可以比较这些软件的功能. 而这篇<a href="https://blog.burntsushi.net/ripgrep">ripgrep is faster than {grep,
ag, git grep, ucg, pt, sift}</a>有人对这些软件的速度进行过测试.
LeaderF的外援就是ripgrep, 简称rg.</p>
<p>rg检索的结果会导入到LeaderF里再进行模糊查找.</p>
<h3 id="rg">rg</h3>
<p>首先需要安装rg, 下载地址在<a href="https://github.com/BurntSushi/ripgrep/releases">这里</a>,
并且让rg所在目录在系统路径下. 然后可以用的如下命令来调用rg.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Leaderf rg ...</span><br></pre></td></tr></table></figure>
<p>调用之后, rg的结果就会在LeaderF窗口里列出,
之后就可以继续用前面提到的模糊匹配, 进一步筛选出你想要的行.
这里rg后面需要接的参数都是rg自身的参数,
可以用<code>Leaderf rg --help</code>来查看rg怎么使用.</p>
<h3 id="与rg相关的按键映射">与rg相关的按键映射</h3>
<p>自己记忆参数用起来肯定不方便. 用得最多的场景是, 检索光标所在位置的词,
或者在visual模式下选中的词.
对于这种场景LeaderF提供了一系列可以映射的句柄. 下面是我自己的映射.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fr <span class="symbol">&lt;Plug&gt;</span>LeaderfRgPrompt</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fra <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordLiteralNoBoundary</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frb <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordLiteralBoundary</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frc <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordRegexNoBoundary</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frd <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordRegexBoundary</span><br><span class="line"></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fra <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualLiteralNoBoundary</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frb <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualLiteralBoundary</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frc <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualRegexNoBoundary</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frd <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualRegexBoundary</span><br></pre></td></tr></table></figure>
<p>快捷键主要是看自己的习惯, 配置完以后, 就可以光速查找当前词.
解释一下:</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>快捷键</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;leader&gt;fr</code></td>
<td>将会在命令行显示 <code>:Leaderf rg -e</code>,
然后等待用户输入想要查询的正则表达式.</td>
</tr>
<tr class="even">
<td><code>&lt;leader&gt;fra</code></td>
<td>将会直接查询光标所在的词语或者visual模式下选中的词语, 但是没有边界.
没有边界的意思是说如果你查<code>word</code>,
包含<code>abcwordxyz</code>的行也会被搜到.</td>
</tr>
<tr class="odd">
<td><code>&lt;leader&gt;frb</code></td>
<td>将会直接查询光标所在的词语,或者visual模式下选中的词语 但是有边界.
有边界的意思是说如果你查<code>word</code>, 包含<code>abcwordxyz</code>
的行不会被搜到,
只有包含类似<code>abc word xyz</code>字段的行才会被搜到.</td>
</tr>
<tr class="even">
<td><code>&lt;leader&gt;frc</code></td>
<td>将会直接把光标所在的词语或者visual模式下选中的词语作为正则表达式检索,
但是没有边界.</td>
</tr>
<tr class="odd">
<td><code>&lt;leader&gt;frd</code></td>
<td>将会直接把光标所在的词语或者visual模式下选中的词语作为正则表达式检索,
但是有边界.</td>
</tr>
</tbody>
</table>
<p>注意敲完快捷键之后需要按一下回车,
这个是LeaderF作者给用户留下了编辑命令的机会. 这几个快捷方式,
只使用了下面几个<code>rg</code>选项:</p>
<ul>
<li><code>-i</code> 忽略大小写.</li>
<li><code>-e &lt;PATTERN&gt;</code> 正则表达式搜索.</li>
<li><code>-F</code> 搜索字符串而不是正则表达式.</li>
<li><code>-w</code> 搜索只匹配有边界的词.</li>
</ul>
<h3 id="rg的其他有用的选项">rg的其他有用的选项</h3>
<p>还有一些常见的场景前面的几个快捷方式无法实现,
比如想要只检索某些特定的文件或者排除掉某些文件.</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>rg选项</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-g, --glob &lt;GLOB&gt;</code></td>
<td>用通配符限定或者排除检索的文件或者目录. 可以使用多次.
通配符的使用跟<code>.gitignore</code>一致. 具体语法参考<a href="https://www.atlassian.com/git/tutorials/saving-changes/gitignore">这里</a>.
在glob前加<code>!</code>表示排除.</td>
</tr>
<tr class="even">
<td><code>-iglob &lt;GLOB&gt;</code></td>
<td>跟前一个一样, 但是忽略大小写.</td>
</tr>
<tr class="odd">
<td><code>-t, --type &lt;TYPE&gt;</code></td>
<td>文件类型检索, rg内置了很多不同的文件类型,
可以使用<code>--type-list</code>来查看其支持的所有文件类型.
比如<code>-t cpp</code>等于<code>*.[chH], *.[chH].in, *.cats</code>.
一个特例是<code>-t all</code>代表检索所有支持的文件类型里匹配的文件.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>LeaderF选项</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>g:Lf_RgConfig</code></td>
<td>可以提前制定一系列rg选项</td>
</tr>
<tr class="even">
<td><code>g:Lf_RgStorePattern</code></td>
<td>可以指定一个vim的寄存器, 一旦检索,
<code>-e</code>后面的内容会被存储进入这个寄存器并且转换成vim的搜索格式.
这个寄存器可以在vim的<code>/</code>或<code>?</code>搜索命令中直接使用.</td>
</tr>
</tbody>
</table>
<p>注意:
前一部分讲的文件搜索里用到的LeaderF选项<code>g:Lf_WildIgnore</code>在这里不起作用,
所以只能用<code>-g "!xxx"</code>来排除文件.
但是用选项<code>g:Lf_RgConfig</code>可以把rg的选项提前设置好.
特别是针对于某个项目用<code>autocmd</code>配置特别的检索选项可以减少误报和漏报.</p>
<h2 id="静态符号索引模糊查找">静态符号索引+模糊查找
<span id="LeaderF-gtags"></span></h2>
<p>前面的rg是通过字符串或者正则表达式进行查找,
更进一步的检索就是静态符号索引. 这篇描述vim默认的标签系统的 --
<a href="/88014cac/" title="vim标签系统">vim标签系统</a>可供参考.</p>
<h3 id="基础用法">基础用法</h3>
<p>LeaderF的作者考虑到静态符号检索出来的结果也可以用来模糊查询.
所以也集成了静态符号索引到中. 下面是LeaderF作者君对基础用法的介绍.</p>
<p><a href="https://zhuanlan.zhihu.com/p/64842373">Leaderf
gtags：模糊匹配与最强静态符号索引工具的完美结合</a></p>
<p>作者放弃了传统的<code>ctags</code>,
而是使用了另外一个功能更强大的静态符号索引软件<a href="https://www.gnu.org/software/global/global.html"><code>gtags</code></a></p>
<p>这一篇是介绍gtags的使用的.</p>
<p><a href="https://zhuanlan.zhihu.com/p/36279445">Vim 8 中 C/C++
符号索引：GTags 篇</a></p>
<p>这篇文章中介绍了另外一个插件<a href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a>,
这个插件是用来管理静态符号索引文件的, 可以同时支持ctags和gtags.
Leaderf也可以管理标签文件, 只要打开如下开关: <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_GtagsAutoGenerate</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_GtagsSource</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_Gtagsconf</span> = <span class="string">&#x27;&lt;gtags_root_path&gt;/share/gtags/gtags.conf&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_Gtagslabel</span> = <span class="string">&#x27;native-pygments&#x27;</span></span><br></pre></td></tr></table></figure>
Leaderf就可以自己自动生成标签库.</p>
<p>解释一下,
<code>g:Lf_GtagsAutoGenerate</code>是用来告诉LeaderF在打开文件后自动生成gtags数据库.</p>
<p><code>g:Lf_GtagsSource</code>可以配置3个值, [0,1,2], 默认值0.
用来配置gtags的需要分析的文件有哪些. 默认值0意思是gtags自己解决,
也就是需要自己添加gtags的选项, 不配置的话, 我理解就是所有文件. 设置成1,
将使用本文第一部分讲的<a href="#LeaderF-file-index">文件索引方式</a>.
设置成2, 就需要自己通过配置<code>g:Lf_GtagsfilesCmd</code>.
总结就是如果是小项目, 不用管这个选项. 如果是大项目,
你前面文件检索已经配置过了, 就设置成1. 如果你项目特殊, 设置成2,
然后自己动手配置文件来源.</p>
<p><code>g:Lf_Gtagsconf</code>是用来指定gtags.conf文件的位置,
<code>Lf_Gtagslabel</code>是说c/c++用gtags自己的解析器,
其他语言以来于<code>pygments</code>. <code>pygments</code>是一个python
module, 可以通过<code>pip install pygments</code>安装.</p>
<p>但为了让两个插件共享标签数据库, 可以如下设置: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let g:Lf_GtagsAutoGenerate = 0</span><br><span class="line">let g:Lf_GtagsGutentags = 1</span><br><span class="line">let g:gutentags_cache_dir = expand(g:Lf_CacheDirectory.&#x27;\.LfCache\gtags&#x27;)</span><br></pre></td></tr></table></figure>
意思就是不自动生成库而试用<code>gutentags</code>生成的,
同时把<code>gutentags</code>的标签生成目录设置成leaderf的标签目录缓存.</p>
<h3 id="leaderfgtags快捷方式">leaderf+gtags快捷方式</h3>
<p>下面是我的相关配置:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgd <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsDefinition</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgr <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsReference</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgs <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsSymbol</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgg <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsGrep</span><br><span class="line"></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgd <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsDefinition</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgr <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsReference</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgs <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsSymbol</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgg <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsGrep</span><br><span class="line"></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fgo :<span class="symbol">&lt;C-U&gt;</span><span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">printf</span>(<span class="string">&quot;Leaderf! gtags --recall %s&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fgn :<span class="symbol">&lt;C-U&gt;</span><span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">printf</span>(<span class="string">&quot;Leaderf gtags --next %s&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fgp :<span class="symbol">&lt;C-U&gt;</span><span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">printf</span>(<span class="string">&quot;Leaderf gtags --previous %s&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于快捷键, 配置完后,
<code>&lt;leader&gt;fgd</code>约等于<code>g_Ctrl-]</code>,
区别是这里加入了模糊搜索和异步执行.
<code>&lt;leader&gt;fgr</code>是ctags不提供的找引用的功能,
<code>&lt;leader&gt;fgs</code>约等于前面的<code>&lt;leader&gt;frb</code>,
<code>&lt;leader&gt;fgg</code>约等于前面的<code>&lt;leader&gt;fra</code>,
之所以这么配置, 主要是我打算根据长期使用比较一下哪个rg和gtags更好用.
<code>&lt;leader&gt;fgo</code>打开上一次检索的结果,
<code>&lt;leader&gt;fgn</code>和<code>&lt;leader&gt;fgp</code>基本等于<code>:tn</code>,
<code>:tp</code>, 在匹配列表中上下跳转.</p>
<p>这里我发现了一个疑似bug, 提交给了作者: <a href="https://github.com/Yggdroot/LeaderF/issues/533">issue#533</a></p>
<h2 id="其他搜索">其他搜索</h2>
<p>模糊搜索和异步执行作为LeaderF的核心武器, 可以扩展到所有的信息搜索上,
LeaderF的作者在这里下了很多功夫, 以下是LeaderF提供的所有搜索功能</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>功能</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>:LeaderfFile</td>
<td>本文<a href="#LeaderF-file">第一部分</a>讲的就是这个命令</td>
</tr>
<tr class="even">
<td>:LeaderfBuffer</td>
<td>在所有打开的buffer里根据buffer的名字搜索相应的buffer,
这个可以用来替代:ls</td>
</tr>
<tr class="odd">
<td>:LeaderfBufferAll</td>
<td>同上, 除了加入隐藏的buffer, 比如帮助文档等.</td>
</tr>
<tr class="even">
<td>:LeaderfMru</td>
<td>搜索most recently used file, 默认显示100个, 可以配置数量.</td>
</tr>
<tr class="odd">
<td>:LeaderfMruCwd</td>
<td>同上, 但只在当前的工作路径下搜索</td>
</tr>
<tr class="even">
<td>:LeaderfTag</td>
<td>在tag文件中检索, 注意这个是ctags的tag文件.</td>
</tr>
<tr class="odd">
<td>:LeaderfBufTag</td>
<td>同上, 但只检索当前buffer的tags</td>
</tr>
<tr class="even">
<td>:LeaderfBufTagAll</td>
<td>同上, 但查找所有listed buffers的tags</td>
</tr>
<tr class="odd">
<td>:LeaderfFunction</td>
<td>查找当前文件的函数或者方法, 这个基本可以用来替代<a href="https://github.com/majutsushi/tagbar">tarbar</a></td>
</tr>
<tr class="even">
<td>:LeaderfFunctionAll</td>
<td>同上, 但列出所有listed buffers的函数和方法</td>
</tr>
<tr class="odd">
<td>:LeaderfLine</td>
<td>在当前文件搜索行, 可以用来替代<code>/</code>和<code>?</code></td>
</tr>
<tr class="even">
<td>:LeaderfLineAll</td>
<td>同上, 但搜索所有的listed buffers的行.</td>
</tr>
<tr class="odd">
<td>:LeaderfHistoryCmd</td>
<td>检索所有执行过的vim命令</td>
</tr>
<tr class="even">
<td>:LeaderfHistorySearch</td>
<td>检索所有执行过的vim搜索</td>
</tr>
<tr class="odd">
<td>:LeaderfSelf</td>
<td>列出所有LeaderF的可执行命令, 供用户检索, 有了这个,
可以不用记忆所有其他命令了.</td>
</tr>
<tr class="even">
<td>:LeaderfHelp</td>
<td>在help tags检索</td>
</tr>
<tr class="odd">
<td>:LeaderfColorscheme</td>
<td>在所有可用的colorscheme里检索</td>
</tr>
<tr class="even">
<td>:LeaderfFiletype</td>
<td>在所有可用的文件类型里检索</td>
</tr>
<tr class="odd">
<td>:LeaderfCommand</td>
<td>在所有可用的vim命令(包括内置的和用户定义的)里检索</td>
</tr>
<tr class="even">
<td>:LeaderfWindow</td>
<td>在所有vim的windows里检索</td>
</tr>
<tr class="odd">
<td>:LeaderfRgInteractive</td>
<td>以交互模式执行<code>Leaderf rg</code></td>
</tr>
<tr class="even">
<td>:LeaderfRgRecall</td>
<td>执行执行过的最后次<code>Leaderf rg</code>命令</td>
</tr>
</tbody>
</table>
<p>我把里面最常用的定义了一些快捷键</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutF</span> = <span class="string">&#x27;&lt;c-p&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutB</span> = <span class="string">&#x27;&lt;c-l&gt;&#x27;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfSelf<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fm :LeaderfMru<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>ff :LeaderfFunction<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fb :LeaderfBufTagAll<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>ft :LeaderfBufTag<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fl :LeaderfLine<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fw :LeaderfWindow<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里有个窍门是, 一旦想不起快捷键,
<code>&lt;leader&gt;f</code>就会直接列出所有可用的Leaderf命令.</p>
<h2 id="总结">总结</h2>
<p>总结一下, 有了一个LeaderF,
几乎所有用来检索的插件甚至内部命令都可以不要了.
这里得除了根据语言语法的动态检索以外. 这是另外的话题, 以后再说.</p>
<p>LeaderF的配置还是需要打磨一下, 文件检索基本是傻瓜模式, 但其他,
尤其是配合rg和gtags还是需要花功夫配置一下, 否则用起来不会有完美体验.</p>
<p>下面是我所有的配置总结.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot;--------------</span></span><br><span class="line"><span class="comment">&quot; LeaderF start</span></span><br><span class="line"><span class="comment">&quot;--------------</span></span><br><span class="line"><span class="string">&quot;let g:Lf_Ctags=&quot;</span>ctags<span class="comment">&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WorkingDirectoryMode</span> = <span class="string">&#x27;AF&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_RootMarkers</span> = [<span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.svn&#x27;</span>, <span class="string">&#x27;.hg&#x27;</span>, <span class="string">&#x27;.project&#x27;</span>, <span class="string">&#x27;.root&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseVersionControlTool</span>=<span class="number">1</span> <span class="comment">&quot;default value, can ignore</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_DefaultExternalTool</span>=<span class="string">&#x27;rg&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_PreviewInPopup</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WindowHeight</span> = <span class="number">0.30</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_CacheDirectory</span> = <span class="variable">s:cachedir</span></span><br><span class="line"><span class="comment">&quot;let g:Lf_StlColorscheme = &#x27;powerline&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_PreviewResult</span> = &#123;</span><br><span class="line">        \ <span class="string">&#x27;File&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Buffer&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Mru&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Tag&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;BufTag&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        \ <span class="string">&#x27;Function&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        \ <span class="string">&#x27;Line&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        \ <span class="string">&#x27;Colorscheme&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Rg&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        \ <span class="string">&#x27;Gtags&#x27;</span>: <span class="number">0</span></span><br><span class="line">        \&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_GtagsAutoGenerate</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_GtagsGutentags</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot;let g:Lf_GtagsAutoGenerate = 1</span></span><br><span class="line"><span class="comment">&quot;let g:Lf_Gtagslabel = &#x27;native-pygments&#x27;</span></span><br><span class="line"><span class="comment">&quot;let g:Lf_GtagsSource = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutF</span> = <span class="string">&#x27;&lt;c-p&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutB</span> = <span class="string">&#x27;&lt;c-l&gt;&#x27;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfSelf<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fm :LeaderfMru<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>ff :LeaderfFunction<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fb :LeaderfBuffer<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>ft :LeaderfBufTag<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fl :LeaderfLine<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fw :LeaderfWindow<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>frr :LeaderfRgRecall<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fr <span class="symbol">&lt;Plug&gt;</span>LeaderfRgPrompt</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fra <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordLiteralNoBoundary</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frb <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordLiteralBoundary</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frc <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordRegexNoBoundary</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frd <span class="symbol">&lt;Plug&gt;</span>LeaderfRgCwordRegexBoundary</span><br><span class="line"></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fra <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualLiteralNoBoundary</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frb <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualLiteralBoundary</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frc <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualRegexNoBoundary</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>frd <span class="symbol">&lt;Plug&gt;</span>LeaderfRgVisualRegexBoundary</span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgd <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsDefinition</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgr <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsReference</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgs <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsSymbol</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgg <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsGrep</span><br><span class="line"></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgd <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsDefinition</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgr <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsReference</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgs <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsSymbol</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;unique&gt;</span> <span class="symbol">&lt;leader&gt;</span>fgg <span class="symbol">&lt;Plug&gt;</span>LeaderfGtagsGrep</span><br><span class="line"></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fgo :<span class="symbol">&lt;C-U&gt;</span><span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">printf</span>(<span class="string">&quot;Leaderf! gtags --recall %s&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fgn :<span class="symbol">&lt;C-U&gt;</span><span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">printf</span>(<span class="string">&quot;Leaderf gtags --next %s&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;leader&gt;</span>fgp :<span class="symbol">&lt;C-U&gt;</span><span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">printf</span>(<span class="string">&quot;Leaderf gtags --previous %s&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot;--------------</span></span><br><span class="line"><span class="comment">&quot; LeaderF end</span></span><br><span class="line"><span class="comment">&quot;--------------</span></span><br></pre></td></tr></table></figure>
<p>返回<a href="/3254a4b3/" title="vim技巧总结">vim技巧总结</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
        <tag>LeaderF</tag>
      </tags>
  </entry>
  <entry>
    <title>vim技巧总结</title>
    <url>//3254a4b3/</url>
    <content><![CDATA[<p>已经有两年时间没折腾过vim的插件了. 最近打算尝试一下neovim,
借着这个机会检索了一下当前流行的vim插件, 发现自己落伍了不少.
而且又学习到很多新的vim知识. 打算总结一下, 主要是方便自己记忆.</p>
<span id="more"></span>
<h2 id="帮助撰写代码">帮助撰写代码</h2>
<p>编辑器的本职工作就是让用户可以编辑文档,
这里记录vim是怎么帮助用户编辑代码的.</p>
<h3 id="vim基本特色----光标移动">vim基本特色 -- 光标移动</h3>
<p>Vim为光标移提供了一套复杂但极有效率的系统,
这套系统也是Vim区别于其他编辑器的最显著特征.
Vim的其他很多功能也都依赖于这套系统. 但成也萧何败也萧何,
这套系统也是Vim劝退很多初学者的一个难点.</p>
<a href="/4f1c2bf8/" title="vim光标移动">vim光标移动</a>
<h2 id="帮助阅读代码">帮助阅读代码</h2>
<p>代码编辑器最重要的功能之一就是能够帮助用户阅读别人写的代码.</p>
<h3 id="静态符号索引----标签tags系统">静态符号索引 --
标签(tags)系统</h3>
<p>由于ctags匹配率比较低, 所以我之前基本放弃使用ctags了.
但刷新知识之后发现这还是个宝藏.</p>
<a href="/88014cac/" title="vim标签系统">vim标签系统</a>
<h3 id="异步模糊检索">异步模糊检索</h3>
<p>vim的异步模糊检索插件使vim超出各种IDE的一个段位.
一旦快捷键形成肌肉记忆, 在代码中跳转时快得飞起. 我常用的有两个,
一般来说LeaderF是主力, fzf安装了备用.</p>
<h4 id="leaderf">leaderf</h4>
<a href="/dc9af5aa/" title="vim plugin介绍之LeaderF">vim plugin介绍之LeaderF</a>
<h4 id="fzf">fzf</h4>
<p>TBD</p>
<h3 id="easymotion">easymotion</h3>
<p>TBD</p>
<h3 id="signature">signature</h3>
<p>TBD</p>
<h2 id="减少写代码的出错机会">减少写代码的出错机会</h2>
<p>TBD</p>
<h3 id="自动补全">自动补全</h3>
<p>TBD</p>
<h3 id="参数提示">参数提示</h3>
<p>TBD</p>
<h3 id="动态检查">动态检查</h3>
<p>TBD</p>
<h2 id="增加apm的插件">增加apm的插件</h2>
<p>TBD</p>
<h3 id="surround">surround</h3>
<p>TBD</p>
<h3 id="easy-align">easy-align</h3>
<p>TBD</p>
<h3 id="expand-region">expand-region</h3>
<p>TBD</p>
<h3 id="matchup">matchup</h3>
<p>TBD</p>
<h3 id="代码注释和反注释">代码注释和反注释</h3>
<p>TBD</p>
<h1 id="vim的自我管理">vim的自我管理</h1>
<h2 id="调试vim">调试vim</h2>
<ol type="1">
<li><a href="/d0cb08b6/" title="vim 监控文件是否在vim外部被修改的机制">vim 监控文件是否在vim外部被修改的机制</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
</search>
