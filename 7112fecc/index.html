<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/Military-Sword-icon-32x32.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Military-Sword-icon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Military-Sword-icon-16x16.png">
  <link rel="mask-icon" href="/images/sword.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"retzzz.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":"ture","motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《流利的Python》第二版是基于python3.10版本的, 是一本对Python 3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读, 更pythonic的代码. 主要包括下面五个部分:  数据结构 函数对象 面向对象 控制流 元编程  之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程, 可以通过这本书作为线索, 学习一下最新的p">
<meta property="og:type" content="article">
<meta property="og:title" content="《流利的Python》第二版(Fluent Python edition 2)读书笔记">
<meta property="og:url" content="https://retzzz.github.io/7112fecc/index.html">
<meta property="og:site_name" content="Mingjian&#39;s Blog">
<meta property="og:description" content="《流利的Python》第二版是基于python3.10版本的, 是一本对Python 3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读, 更pythonic的代码. 主要包括下面五个部分:  数据结构 函数对象 面向对象 控制流 元编程  之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程, 可以通过这本书作为线索, 学习一下最新的p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Figure1_2.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table1_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table1_2.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table2_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table2_3.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table2_4.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Figure3_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table3_1.png">
<meta property="article:published_time" content="2023-03-17T10:00:00.000Z">
<meta property="article:modified_time" content="2023-04-08T10:00:00.000Z">
<meta property="article:author" content="Mingjian">
<meta property="article:tag" content="python">
<meta property="article:tag" content="reading note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://retzzz.github.io/7112fecc//Figure1_2.png">


<link rel="canonical" href="https://retzzz.github.io/7112fecc/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://retzzz.github.io/7112fecc/","path":"/7112fecc/","title":"《流利的Python》第二版(Fluent Python edition 2)读书笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《流利的Python》第二版(Fluent Python edition 2)读书笔记 | Mingjian's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-160618774-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-160618774-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?0dc9d8661d73be13d3e605feca017f0c"></script>

  <script async src="//assets.growingio.com/2.1/gio.js"></script>
  <script class="next-config" data-name="growingio_analytics" type="application/json">"abf47f3a6db226d1"</script>
  <script src="/js/third-party/analytics/growingio.js"></script>






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Mingjian's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头, 何况烂记性.<br/>人生如不能回档的游戏, 保持升级直到角色死亡.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#preface"><span class="nav-text">Preface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#how-the-book-is-organized"><span class="nav-text">How the Book Is Organized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#part-i-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">Part I, 数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#part-ii-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">Part II, 函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#part-iii-%E7%B1%BB%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="nav-text">Part III 类与协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#part-iv-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-text">Part IV 控制流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#part-v-%E5%85%83%E7%BC%96%E7%A8%8Bmetaprogramming"><span class="nav-text">Part V
元编程(Metaprogramming)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part-i-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84data-structures"><span class="nav-text">1. PART I 数据结构(Data
Structures)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#chapter-1-the-python-data-model"><span class="nav-text">1.1. Chapter 1 The Python Data
Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chapter-2-an-array-of-sequences"><span class="nav-text">1.2. Chapter 2 An Array of
Sequences</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#overview-of-built-in-sequences"><span class="nav-text">1.2.1. Overview of Built-in
Sequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list-comprehensions-and-generator-expressions"><span class="nav-text">1.2.2. List
Comprehensions and Generator Expressions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuples-are-not-just-immutable-lists"><span class="nav-text">1.2.3. Tuples Are Not Just
Immutable Lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unpacking-sequences-and-iterables"><span class="nav-text">1.2.4. Unpacking Sequences
and Iterables</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#using-to-grab-excess-items"><span class="nav-text">1.2.4.1. Using * to Grab Excess
Items</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unpacking-with-in-function-calls-and-sequence-literals"><span class="nav-text">1.2.4.2.
Unpacking with * in Function Calls and Sequence Literals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nested-unpacking"><span class="nav-text">1.2.4.3. Nested Unpacking</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pattern-matching-with-sequences"><span class="nav-text">1.2.5. Pattern Matching with
Sequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slicing"><span class="nav-text">1.2.6. Slicing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#using-and-with-sequences"><span class="nav-text">1.2.7. Using + and * with
Sequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list.sort-versus-the-sorted-built-in"><span class="nav-text">1.2.8. list.sort Versus
the sorted Built-in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#when-a-list-is-not-the-answer"><span class="nav-text">1.2.9. When a List is Not the
Answer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#arrays"><span class="nav-text">1.2.9.1. Arrays</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#memory-views"><span class="nav-text">1.2.9.2. Memory Views</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#numpy"><span class="nav-text">1.2.9.3. NumPy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deques-and-other-queues"><span class="nav-text">1.2.9.4. Deques and Other Queues</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chapter-3-dictionaries-and-sets"><span class="nav-text">1.3. Chapter 3 Dictionaries and
Sets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#modern-dict-syntax"><span class="nav-text">1.3.1. Modern dict Syntax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dict-comprehensions"><span class="nav-text">1.3.1.1. dict Comprehensions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unpacking-mappings"><span class="nav-text">1.3.1.2. Unpacking Mappings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merging-mappings-with"><span class="nav-text">1.3.1.3. Merging Mappings with
|</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-matching-with-mappings"><span class="nav-text">1.3.2. Pattern Matching with
Mappings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#standard-api-of-mapping-types"><span class="nav-text">1.3.3. Standard API of Mapping
Types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#what-is-hashable"><span class="nav-text">1.3.3.1. What is Hashable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overview-of-common-mapping-methods"><span class="nav-text">1.3.3.2. Overview of Common
Mapping Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inserting-or-updating-mutable-values"><span class="nav-text">1.3.3.3. Inserting or
Updating Mutable Values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#automatic-handling-of-missing-keys"><span class="nav-text">1.3.4. Automatic Handling of
Missing Keys</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#defaultdict-another-take-on-missing-keys"><span class="nav-text">1.3.4.1. defaultdict:
Another Take on Missing Keys</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-__missing__-method"><span class="nav-text">1.3.4.2. The __missing__
Method</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inconsistent-usage-of-__missing__-in-the-standard-library"><span class="nav-text">1.3.4.3.
Inconsistent Usage of __missing__ in the Standard
Library</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#variations-of-dict"><span class="nav-text">1.3.5. Variations of dict</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collections.ordereddict"><span class="nav-text">1.3.5.1.
collections.OrderedDict</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection.chainmap"><span class="nav-text">1.3.5.2.
collection.ChainMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection.counter"><span class="nav-text">1.3.5.3.
collection.Counter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shelve.shelf"><span class="nav-text">1.3.5.4. shelve.Shelf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subclassing-userdict-instead-of-dict"><span class="nav-text">1.3.5.5. Subclassing
UserDict Instead of dict</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#immutable-mappings"><span class="nav-text">1.3.6. Immutable Mappings</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mingjian</p>
  <div class="site-description" itemprop="description">计算机技术, 航电, 数学, 读书笔记.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://retzzz.github.io/7112fecc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mingjian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mingjian's Blog">
      <meta itemprop="description" content="计算机技术, 航电, 数学, 读书笔记.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《流利的Python》第二版(Fluent Python edition 2)读书笔记 | Mingjian's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《流利的Python》第二版(Fluent Python edition 2)读书笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-17 18:00:00" itemprop="dateCreated datePublished" datetime="2023-03-17T18:00:00+08:00">2023-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-08 18:00:00" itemprop="dateModified" datetime="2023-04-08T18:00:00+08:00">2023-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>《流利的Python》第二版是基于python3.10版本的, 是一本对Python
3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读,
更pythonic的代码. 主要包括下面五个部分:</p>
<ul>
<li>数据结构</li>
<li>函数对象</li>
<li>面向对象</li>
<li>控制流</li>
<li>元编程</li>
</ul>
<div class="note info"><p>之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程,
可以通过这本书作为线索, 学习一下最新的python语言特性.
这读书笔记会专注于记录那些我不熟悉的新特性(或者老特性),
或者能够给我启发的内容.</p>
</div>
<span id="more"></span>
<div class="note warning"><p>没有翻译成中文的包括: 章节标题, 大部分专有名词,
python的关键字相关的词.</p>
</div>
<h2 id="preface">Preface</h2>
<h3 id="how-the-book-is-organized">How the Book Is Organized</h3>
<h4 id="part-i-数据结构">Part I, 数据结构</h4>
<p>第一章介绍的是Python数据模型,
解释为啥双下划线方法是所有类型对象一致行为的关键.
剩下的章节介绍容器类型的使用:包括sequences, mappings, sets, 和str vs
bytes. 也介绍了标准库里的一些更高级的构造类: named tuple
factories和@dataclass装饰器. Python3.10加入的模式匹配(Pattern
matching)会在第2,3,5章介绍, 包括sequence patterns, mapping patterns,
和class patterns. Part I最后一章介绍对象的生命周期: references,
mutability, garbage collection.</p>
<div class="note info"><p>Part I 里面最感兴趣的是标准库里的容器类,
和python3.10的matching语法.</p>
</div>
<h4 id="part-ii-函数对象">Part II, 函数对象</h4>
<p>函数作为语言中的第一类对象: 什么意思,
它是如何影响一些流行的设计模式，以及如何通过利用闭包来实现函数装饰器.
这里还介绍了Python中可调用对象的一般概念, 函数属性, 自省(introspection),
参数注释和Python3中新的非本地声明。第8章介绍了函数签名中的主要新主题--类型提示(pyte
hints).</p>
<div class="note info"><p>Part II 里面最感兴趣的是类型提示.</p>
</div>
<h4 id="part-iii-类与协议">Part III 类与协议</h4>
<p>这部分解释了如何构建容器类, 抽象基类, 协议, 多继承, 运算符重载.
第15章继续讨论类型提示.</p>
<h4 id="part-iv-控制流">Part IV 控制流</h4>
<p>这部分介绍了超过条件,循环,子过程这种传统控制流的语言结构和库.
包括生成器, 上下文访问管理器(visit context managers)和协程,
<code>yield from</code>语法. 第18章包括了使用pattern matching的例子.
第19章是新章节, 介绍了并行编程的一个可选项.
关于异步编程的章节也被重写了.</p>
<div class="note info"><p>Part IV最感兴趣的是协程, with语句.</p>
</div>
<h4 id="part-v-元编程metaprogramming">Part V
元编程(Metaprogramming)</h4>
<p>这部分首先回顾了一个技术, 可以构建一种类, 该类具有能够动态构建的属性,
能处理半结构化数据(比如JSON数据集). 然后介绍了familiar属性机制,
然后深入探讨对象属性访问如何在 Python 中使用描述符在底层工作.
解释了函数, 方法和描述符之间的关系. 在第五部分中,
字段验证库的逐步实现揭示了导致最后一章的高级工具的细微问题:
类装饰器和元类.</p>
<div class="note info"><p>全部感兴趣.</p>
</div>
<h2 id="part-i-数据结构data-structures">1. PART I 数据结构(Data
Structures)</h2>
<h3 id="chapter-1-the-python-data-model">1.1. Chapter 1 The Python Data
Model</h3>
<div class="note info"><p>这一章的内容就是介绍双下划线特殊方法, 没有什么新颖的.
这里就是学到一个新词dunder, 比如说<code>__getitem__</code>,
可以读为"dunder-getitem". dunder是"double underscore before and
after"的缩写. 所以说下面三个是同义词special method, magic method, dunder
method.</p>
</div>
<p>下面几个图总结得很有条理, 这里记录一下. <img src="/7112fecc//Figure1_2.png" class width="800" title="Figure 1-2 Collections UML"> <img src="/7112fecc//Table1_1.png" class width="800" title="Table 1-1 Special Method Names (operators excluded)">
<img src="/7112fecc//Table1_2.png" class width="800" title="Table 1-2 Special Method Names for operators"></p>
<h3 id="chapter-2-an-array-of-sequences">1.2. Chapter 2 An Array of
Sequences</h3>
<p>这一章主要讲各种序列(sequence)对象, 主题包括</p>
<ul>
<li>list推导式(comprehension)和生成器表达式(generator expressions)</li>
<li>tuple用作记录(record) vs tuple用作不可变list</li>
<li>序列解包(unpacking)和序列模式(pattern)</li>
<li>切片对象的读和写</li>
<li>特殊的序列类型, 比如array和queue</li>
</ul>
<h4 id="overview-of-built-in-sequences">1.2.1. Overview of Built-in
Sequences</h4>
<p>两种分类方法:</p>
<ul>
<li>容器序列(list, tuple, collections.deque) vs 平铺序列(str, bytes,
array.array)</li>
<li>可变序列(list, bytearray, array.array) vs 不可变序列(tuple, str,
bytes)</li>
</ul>
<h4 id="list-comprehensions-and-generator-expressions">1.2.2. List
Comprehensions and Generator Expressions</h4>
<p>这两个概念对应的语法几乎是一样的,
唯一的区别就是前者用<code>[]</code>后者用<code>()</code>. 实际上,
前者生成一个list, 后这生成一个generator对象.</p>
<h4 id="tuples-are-not-just-immutable-lists">1.2.3. Tuples Are Not Just
Immutable Lists</h4>
<p>Tuples as Records也就是类似于c语言的struct, 只不过没有field名字,
只靠位置来访问. 可以方便的通过一个赋值语句来解包.</p>
<p>Tuples as Immutable Lists给出了几条用tuple替代list的优势,
主要就是长度已知和速度更快.</p>
<p>下面这张比较list, tuple两种对象方法和属性的表值得收藏.</p>
<img src="/7112fecc//Table2_1.png" class width="800" title="Table 2-1 Methods and attributes found in list or tuple">
<h4 id="unpacking-sequences-and-iterables">1.2.4. Unpacking Sequences
and Iterables</h4>
<p>序列解包, 可以避免使用索引(index)运算.
解包操作可以被使用到所有iterable对象上, 不光sequence对象.</p>
<p>最基本的解包操作就是并行赋值(parallel assignment).</p>
<p>另一个解包操作就是在函数调用时, 给一个参数加前缀<code>*</code>.
例子如下: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = <span class="built_in">divmod</span>(*t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>加*前缀拆包还有以下几个用途</p>
<h5 id="using-to-grab-excess-items">1.2.4.1. Using * to Grab Excess
Items</h5>
<p>主要用于并行赋值(parallel assignment), 抓取额外的元素.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h5 id="unpacking-with-in-function-calls-and-sequence-literals">1.2.4.2.
Unpacking with * in Function Calls and Sequence Literals</h5>
<p>在函数调用时, 解包之后的可迭代对象可以被用作相应位置的输入参数.
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b, c, d, *rest</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> a, b, c, d, rest</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(*[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, *<span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, (<span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure></p>
<p>也可以用在定义list, tuple, set的文本(Literal)里, 比如:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>, *(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="nested-unpacking">1.2.4.3. Nested Unpacking</h5>
<p>嵌套的tuple可以直接嵌套式解包, 比如: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;São Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;&quot;</span>:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;<span class="string">&quot;latitude&quot;</span>:&gt;<span class="number">9</span>&#125;</span> | <span class="subst">&#123;<span class="string">&quot;longitude&quot;</span>:&gt;<span class="number">9</span>&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> name, _, _, (lat, lon) <span class="keyword">in</span> metro_areas:</span><br><span class="line">        <span class="keyword">if</span> lon &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;lat:<span class="number">9.4</span>f&#125;</span> | <span class="subst">&#123;lon:<span class="number">9.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h4 id="pattern-matching-with-sequences">1.2.5. Pattern Matching with
Sequences</h4>
<p>python 3.10加入的新语法match/case 语句 在这本书里根据pattern的类型,
被拆分到各个章节. 这节只介绍sequence的pattern.</p>
<p>看下面这个例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_command</span>(<span class="params">self, message</span>):</span><br><span class="line">    <span class="keyword">match</span> message:</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;BEEPER&#x27;</span>, frequency, times]:</span><br><span class="line">            self.beep(times, frequency)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;NECK&#x27;</span>, angle]:</span><br><span class="line">            self.rotate_neck(angle)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;LED&#x27;</span>, ident, intensity]:</span><br><span class="line">            self.leds[ident].set_brightness(ident, intensity)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;LED&#x27;</span>, ident, red, green, blue]:</span><br><span class="line">            self.leds[ident].set_color(ident, red, green, blue)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">raise</span> InvalidCommand(message)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>关键字<code>match</code>后面的表达式是主语(subject),
Python将要尝试把主语匹配到每个<code>case</code>分句中的pattern上.</li>
<li>第一个pattern会跟任何包含三个元素的sequence进行匹配,
第一个元素必须是字符串'BEEPER'. 第二个和第三个可以是任何值,
他们会被按顺序绑定到变量<code>frequency</code>和<code>times</code>.</li>
<li>第二个pattern匹配任何具有两个元素且第一个是字符串'NECK'的主语.</li>
<li>第三个pattern将匹配任何具有三个元素且第一个元素是字符串'LED'的主语.
如果元素个数不匹配, Python会继续尝试匹配下一个<code>case</code>.</li>
<li>第四个pattern将匹配首元素是'LED'的5元素主语.</li>
<li>最后一句是默认<code>case</code>.
任何在前面pattern中找不到匹配的主语将匹配这一条,
<code>_</code>是个特殊变量, 后面会讲到.</li>
</ol>
<p>这里比较了match/case跟C语言里的switch/case的区别, 作者认为:</p>
<ol type="1">
<li>原来python中的<code>if/elif/elif/.../else</code>语句块是switch/case的一个很好的替代品,
而且避免了c语言中常碰到的fallthrough和dangling else问题.
前者是忘记写break时产生的,
后者是if-else不写大括号导致嵌套if语句的是else匹配跟预想的不一致.</li>
<li>match/case比switch/case强大, 一个重要的改进就是解构(destructuring),
也就是可以在匹配时直接对主语进行拆包(unpacking)</li>
</ol>
<p>通常来讲, 当下列条件都满足, 一个sequence
pattern匹配到主语(subject):</p>
<ol type="1">
<li>主语是一个sequence;</li>
<li>主语跟pattern有相同数量的元素;</li>
<li>每一个对应的元素匹配, 包括嵌套的元素.</li>
</ol>
<p>例如pattern
<code>[name, _, _, (lat, lon)]</code>匹配一个具有4个元素的sequence,
并且其最后一个元素是具有两个元素的sequence.</p>
<p>几点额外的用法和说明:</p>
<ol type="1">
<li>sequence pattern可以是list, tuple, 或嵌套的tuples和lists的组合.
在pattern里方括号和园括号没有区别.</li>
<li>一个sequence
pattern可以匹配大多数collection.abc.Sequence的子类的实例, 但str, bytes,
bytearray除外. 这三个类型如果做match语句主语,
会像整数一样被当作单一值处理.</li>
<li>标准库里下面这些类型与sequence patterns兼容:
<code>list, tuple, memoryview, range, array.array, collections.deque</code>.</li>
<li>与前面讲的拆包不同的地方是,
不能对非sequence得可迭代对象解构(destructuring).</li>
<li>符号<code>_</code>在这里是特殊的, 它将匹配在该位置的任何元素,
但是不绑定名字.
<code>_</code>也是唯一可以多次出现在pattern里的元素.</li>
<li>可以用<code>as</code>关键字绑定pattern的一部分到一个变量,
比如<code>case [name, _, _, (lat, lon) as coord]:</code></li>
<li>可以在pattern里添加类型信息,
例如<code>case [str(name), _, _, (float(lat), float(lon))]:</code>,
这里语法跟构造器调用的语法一样, 但是含义不一样.</li>
<li><code>*_</code>可以用来表示任意数量的元素,
例如<code>case [str(name), *_, (float(lat), float(lon))]:</code>可以匹配任何以字符串开头,
以两个浮点类型元素的嵌套sequence结尾的主语.
也可以用<code>*extra</code>来替换<code>*_</code>,
这么做<code>extra</code>会绑定到一个0到多个元素的<code>list</code>对象.
在一个sequence pattern里, <code>*</code>只能出现一次.
但嵌套的sequence可以分别使用,
例如<code>case ['lambda', [*parms], *body] if body:</code></li>
<li>一个可选的以<code>if</code>开头的守卫从句可以用来添加匹配条件.
但if语句只有当匹配了pattern才会被执行.
case之后的语句块只有匹配pattern且守卫表达式为真时才会被执行, 例如:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> record:</span><br><span class="line">    <span class="keyword">case</span> [name, _, _, (lat, lon)] <span class="keyword">if</span> lon &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;lat:<span class="number">9.4</span>f&#125;</span> | <span class="subst">&#123;lon:<span class="number">9.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="slicing">1.2.6. Slicing</h4>
<p>这里作者讲了一个有趣的知识点,
执行<code>seq[start:stop:step]</code>在python内部调用了<code>seq.__getitem__(slice(start,stop,step)]</code>.
所以可以给一个slice对象命名, 比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>invoice = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>0.....6.................................40........52...55........</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1909 Pimoroni PiBrella $17.50 3 $52.50</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1489 6mm Tactile Switch x20 $4.95 2 $9.90</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1510 Panavise Jr. - PV-201 $28.00 1 $28.00</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SKU = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DESCRIPTION = <span class="built_in">slice</span>(<span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>UNIT_PRICE = <span class="built_in">slice</span>(<span class="number">40</span>, <span class="number">52</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>QUANTITY = <span class="built_in">slice</span>(<span class="number">52</span>, <span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ITEM_TOTAL = <span class="built_in">slice</span>(<span class="number">55</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>line_items = invoice.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item[UNIT_PRICE], item[DESCRIPTION])</span><br><span class="line">...</span><br><span class="line">    $<span class="number">17.50</span> Pimoroni PiBrella</span><br><span class="line">     $<span class="number">4.95</span> 6mm Tactile Switch x20</span><br><span class="line">    $<span class="number">28.00</span> Panavise Jr. - PV-<span class="number">201</span></span><br><span class="line">    $<span class="number">34.95</span> PiTFT Mini Kit 320x240</span><br></pre></td></tr></table></figure>
<p>另外还有一个给切片对象赋值, 如果赋值左边时一个切片对象,
右边必须是一个可迭代对象. 例如 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="using-and-with-sequences">1.2.7. Using + and * with
Sequences</h4>
<p>几个知识点:</p>
<ol type="1">
<li>对sequence进行<code>+</code>和<code>*</code>, 会创建新的对象,
而不会修改操作数.</li>
<li>构造多维数组时, 有个陷阱, 这个我过去也碰到过, 正确做法:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>错误做法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>下面是关于对sequence类型应用<code>+=</code>,
<code>*=</code>这种增量赋值(Augmented Assignment)的几个知识点</p>
<ol type="1">
<li>对于<code>a += b</code>, 如果实现了<code>__iadd__</code>,
那么这个dunder函数将被调用. 如果用于可变序列(mutable sequences),
那么该对象将被修改(类似于<code>a.extend(b)</code>).
<code>a</code>讲指向原来的对象.</li>
<li>如果没有实现<code>__iadd__</code>, 但是实现了<code>__add__</code>,
那么<code>a += b</code>跟<code>a = a + b</code>效果相同.
所以<code>a += b</code>运行之后<code>a</code>指向的<code>a + b</code>产生的新对象.
对于不可变序列对象(immutable sequences), 这个是必然结果.</li>
<li><code>+=</code>在底层相当于两步操作, 所以有可能完成一半之后报错,
比如下面这个例子:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">69</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">40</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">69</span>, <span class="number">50</span>, <span class="number">40</span>])</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>避免在tuple里使用可变类型元素.</li>
<li>网站<code>pythontutor.com</code>可以帮助分析内存分配.
直接分析字节码也不是很难.</li>
</ol>
<h4 id="list.sort-versus-the-sorted-built-in">1.2.8. list.sort Versus
the sorted Built-in</h4>
<p>list.sort不创建新对象, 内置函数sorted创建新的对象.
两个参数reverse是逆序不用说,
key是以可迭代对象的每个元素为唯一参数的一个函数,
这个函数返回排序时用来比较的对象. 举例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>)</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br></pre></td></tr></table></figure>
<div class="note info"><p>一个额外的知识点,
利用bisect内置库模块可以在维持排序的情况下做插入和快速搜索.</p>
</div>
<h4 id="when-a-list-is-not-the-answer">1.2.9. When a List is Not the
Answer</h4>
<p>list类型非常易用, 但针对一些特定的需求, 有时候有更好的选择.
这一小章节就是介绍其他选项的, 我也经常过度使用list,
所以这章认真读一下.</p>
<h5 id="arrays">1.2.9.1. Arrays</h5>
<p>如果list只包含数字, 那么<code>array.array</code>是很有效的替代品.</p>
<ol type="1">
<li>Arrays支持所有可变序列的操作, 比如<code>.pop</code>,
<code>.insert</code>, `.extend.</li>
<li>有课外的快速读写(saving, loading)的操作,
比如<code>.frombytes</code>, <code>.tofile</code></li>
<li>跟C array一样节省.</li>
<li>无法像list一样自排序, 需要使用built-in
<code>sorted</code>函数来做排序.
例如<code>a = array.array(a.typecode, sorted(a))</code>.
使用<code>bisect.insort</code>可以在保持排序的情况下添加元素.</li>
</ol>
<p>下表是跟list的方法对比. 这本书这种对比特别直观, 点赞收藏.</p>
<img src="/7112fecc//Table2_3.png" class width="800" title="Table 2-3 Methods and attributes found in list or array">
<h5 id="memory-views">1.2.9.2. Memory Views</h5>
<p><code>memoryview</code>居然是个built-in的类,
可以让不同的sequence类型共享内存.
<code>memoryview.cast</code>方法可以通过指定内存空间内每个元素的大小,
和对元素进行重新分组来修改读写元素的方式.
这个方法返回另一个<code>memoryview</code>对象,
但跟源对象共享同一块内存.</p>
<h5 id="numpy">1.2.9.3. NumPy</h5>
<p>NumPy提供高级的数组和矩阵运算,
它是Python能够成为主流的科学计算程序语言的原因.
SciPy是基于NumPy的一个库, 提供大量科学计算算法, 包括线性代数, 微积分,
统计等.</p>
<p>NumPy和SciPyye也是一些其他工具的基础, 比如</p>
<ol type="1">
<li>Pandas提供了有效的非数字类型的数组操作, 提供了导入/导出到其它格式,
像.csv, .xls, SQL, HDF5等等.</li>
<li>scikit-learn是当前最广泛使用的机器学习工具集.</li>
<li>Dask项目, 提供了在一组机器上并行计算Numpy, Pandas,
scikit-learn过程的能力.</li>
</ol>
<h5 id="deques-and-other-queues">1.2.9.4. Deques and Other Queues</h5>
<p><code>collections.deque</code>类是一个线程安全(thread-safe)的双向序列.
可以从两端快速插入和删除. <code>deque</code>可以被固定最大长度,
叫做绑定的<code>deque</code>(bounded deque). 如果绑定的deque满了,
那么从一端加入新元素, 将导致另一端的第一个元素被删除.</p>
<p>下表是list和deque方法对比:</p>
<img src="/7112fecc//Table2_4.png" class width="800" title="Table 2-4 Methods implemented in list and deque">
<p>除了<code>deque</code>,
其他的python标准库里如下一些模块还包括了其他的一些队列类:</p>
<ol type="1">
<li>queue: 这个模块提供了thread-safe的同步类,
包括<code>SimpleQueue</code>, <code>Queue</code>,
<code>LifoQueue</code>, <code>PriorityQueue</code>.
除了<code>SimpleQueue</code>, 其他几个类可以在构建时提供一个最大长度.
但跟<code>deque</code>不同的是, 队列满了之后不会删除元素,
而是会阻塞线程, 直到有其他线程给队列腾出空间.
这对于线程间同步非常有用.</li>
<li>multiprocessing: 这个模块实现了它自己的SimpleQueue和绑定的Queue,
跟模块queue里的很像, 但是是为了进程间交互设计的.
为了任务管理提供了一个特别的<code>multiprocessing.JoinableQueue</code>类.</li>
<li>asyncio: 提供了<code>Queue</code>, <code>LifoQueue</code>,
<code>PriorityQueue</code>, 和<code>JoinableQueue</code>.
跟模块<code>queue</code>里的很像, 但是为了异步编程的任务管理设计.</li>
<li>heapq: 跟前三个模块不同, <code>heapq</code>没有实现队列类,
但是提供了一些像<code>heappush</code>, <code>heappop</code>的函数,
让用户可以像使用heap queue或者priority queue一样使用一个可变队列(mutable
sequence).</li>
</ol>
<h3 id="chapter-3-dictionaries-and-sets">1.3. Chapter 3 Dictionaries and
Sets</h3>
<p>Python的一些核心基础结构是由内存中的字典结构构成的, 比如:</p>
<ol type="1">
<li>类和实例的属性.</li>
<li>模块名字空间.</li>
<li>函数的keyword参数.</li>
<li><code>__builtins__.__dict__</code>存储所有的内置类型, 对象,
和函数.</li>
</ol>
<p>哈希表(Hash tables)是Python高性能<code>dict</code>的基础引擎.
<code>set</code>, <code>frozenset</code>也是基于哈希表.</p>
<h4 id="modern-dict-syntax">1.3.1. Modern dict Syntax</h4>
<h4 id="dict-comprehensions">1.3.1.1. dict Comprehensions</h4>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dial_codes = [</span><br><span class="line"><span class="meta">... </span>    (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> dial_codes&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial</span><br><span class="line">&#123;<span class="string">&#x27;Bangladesh&#x27;</span>: <span class="number">880</span>, <span class="string">&#x27;Brazil&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;China&#x27;</span>: <span class="number">86</span>, <span class="string">&#x27;India&#x27;</span>: <span class="number">91</span>, <span class="string">&#x27;Indonesia&#x27;</span>: <span class="number">62</span>,</span><br><span class="line"><span class="string">&#x27;Japan&#x27;</span>: <span class="number">81</span>, <span class="string">&#x27;Nigeria&#x27;</span>: <span class="number">234</span>, <span class="string">&#x27;Pakistan&#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Russia&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;United States&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code: country.upper()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> country, code <span class="keyword">in</span> <span class="built_in">sorted</span>(country_dial.items())</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> code &lt; <span class="number">70</span>&#125;</span><br><span class="line">&#123;<span class="number">55</span>: <span class="string">&#x27;BRAZIL&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;INDONESIA&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;RUSSIA&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;UNITED STATES&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unpacking-mappings">1.3.1.2. Unpacking Mappings</h4>
<p>从Python3.5版本开始映射类型的解包(mapping
unpacking)可以用有两种方式的应用:</p>
<ol type="1">
<li>在函数调用的时候, 可以应用<code>**</code>到多个参数上.</li>
<li><code>**</code>可以被用于<code>dict</code>的文本里.</li>
</ol>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">**kwargs</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> kwargs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dump(**&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, y=<span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, **&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="merging-mappings-with">1.3.1.3. Merging Mappings with
<code>|</code></h4>
<p>Python
3.9版本支持使用<code>|</code>和<code>|=</code>来合并mapping类型.
前者创建一个新的mapping对象, 新对象的类型默认跟左边的操作数相同,
后者更新现存的mapping.</p>
<h3 id="pattern-matching-with-mappings">1.3.2. Pattern Matching with
Mappings</h3>
<p><code>match/case</code>语句的主语(subject)可以是mapping对象.
Pattern看起来跟mapping文本很像,
可以匹配任何<code>collections.abc.Mapping</code>的子类的实例.</p>
<p>pattern
matching是用来处理嵌套的mappings和sequences的结构化记录非常强大的工具.
比如处理JSON, 半结构化数据库比如MongoDB, EdgeDB, PostgreSQL.</p>
<p>下面是个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">get_creators</span>(<span class="params">record: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">match</span> record:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;api&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;authors&#x27;</span>: [*names]&#125;:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> names</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;api&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;author&#x27;</span>: name&#125;:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [name]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>&#125;:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Invalid &#x27;book&#x27; record: <span class="subst">&#123;record!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;movie&#x27;</span>, <span class="string">&#x27;director&#x27;</span>: name&#125;:  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [name]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> _:  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Invalid record: <span class="subst">&#123;record!r&#125;</span>&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = <span class="built_in">dict</span>(api=<span class="number">1</span>, author=<span class="string">&#x27;Douglas Hofstadter&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">type</span>=<span class="string">&#x27;book&#x27;</span>, title=<span class="string">&#x27;Gödel, Escher, Bach&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(b1)</span><br><span class="line">[<span class="string">&#x27;Douglas Hofstadter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = OrderedDict(api=<span class="number">2</span>, <span class="built_in">type</span>=<span class="string">&#x27;book&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        title=<span class="string">&#x27;Python in a Nutshell&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        authors=<span class="string">&#x27;Martelli Ravenscroft Holden&#x27;</span>.split())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(b2)</span><br><span class="line">[<span class="string">&#x27;Martelli&#x27;</span>, <span class="string">&#x27;Ravenscroft&#x27;</span>, <span class="string">&#x27;Holden&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>: <span class="number">770</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> get_creators</span><br><span class="line">ValueError: Invalid <span class="string">&#x27;book&#x27;</span> record: &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>: <span class="number">770</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(<span class="string">&#x27;Spam, spam, spam&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">12</span>, <span class="keyword">in</span> get_creators</span><br><span class="line">ValueError: Invalid record: <span class="string">&#x27;Spam, spam, spam&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的几点是</p>
<ol type="1">
<li>pattern里面key的顺序不会影响匹配,
即便主语是<code>OrderedDict</code>.</li>
<li>跟sequence pattern对比, mapping pattern允许部分匹配.</li>
<li>因为允许部分匹配,
所以不需要用<code>**extra</code>匹配额外的key-value对.
但如果你想要捕获额外的key-value对, 作为一个dict,
最后一个变量可以用双星号变量, 而且不能是<code>**_</code>.</li>
</ol>
<h3 id="standard-api-of-mapping-types">1.3.3. Standard API of Mapping
Types</h3>
<p><code>dict</code>的接口是由<code>collections.abc</code>模块提供的<code>Mapping</code>和<code>MutableMapping</code>描述的,
见下图:</p>
<img src="/7112fecc//Figure3_1.png" class width="800" title="Figure 3-1 UML class diagram for the MutableMapping">
<p>想要自定义mapping类型, 可以扩展<code>collections.UserDict</code>,
或者通过composition包裹一个<code>dict</code>, 而不是这些ABCs的子类.
<code>collections.UserDict</code>类和标准库中的所有具体mapping类在其实现中都封装了基本dict.
而dict又构建在哈希表上. 因此. 它们都有一个限制.
即键必须是可散列(hashable)的(value不需要是可散列的，只需要key).</p>
<h4 id="what-is-hashable">1.3.3.1. What is Hashable</h4>
<p>定义: 如果一个对象具有一个哈希值,
并且这个值在对象的整个生命周期内不变(这需要一个<code>__hash__()</code>方法).
并且可以跟其他对象进行比较(这需要一个<code>__eq__()</code>方法),
那么这个对象就是可散列的(hashable).
两个相等的可散列对象必须具有相同的哈希值.</p>
<ul>
<li>可散列对象包括: 数值类型, flat immutable类型(str, bytes),
所有元素都是可散列的的immutable容器(frozenset, tuple if all its items
are hashable).</li>
<li>不可散列对象包括: mutable容器类(list, dict)</li>
</ul>
<p>其他几个知识点:</p>
<ol type="1">
<li>同一个对象的哈希值只有同一个python进程里能确保相等. 在不同的机器,
不同python版本, 不同python的实现, 不同的python进程里都不能确保相同.</li>
<li>用户定义类型默认是hashable,
因为默认他们的哈希值就是他们的<code>id()</code>,
而<code>__eq__()</code>方法继承了根类<code>object</code>,
简单比较对象ID. 如果对象实现了<code>__eq__()</code>方法,
那么它只有实现了<code>__hash__()</code>方法, 并且其每次能返回相同值,
它才是hashable. 所以实践中,
这两个dunder方法仅使用那些在对象生命周期内保持不变的属性.</li>
</ol>
<h4 id="overview-of-common-mapping-methods">1.3.3.2. Overview of Common
Mapping Methods</h4>
<p>下面这个表给出了<code>dict</code>和它的两个流行的变体<code>defaultdict</code>和<code>OrderedDict</code>.
这两个变体定义在<code>collections</code>模块.</p>
<img src="/7112fecc//Table3_1.png" class width="800" title="Table 3-1. Methods of the mapping types">
<h4 id="inserting-or-updating-mutable-values">1.3.3.3. Inserting or
Updating Mutable Values</h4>
<p>若<code>dict</code>访问操作<code>d[k]</code>里的k不是一个存在的键,
会报错.
<code>d.get(k, default)</code>比处理<code>KeyError</code>更方便的返回默认值.
如果想要同时取值和更新, 可以使用<code>d.setdefault(key,default)</code>,
这个方法虽然叫set somthing, 但是意思是, 如果key存在就返回d[key],
否则先d[key]=default, 然后再返回d[key]. 这样可以减少一次搜索.</p>
<h4 id="automatic-handling-of-missing-keys">1.3.4. Automatic Handling of
Missing Keys</h4>
<p>在一个mapping对象搜索一个不存在的key, 对象的行为是可以定制化的.
通常通过两种可能的途径,
一个是用<code>defaultdict</code>代替默认的<code>dict</code>,
另一个是继承dict, 添加<code>__missing__</code>方法来定制行为模式.</p>
<h5 id="defaultdict-another-take-on-missing-keys">1.3.4.1. defaultdict:
Another Take on Missing Keys</h5>
<p>知识点:</p>
<ol type="1">
<li><code>collections.defaultdict</code>实例初始化的时候,
你需要提供一个可调用对象.</li>
<li>当一个不存在的key被传给<code>__getitem__</code>方法时,
这个可调用对象被调用来产生一个默认值.</li>
<li>这个可调用对象也作为实例的一个叫做<code>default_factory</code>的属性.</li>
<li>d.get(k)将不会触发<code>default_factory</code>被调用.</li>
</ol>
<h5 id="the-__missing__-method">1.3.4.2. The <code>__missing__</code>
Method</h5>
<p>想要更精确的定制处理不存在key的行为,
需要使用<code>__missing__</code>方法,
<code>dict</code>类没有定义这个方法, 但是如果任何子类提供了这个方法,
当不存在key被访问的时候,
<code>dict.__getitem__</code>会调用这个方法.</p>
<p>知识点:</p>
<ol type="1">
<li>避免出现无限迭代的情况.</li>
<li>为了行为一致性, <code>__contains__</code>方法也需要在子类重写.
因为表达式<code>k in d</code>会调用这个方法,
但继承自<code>dict</code>的<code>__contains__</code>并不会回调<code>__missing__</code>.</li>
</ol>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrKeyDict</span>(collections.UserDict):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, item</span>):</span><br><span class="line">        self.data[<span class="built_in">str</span>(key)] = item</span><br></pre></td></tr></table></figure>
<h5 id="inconsistent-usage-of-__missing__-in-the-standard-library">1.3.4.3.
Inconsistent Usage of <code>__missing__</code> in the Standard
Library</h5>
<p>几个场景</p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>dict</code>的子类
只实现了<code>__missing__</code></td>
<td style="text-align: left;">那么只有<code>d[k]</code>通过继承自<code>dict</code>的<code>__getitem__</code>
有可能调用<code>__missing__</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>collection.UserDict</code>的子类
只实现了<code>__missing__</code></td>
<td style="text-align: left;">由于继承自<code>UserDict</code>的<code>get</code>方法也调用<code>__getitem__</code>
所以<code>d[k]</code>和<code>d.get(k)</code>都有可能调用<code>__missing__</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>abc.Mapping</code>的子类
实现最简单的<code>__getitem__</code></td>
<td style="text-align: left;"><code>__missing__</code>永远不会被调用,
因为<code>__getitem__</code> 没调用它.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>abc.Mapping</code>的子类
<code>__getitem__</code>调用<code>__missing__</code></td>
<td style="text-align: left;"><code>d[k]</code>, <code>d.get(k)</code>,
<code>k in d</code>都会触发<code>__missing__</code></td>
</tr>
</tbody>
</table>
<p>这四个场景只描绘了最小化的实现,
如果你的子类实现了<code>__getitem__</code>, <code>get</code>,
<code>__contains__</code>,
那么你可以基于你的需求决定这些方法是否使用<code>__missing_</code>.
关键点是标准库中的mappings的默认行为是不一样的, 所以一定要小心使用.</p>
<p>别忘了<code>setdefault</code>和<code>update</code>也受搜索key的影响,
所以你有可能需要实现具有特殊逻辑的<code>__getitem__</code>来避免对象行为的不一致性.</p>
<h4 id="variations-of-dict">1.3.5. Variations of <code>dict</code></h4>
<p>这一节介绍标准库里除了<code>defaultdict</code>以外的mapping类型.</p>
<h4 id="collections.ordereddict">1.3.5.1.
<code>collections.OrderedDict</code></h4>
<p>Python 3.6开始, 内建的<code>dict</code>也会保留keys的顺序.
Python文档里列出的<code>dict</code>和<code>OrderedDict</code>的区别如下.</p>
<ol type="1">
<li><code>OrderedDict</code>在判定等号时会检查顺序是否相同.</li>
<li><code>OrderedDict</code>的<code>popitem()</code>方法会接受一个可选参数来指定时LIFO还是FIFO.</li>
<li><code>OrderedDict</code>有一个<code>move_to_end()</code>方法可以有效的把元素挪到队尾.</li>
<li>运算效率上, <code>dict</code>优先mapping操作,
而追踪插入元素的顺序次之.</li>
<li>运算效率上, <code>OrderedDict</code>优先重排序操作, 空间效率,
迭代速度和更新操作次之.</li>
<li>算法上,
<code>OrderedDict</code>比<code>dict</code>更善于处理频繁排序的操作.
因此很适合用于追踪最近访问的操作(比如LRU缓存).</li>
</ol>
<h4 id="collection.chainmap">1.3.5.2.
<code>collection.ChainMap</code></h4>
<ol type="1">
<li><code>ChainMap</code>实例可以把多个mapping类型对象当作一个列表来检索.
检索操作是按照构建时提供的mapping类型对象的顺序来执行的,
只要找到任何一个存在的key, 就检索成功.</li>
<li>更新和插入操作只影响第一个mapping对象</li>
<li>不拷贝对象, 只保存mapping对象的引用.</li>
<li>特别适合用于语言的嵌套名字哦那空间.</li>
</ol>
<p>例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = <span class="built_in">dict</span>(a=<span class="number">2</span>, b=<span class="number">4</span>, c=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain = ChainMap(d1, d2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain[<span class="string">&#x27;c&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">pylookup = ChainMap(<span class="built_in">locals</span>(), <span class="built_in">globals</span>(), <span class="built_in">vars</span>(builtins))</span><br></pre></td></tr></table></figure></p>
<h4 id="collection.counter">1.3.5.3.
<code>collection.Counter</code></h4>
<ol type="1">
<li>这个对象可以保存每个key的整数计数.</li>
<li>更新对象实际上是在现存计数上加新计数.</li>
<li><code>+</code>和<code>-</code>运算用于合并计数.</li>
<li><code>most_common([n])</code>返回一个有序的list, 元素是tuple,
表示计数最多的前n个元素.</li>
</ol>
<p>例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.update(<span class="string">&#x27;aaaaazzz&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></p>
<h4 id="shelve.shelf">1.3.5.4. <code>shelve.Shelf</code></h4>
<p>标准库中的<code>shelve</code>模块为从字符串key到用<code>pickle</code>二进制格式序列化的Python对象的mapping提供了一个永久存储的方法.
名字叫<code>shelve</code>, 来自于咸菜(pickle)坛子放在架子(shelve)上.</p>
<p><code>shelve.open</code>函数返回一个<code>shelve.Shelf</code>实例,
这是一个简单的key-value DBM数据库.</p>
<h4 id="subclassing-userdict-instead-of-dict">1.3.5.5. Subclassing
UserDict Instead of dict</h4>
<p>这段建议大家如果想创建自己的mapping类型,
继承<code>UserDict</code>而不是<code>dict</code>.
主要原因是<code>dict</code>的实现里有一些shortcuts.
这导致一些本来可以直接继承<code>UserDict</code>的方法,
在继承<code>dict</code>时需要重写.</p>
<h3 id="immutable-mappings">1.3.6. Immutable Mappings</h3>
<p>未完待续</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/reading-note/" rel="tag"># reading note</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/df491dd4/" rel="prev" title="python decorator(装饰器)">
                  <i class="fa fa-chevron-left"></i> python decorator(装饰器)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/9432bb75/" rel="next" title="中国农历是如何计算的">
                  中国农历是如何计算的 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mingjian</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"retzzz","repo":"gitment-comments","client_id":"6a068ba17921ccef5727","client_secret":"f6a9f87e75e82d68a9988a1803eaf0ba021c2864","admin_user":"retzzz","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"1075cd4416d854d7e03c80d9d1eb4b66"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
