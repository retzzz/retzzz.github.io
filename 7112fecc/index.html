<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/Military-Sword-icon-32x32.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Military-Sword-icon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Military-Sword-icon-16x16.png">
  <link rel="mask-icon" href="/images/sword.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"retzzz.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":"ture","motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《流利的Python》第二版是基于python3.10版本的, 是一本对Python 3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读, 更pythonic的代码. 主要包括下面五个部分: * 数据结构 * 函数对象 * 面向对象 * 控制流 * 元编程 之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程, 可以通过这本书作为线索, 学习">
<meta property="og:type" content="article">
<meta property="og:title" content="《流利的Python》第二版(Fluent Python edition 2)读书笔记">
<meta property="og:url" content="https://retzzz.github.io/7112fecc/index.html">
<meta property="og:site_name" content="Mingjian&#39;s Blog">
<meta property="og:description" content="《流利的Python》第二版是基于python3.10版本的, 是一本对Python 3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读, 更pythonic的代码. 主要包括下面五个部分: * 数据结构 * 函数对象 * 面向对象 * 控制流 * 元编程 之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程, 可以通过这本书作为线索, 学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Figure1_2.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table1_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table1_2.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table2_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table2_3.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table2_4.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Figure3_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table3_1.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Figure3_2.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table3_2to3_4.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Table3_5.png">
<meta property="og:image" content="https://retzzz.github.io/7112fecc//Figure4_7.png">
<meta property="article:published_time" content="2023-03-17T10:00:00.000Z">
<meta property="article:modified_time" content="2023-04-13T10:00:00.000Z">
<meta property="article:author" content="Mingjian">
<meta property="article:tag" content="python">
<meta property="article:tag" content="reading note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://retzzz.github.io/7112fecc//Figure1_2.png">


<link rel="canonical" href="https://retzzz.github.io/7112fecc/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://retzzz.github.io/7112fecc/","path":"/7112fecc/","title":"《流利的Python》第二版(Fluent Python edition 2)读书笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《流利的Python》第二版(Fluent Python edition 2)读书笔记 | Mingjian's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-160618774-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-160618774-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?0dc9d8661d73be13d3e605feca017f0c"></script>

  <script async src="//assets.growingio.com/2.1/gio.js"></script>
  <script class="next-config" data-name="growingio_analytics" type="application/json">"abf47f3a6db226d1"</script>
  <script src="/js/third-party/analytics/growingio.js"></script>






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Mingjian's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头, 何况烂记性.<br/>人生如不能回档的游戏, 保持升级直到角色死亡.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#preface"><span class="nav-text">Preface</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#how-the-book-is-organized"><span class="nav-text">How the Book Is Organized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#part-i-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">Part I, 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#part-ii-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">Part II, 函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#part-iii-%E7%B1%BB%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="nav-text">Part III 类与协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#part-iv-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-text">Part IV 控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#part-v-%E5%85%83%E7%BC%96%E7%A8%8Bmetaprogramming"><span class="nav-text">Part V
元编程(Metaprogramming)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#part-i-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84data-structures"><span class="nav-text">PART I 数据结构(Data
Structures)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-1-the-python-data-model"><span class="nav-text">1. Chapter 1 The Python Data
Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-2-an-array-of-sequences"><span class="nav-text">2. Chapter 2 An Array of
Sequences</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#overview-of-built-in-sequences"><span class="nav-text">2.1. Overview of Built-in
Sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-comprehensions-and-generator-expressions"><span class="nav-text">2.2. List
Comprehensions and Generator Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuples-are-not-just-immutable-lists"><span class="nav-text">2.3. Tuples Are Not Just
Immutable Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unpacking-sequences-and-iterables"><span class="nav-text">2.4. Unpacking Sequences and
Iterables</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#using-to-grab-excess-items"><span class="nav-text">2.4.1. Using * to Grab Excess
Items</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unpacking-with-in-function-calls-and-sequence-literals"><span class="nav-text">2.4.2.
Unpacking with * in Function Calls and Sequence Literals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nested-unpacking"><span class="nav-text">2.4.3. Nested Unpacking</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-matching-with-sequences"><span class="nav-text">2.5. Pattern Matching with
Sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slicing"><span class="nav-text">2.6. Slicing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-and-with-sequences"><span class="nav-text">2.7. Using + and * with Sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list.sort-versus-the-sorted-built-in"><span class="nav-text">2.8. list.sort Versus the
sorted Built-in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#when-a-list-is-not-the-answer"><span class="nav-text">2.9. When a List is Not the
Answer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#arrays"><span class="nav-text">2.9.1. Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-views"><span class="nav-text">2.9.2. Memory Views</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numpy"><span class="nav-text">2.9.3. NumPy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deques-and-other-queues"><span class="nav-text">2.9.4. Deques and Other Queues</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-3-dictionaries-and-sets"><span class="nav-text">3. Chapter 3 Dictionaries and
Sets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#modern-dict-syntax"><span class="nav-text">3.1. Modern dict Syntax</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dict-comprehensions"><span class="nav-text">3.1.1. dict Comprehensions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unpacking-mappings"><span class="nav-text">3.1.2. Unpacking Mappings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merging-mappings-with"><span class="nav-text">3.1.3. Merging Mappings with
|</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-matching-with-mappings"><span class="nav-text">3.2. Pattern Matching with
Mappings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#standard-api-of-mapping-types"><span class="nav-text">3.3. Standard API of Mapping
Types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#what-is-hashable"><span class="nav-text">3.3.1. What is Hashable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overview-of-common-mapping-methods"><span class="nav-text">3.3.2. Overview of Common
Mapping Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inserting-or-updating-mutable-values"><span class="nav-text">3.3.3. Inserting or
Updating Mutable Values</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#automatic-handling-of-missing-keys"><span class="nav-text">3.4. Automatic Handling of
Missing Keys</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#defaultdict-another-take-on-missing-keys"><span class="nav-text">3.4.1. defaultdict:
Another Take on Missing Keys</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-__missing__-method"><span class="nav-text">3.4.2. The __missing__
Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inconsistent-usage-of-__missing__-in-the-standard-library"><span class="nav-text">3.4.3.
Inconsistent Usage of __missing__ in the Standard
Library</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variations-of-dict"><span class="nav-text">3.5. Variations of dict</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#collections.ordereddict"><span class="nav-text">3.5.1.
collections.OrderedDict</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection.chainmap"><span class="nav-text">3.5.2.
collection.ChainMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection.counter"><span class="nav-text">3.5.3. collection.Counter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shelve.shelf"><span class="nav-text">3.5.4. shelve.Shelf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subclassing-userdict-instead-of-dict"><span class="nav-text">3.5.5. Subclassing
UserDict Instead of dict</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#immutable-mappings"><span class="nav-text">3.6. Immutable Mappings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictionary-views"><span class="nav-text">3.7. Dictionary Views</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#practical-consequences-of-how-dict-works"><span class="nav-text">3.8. Practical
Consequences of How dict Works</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-theory"><span class="nav-text">3.9. Set Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set-literals"><span class="nav-text">3.9.1 Set Literals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-comprehensions"><span class="nav-text">3.9.2 Set Comprehensions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#practical-consequences-of-how-sets-work"><span class="nav-text">3.10 Practical
Consequences of How Sets Work</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set-operations"><span class="nav-text">3.10.1 Set Operations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-operations-on-dict-views"><span class="nav-text">3.11 Set Operations on dict
Views</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unicode-text-versus-bytes"><span class="nav-text">4. Unicode Text Versus Bytes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#character-issues"><span class="nav-text">4.1. Character Issues</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#byte-essentials"><span class="nav-text">4.2. Byte Essentials</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#basic-encodersdecoders"><span class="nav-text">4.3. Basic Encoders&#x2F;Decoders</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#understanding-encodedecode-problems"><span class="nav-text">4.4. Understanding
Encode&#x2F;Decode Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#coping-with-unicodeencodeerror"><span class="nav-text">4.4.1. Coping with
UnicodeEncodeError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coping-with-unicodedecodeerror"><span class="nav-text">4.4.2. Coping with
UnicodeDecodeError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#syntaxerror-when-loading-modules-with-unexpected-encoding"><span class="nav-text">4.4.3.
SyntaxError When Loading Modules with Unexpected Encoding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-discover-the-encoding-of-a-byte-sequence"><span class="nav-text">4.4.4. How to
Discover the Encoding of a Byte Sequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bom-a-useful-gremlin"><span class="nav-text">4.4.5. BOM: A Useful Gremlin</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handling-text-files"><span class="nav-text">4.5. Handling Text Files</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#beware-of-encoding-defaults"><span class="nav-text">4.5.1 Beware of Encoding
Defaults</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#normalizing-unicode-for-reliable-comparisons"><span class="nav-text">4.6. Normalizing
Unicode for Reliable Comparisons</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#case-folding"><span class="nav-text">4.6.1. Case Folding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#utility-functions-for-normalized-text-matching"><span class="nav-text">4.6.2. Utility
Functions for Normalized Text Matching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extreme-normalization-taking-out-diacritics"><span class="nav-text">4.6.3. Extreme
“Normalization”: Taking Out Diacritics</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorting-unicode-text"><span class="nav-text">4.7. Sorting Unicode Text</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sorting-with-the-unicode-collation-algorithm"><span class="nav-text">4.7.1. Sorting
with the Unicode Collation Algorithm</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-unicode-database"><span class="nav-text">4.8. The Unicode Database</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#finding-characters-by-name"><span class="nav-text">4.8.1. Finding Characters by
Name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numeric-meaning-of-characters"><span class="nav-text">4.8.2. Numeric Meaning of
Characters</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dual-mode-str-and-bytes-apis"><span class="nav-text">4.9. Dual-Mode str and bytes
APIs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#str-versus-bytes-in-regular-expressions"><span class="nav-text">4.9.1 str Versus bytes
in Regular Expressions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#str-versus-bytes-in-os-functions"><span class="nav-text">4.9.2 str Versus bytes in os
Functions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-5.-data-class-builders"><span class="nav-text">5. Chapter 5. Data Class
Builders</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-6.-object-references-mutability-and-recycling"><span class="nav-text">6.
Chapter 6. Object References, Mutability, and Recycling</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#part-ii.-functions-as-objects"><span class="nav-text">Part II. Functions as
Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-7.-functions-as-first-class-objects"><span class="nav-text">7. Chapter 7.
Functions as First-Class Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#treating-a-function-like-an-object"><span class="nav-text">7.1. Treating a Function
Like an Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#higher-order-functions"><span class="nav-text">7.2. Higher-Order Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anonymous-functions"><span class="nav-text">7.3 Anonymous Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-nine-flavors-of-callable-objects"><span class="nav-text">7.4 The Nine Flavors of
Callable Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-defined-callable-types"><span class="nav-text">7.5. User-Defined Callable
Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#from-positional-to-keyword-only-parameters"><span class="nav-text">7.6. From Positional
to Keyword-Only Parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#packages-for-functional-programming"><span class="nav-text">7.7. Packages for
Functional Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#the-operator-module"><span class="nav-text">7.7.1. The operator Module</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#freezing-arguments-with-functools.partial"><span class="nav-text">7.7.2. Freezing
Arguments with functools.partial</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-8.-type-hints-in-functions"><span class="nav-text">8. Chapter 8. Type Hints in
Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#about-gradual-typing"><span class="nav-text">8.1. About Gradual Typing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#types-are-defined-by-supported-operations"><span class="nav-text">8.2. Types Are
Defined by Supported Operations</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mingjian</p>
  <div class="site-description" itemprop="description">计算机技术, 航电, 数学, 读书笔记.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://retzzz.github.io/7112fecc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mingjian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mingjian's Blog">
      <meta itemprop="description" content="计算机技术, 航电, 数学, 读书笔记.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《流利的Python》第二版(Fluent Python edition 2)读书笔记 | Mingjian's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《流利的Python》第二版(Fluent Python edition 2)读书笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-17 18:00:00" itemprop="dateCreated datePublished" datetime="2023-03-17T18:00:00+08:00">2023-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-13 18:00:00" itemprop="dateModified" datetime="2023-04-13T18:00:00+08:00">2023-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>《流利的Python》第二版是基于python3.10版本的, 是一本对Python
3各个方面的特性的细节的介绍让你能够写出更精炼, 更快速, 更可读,
更pythonic的代码. 主要包括下面五个部分:</p>
<pre><code>* 数据结构
* 函数对象
* 面向对象
* 控制流
* 元编程</code></pre>
<div class="note info"><p>之所以读这本书, 是因为python的进化很快, 之前一直在使用3.4编程,
可以通过这本书作为线索, 学习一下最新的python语言特性.
这读书笔记会专注于记录那些我不熟悉的新特性(或者老特性),
或者能够给我启发的内容.</p>
</div>
<span id="more"></span>
<div class="note warning"><p>没有翻译成中文的包括: 章节标题, 大部分专有名词,
python的关键字相关的词.</p>
</div>
<h1 id="preface">Preface</h1>
<h2 id="how-the-book-is-organized">How the Book Is Organized</h2>
<h3 id="part-i-数据结构">Part I, 数据结构</h3>
<p>第一章介绍的是Python数据模型,
解释为啥双下划线方法是所有类型对象一致行为的关键.
剩下的章节介绍容器类型的使用:包括sequences, mappings, sets, 和str vs
bytes. 也介绍了标准库里的一些更高级的构造类: named tuple
factories和@dataclass装饰器. Python3.10加入的模式匹配(Pattern
matching)会在第2,3,5章介绍, 包括sequence patterns, mapping patterns,
和class patterns. Part I最后一章介绍对象的生命周期: references,
mutability, garbage collection.</p>
<div class="note info"><p>Part I 里面最感兴趣的是标准库里的容器类,
和python3.10的matching语法.</p>
</div>
<h3 id="part-ii-函数对象">Part II, 函数对象</h3>
<p>函数作为语言中的第一类对象: 什么意思,
它是如何影响一些流行的设计模式，以及如何通过利用闭包来实现函数装饰器.
这里还介绍了Python中可调用对象的一般概念, 函数属性, 自省(introspection),
参数注释和Python3中新的非本地声明.
第8章介绍了函数签名中的主要新主题--类型提示(pyte hints).</p>
<div class="note info"><p>Part II 里面最感兴趣的是类型提示.</p>
</div>
<h3 id="part-iii-类与协议">Part III 类与协议</h3>
<p>这部分解释了如何构建容器类, 抽象基类, 协议, 多继承, 运算符重载.
第15章继续讨论类型提示.</p>
<h3 id="part-iv-控制流">Part IV 控制流</h3>
<p>这部分介绍了超过条件,循环,子过程这种传统控制流的语言结构和库.
包括生成器, 上下文访问管理器(visit context managers)和协程,
<code>yield from</code>语法. 第18章包括了使用pattern matching的例子.
第19章是新章节, 介绍了并行编程的一个可选项.
关于异步编程的章节也被重写了.</p>
<div class="note info"><p>Part IV最感兴趣的是协程, with语句.</p>
</div>
<h3 id="part-v-元编程metaprogramming">Part V
元编程(Metaprogramming)</h3>
<p>这部分首先回顾了一个技术, 可以构建一种类, 该类具有能够动态构建的属性,
能处理半结构化数据(比如JSON数据集). 然后介绍了familiar属性机制,
然后深入探讨对象属性访问如何在 Python 中使用描述符在底层工作.
解释了函数, 方法和描述符之间的关系. 在第五部分中,
字段验证库的逐步实现揭示了导致最后一章的高级工具的细微问题:
类装饰器和元类.</p>
<div class="note info"><p>全部感兴趣.</p>
</div>
<h1 id="part-i-数据结构data-structures">PART I 数据结构(Data
Structures)</h1>
<h2 id="chapter-1-the-python-data-model">1. Chapter 1 The Python Data
Model</h2>
<div class="note info"><p>这一章的内容就是介绍双下划线特殊方法, 没有什么新颖的.
这里就是学到一个新词dunder, 比如说<code>__getitem__</code>,
可以读为"dunder-getitem". dunder是"double underscore before and
after"的缩写. 所以说下面三个是同义词special method, magic method, dunder
method.</p>
</div>
<p>下面几个图总结得很有条理, 这里记录一下. <img src="/7112fecc//Figure1_2.png" class width="800" title="Figure 1-2 Collections UML"> <img src="/7112fecc//Table1_1.png" class width="800" title="Table 1-1 Special Method Names (operators excluded)">
<img src="/7112fecc//Table1_2.png" class width="800" title="Table 1-2 Special Method Names for operators"></p>
<h2 id="chapter-2-an-array-of-sequences">2. Chapter 2 An Array of
Sequences</h2>
<p>这一章主要讲各种序列(sequence)对象, 主题包括</p>
<ul>
<li>list推导式(comprehension)和生成器表达式(generator expressions)</li>
<li>tuple用作记录(record) vs tuple用作不可变list</li>
<li>序列解包(unpacking)和序列模式(pattern)</li>
<li>切片对象的读和写</li>
<li>特殊的序列类型, 比如array和queue</li>
</ul>
<h3 id="overview-of-built-in-sequences">2.1. Overview of Built-in
Sequences</h3>
<p>两种分类方法:</p>
<ul>
<li>容器序列(list, tuple, collections.deque) vs 平铺序列(str, bytes,
array.array)</li>
<li>可变序列(list, bytearray, array.array) vs 不可变序列(tuple, str,
bytes)</li>
</ul>
<h3 id="list-comprehensions-and-generator-expressions">2.2. List
Comprehensions and Generator Expressions</h3>
<p>这两个概念对应的语法几乎是一样的,
唯一的区别就是前者用<code>[]</code>后者用<code>()</code>. 实际上,
前者生成一个list, 后这生成一个generator对象.</p>
<h3 id="tuples-are-not-just-immutable-lists">2.3. Tuples Are Not Just
Immutable Lists</h3>
<p>Tuples as Records也就是类似于c语言的struct, 只不过没有field名字,
只靠位置来访问. 可以方便的通过一个赋值语句来解包.</p>
<p>Tuples as Immutable Lists给出了几条用tuple替代list的优势,
主要就是长度已知和速度更快.</p>
<p>下面这张比较list, tuple两种对象方法和属性的表值得收藏.</p>
<img src="/7112fecc//Table2_1.png" class width="800" title="Table 2-1 Methods and attributes found in list or tuple">
<h3 id="unpacking-sequences-and-iterables">2.4. Unpacking Sequences and
Iterables</h3>
<p>序列解包, 可以避免使用索引(index)运算.
解包操作可以被使用到所有iterable对象上, 不光sequence对象.</p>
<p>最基本的解包操作就是并行赋值(parallel assignment).</p>
<p>另一个解包操作就是在函数调用时, 给一个参数加前缀<code>*</code>.
例子如下: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = <span class="built_in">divmod</span>(*t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>加*前缀拆包还有以下几个用途</p>
<h4 id="using-to-grab-excess-items">2.4.1. Using * to Grab Excess
Items</h4>
<p>主要用于并行赋值(parallel assignment), 抓取额外的元素.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h4 id="unpacking-with-in-function-calls-and-sequence-literals">2.4.2.
Unpacking with * in Function Calls and Sequence Literals</h4>
<p>在函数调用时, 解包之后的可迭代对象可以被用作相应位置的输入参数.
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b, c, d, *rest</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> a, b, c, d, rest</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(*[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, *<span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, (<span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure></p>
<p>也可以用在定义list, tuple, set的文本(Literal)里, 比如:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>, *(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="nested-unpacking">2.4.3. Nested Unpacking</h4>
<p>嵌套的tuple可以直接嵌套式解包, 比如: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;São Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;&quot;</span>:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;<span class="string">&quot;latitude&quot;</span>:&gt;<span class="number">9</span>&#125;</span> | <span class="subst">&#123;<span class="string">&quot;longitude&quot;</span>:&gt;<span class="number">9</span>&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> name, _, _, (lat, lon) <span class="keyword">in</span> metro_areas:</span><br><span class="line">        <span class="keyword">if</span> lon &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;lat:<span class="number">9.4</span>f&#125;</span> | <span class="subst">&#123;lon:<span class="number">9.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h3 id="pattern-matching-with-sequences">2.5. Pattern Matching with
Sequences</h3>
<p>python 3.10加入的新语法match/case 语句 在这本书里根据pattern的类型,
被拆分到各个章节. 这节只介绍sequence的pattern.</p>
<p>看下面这个例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_command</span>(<span class="params">self, message</span>):</span><br><span class="line">    <span class="keyword">match</span> message:</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;BEEPER&#x27;</span>, frequency, times]:</span><br><span class="line">            self.beep(times, frequency)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;NECK&#x27;</span>, angle]:</span><br><span class="line">            self.rotate_neck(angle)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;LED&#x27;</span>, ident, intensity]:</span><br><span class="line">            self.leds[ident].set_brightness(ident, intensity)</span><br><span class="line">        <span class="keyword">case</span> [<span class="string">&#x27;LED&#x27;</span>, ident, red, green, blue]:</span><br><span class="line">            self.leds[ident].set_color(ident, red, green, blue)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">raise</span> InvalidCommand(message)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>关键字<code>match</code>后面的表达式是主语(subject),
Python将要尝试把主语匹配到每个<code>case</code>分句中的pattern上.</li>
<li>第一个pattern会跟任何包含三个元素的sequence进行匹配,
第一个元素必须是字符串'BEEPER'. 第二个和第三个可以是任何值,
他们会被按顺序绑定到变量<code>frequency</code>和<code>times</code>.</li>
<li>第二个pattern匹配任何具有两个元素且第一个是字符串'NECK'的主语.</li>
<li>第三个pattern将匹配任何具有三个元素且第一个元素是字符串'LED'的主语.
如果元素个数不匹配, Python会继续尝试匹配下一个<code>case</code>.</li>
<li>第四个pattern将匹配首元素是'LED'的5元素主语.</li>
<li>最后一句是默认<code>case</code>.
任何在前面pattern中找不到匹配的主语将匹配这一条,
<code>_</code>是个特殊变量, 后面会讲到.</li>
</ol>
<p>这里比较了match/case跟C语言里的switch/case的区别, 作者认为:</p>
<ol type="1">
<li>原来python中的<code>if/elif/elif/.../else</code>语句块是switch/case的一个很好的替代品,
而且避免了c语言中常碰到的fallthrough和dangling else问题.
前者是忘记写break时产生的,
后者是if-else不写大括号导致嵌套if语句的是else匹配跟预想的不一致.</li>
<li>match/case比switch/case强大, 一个重要的改进就是解构(destructuring),
也就是可以在匹配时直接对主语进行拆包(unpacking)</li>
</ol>
<p>通常来讲, 当下列条件都满足, 一个sequence
pattern匹配到主语(subject):</p>
<ol type="1">
<li>主语是一个sequence;</li>
<li>主语跟pattern有相同数量的元素;</li>
<li>每一个对应的元素匹配, 包括嵌套的元素.</li>
</ol>
<p>例如pattern
<code>[name, _, _, (lat, lon)]</code>匹配一个具有4个元素的sequence,
并且其最后一个元素是具有两个元素的sequence.</p>
<p>几点额外的用法和说明:</p>
<ol type="1">
<li>sequence pattern可以是list, tuple, 或嵌套的tuples和lists的组合.
在pattern里方括号和园括号没有区别.</li>
<li>一个sequence
pattern可以匹配大多数collection.abc.Sequence的子类的实例, 但str, bytes,
bytearray除外. 这三个类型如果做match语句主语,
会像整数一样被当作单一值处理.</li>
<li>标准库里下面这些类型与sequence patterns兼容:
<code>list, tuple, memoryview, range, array.array, collections.deque</code>.</li>
<li>与前面讲的拆包不同的地方是,
不能对非sequence得可迭代对象解构(destructuring).</li>
<li>符号<code>_</code>在这里是特殊的, 它将匹配在该位置的任何元素,
但是不绑定名字.
<code>_</code>也是唯一可以多次出现在pattern里的元素.</li>
<li>可以用<code>as</code>关键字绑定pattern的一部分到一个变量,
比如<code>case [name, _, _, (lat, lon) as coord]:</code></li>
<li>可以在pattern里添加类型信息,
例如<code>case [str(name), _, _, (float(lat), float(lon))]:</code>,
这里语法跟构造器调用的语法一样, 但是含义不一样.</li>
<li><code>*_</code>可以用来表示任意数量的元素,
例如<code>case [str(name), *_, (float(lat), float(lon))]:</code>可以匹配任何以字符串开头,
以两个浮点类型元素的嵌套sequence结尾的主语.
也可以用<code>*extra</code>来替换<code>*_</code>,
这么做<code>extra</code>会绑定到一个0到多个元素的<code>list</code>对象.
在一个sequence pattern里, <code>*</code>只能出现一次.
但嵌套的sequence可以分别使用,
例如<code>case ['lambda', [*parms], *body] if body:</code></li>
<li>一个可选的以<code>if</code>开头的守卫从句可以用来添加匹配条件.
但if语句只有当匹配了pattern才会被执行.
case之后的语句块只有匹配pattern且守卫表达式为真时才会被执行, 例如:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> record:</span><br><span class="line">    <span class="keyword">case</span> [name, _, _, (lat, lon)] <span class="keyword">if</span> lon &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">15</span>&#125;</span> | <span class="subst">&#123;lat:<span class="number">9.4</span>f&#125;</span> | <span class="subst">&#123;lon:<span class="number">9.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="slicing">2.6. Slicing</h3>
<p>这里作者讲了一个有趣的知识点,
执行<code>seq[start:stop:step]</code>在python内部调用了<code>seq.__getitem__(slice(start,stop,step)]</code>.
所以可以给一个slice对象命名, 比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>invoice = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>0.....6.................................40........52...55........</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1909 Pimoroni PiBrella $17.50 3 $52.50</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1489 6mm Tactile Switch x20 $4.95 2 $9.90</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1510 Panavise Jr. - PV-201 $28.00 1 $28.00</span></span><br><span class="line"><span class="string"><span class="meta">... </span>1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SKU = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DESCRIPTION = <span class="built_in">slice</span>(<span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>UNIT_PRICE = <span class="built_in">slice</span>(<span class="number">40</span>, <span class="number">52</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>QUANTITY = <span class="built_in">slice</span>(<span class="number">52</span>, <span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ITEM_TOTAL = <span class="built_in">slice</span>(<span class="number">55</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>line_items = invoice.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item[UNIT_PRICE], item[DESCRIPTION])</span><br><span class="line">...</span><br><span class="line">    $<span class="number">17.50</span> Pimoroni PiBrella</span><br><span class="line">     $<span class="number">4.95</span> 6mm Tactile Switch x20</span><br><span class="line">    $<span class="number">28.00</span> Panavise Jr. - PV-<span class="number">201</span></span><br><span class="line">    $<span class="number">34.95</span> PiTFT Mini Kit 320x240</span><br></pre></td></tr></table></figure>
<p>另外还有一个给切片对象赋值, 如果赋值左边时一个切片对象,
右边必须是一个可迭代对象. 例如 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="using-and-with-sequences">2.7. Using + and * with Sequences</h3>
<p>几个知识点:</p>
<ol type="1">
<li>对sequence进行<code>+</code>和<code>*</code>, 会创建新的对象,
而不会修改操作数.</li>
<li>构造多维数组时, 有个陷阱, 这个我过去也碰到过, 正确做法:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>错误做法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>下面是关于对sequence类型应用<code>+=</code>,
<code>*=</code>这种增量赋值(Augmented Assignment)的几个知识点</p>
<ol type="1">
<li>对于<code>a += b</code>, 如果实现了<code>__iadd__</code>,
那么这个dunder函数将被调用. 如果用于可变序列(mutable sequences),
那么该对象将被修改(类似于<code>a.extend(b)</code>).
<code>a</code>讲指向原来的对象.</li>
<li>如果没有实现<code>__iadd__</code>, 但是实现了<code>__add__</code>,
那么<code>a += b</code>跟<code>a = a + b</code>效果相同.
所以<code>a += b</code>运行之后<code>a</code>指向的<code>a + b</code>产生的新对象.
对于不可变序列对象(immutable sequences), 这个是必然结果.</li>
<li><code>+=</code>在底层相当于两步操作, 所以有可能完成一半之后报错,
比如下面这个例子:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">69</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">40</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">69</span>, <span class="number">50</span>, <span class="number">40</span>])</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>避免在tuple里使用可变类型元素.</li>
<li>网站<code>pythontutor.com</code>可以帮助分析内存分配.
直接分析字节码也不是很难.</li>
</ol>
<h3 id="list.sort-versus-the-sorted-built-in">2.8. list.sort Versus the
sorted Built-in</h3>
<p>list.sort不创建新对象, 内置函数sorted创建新的对象.
两个参数reverse是逆序不用说,
key是以可迭代对象的每个元素为唯一参数的一个函数,
这个函数返回排序时用来比较的对象. 举例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>)</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br></pre></td></tr></table></figure>
<div class="note info"><p>一个额外的知识点,
利用bisect内置库模块可以在维持排序的情况下做插入和快速搜索.</p>
</div>
<h3 id="when-a-list-is-not-the-answer">2.9. When a List is Not the
Answer</h3>
<p>list类型非常易用, 但针对一些特定的需求, 有时候有更好的选择.
这一小章节就是介绍其他选项的, 我也经常过度使用list,
所以这章认真读一下.</p>
<h4 id="arrays">2.9.1. Arrays</h4>
<p>如果list只包含数字, 那么<code>array.array</code>是很有效的替代品.</p>
<ol type="1">
<li>Arrays支持所有可变序列的操作, 比如<code>.pop</code>,
<code>.insert</code>, `.extend.</li>
<li>有课外的快速读写(saving, loading)的操作,
比如<code>.frombytes</code>, <code>.tofile</code></li>
<li>跟C array一样节省.</li>
<li>无法像list一样自排序, 需要使用built-in
<code>sorted</code>函数来做排序.
例如<code>a = array.array(a.typecode, sorted(a))</code>.
使用<code>bisect.insort</code>可以在保持排序的情况下添加元素.</li>
</ol>
<p>下表是跟list的方法对比. 这本书这种对比特别直观, 点赞收藏.</p>
<img src="/7112fecc//Table2_3.png" class width="800" title="Table 2-3 Methods and attributes found in list or array">
<h4 id="memory-views">2.9.2. Memory Views</h4>
<p><code>memoryview</code>居然是个built-in的类,
可以让不同的sequence类型共享内存.
<code>memoryview.cast</code>方法可以通过指定内存空间内每个元素的大小,
和对元素进行重新分组来修改读写元素的方式.
这个方法返回另一个<code>memoryview</code>对象,
但跟源对象共享同一块内存.</p>
<h4 id="numpy">2.9.3. NumPy</h4>
<p>NumPy提供高级的数组和矩阵运算,
它是Python能够成为主流的科学计算程序语言的原因.
SciPy是基于NumPy的一个库, 提供大量科学计算算法, 包括线性代数, 微积分,
统计等.</p>
<p>NumPy和SciPyye也是一些其他工具的基础, 比如</p>
<ol type="1">
<li>Pandas提供了有效的非数字类型的数组操作, 提供了导入/导出到其它格式,
像.csv, .xls, SQL, HDF5等等.</li>
<li>scikit-learn是当前最广泛使用的机器学习工具集.</li>
<li>Dask项目, 提供了在一组机器上并行计算Numpy, Pandas,
scikit-learn过程的能力.</li>
</ol>
<h4 id="deques-and-other-queues">2.9.4. Deques and Other Queues</h4>
<p><code>collections.deque</code>类是一个线程安全(thread-safe)的双向序列.
可以从两端快速插入和删除. <code>deque</code>可以被固定最大长度,
叫做绑定的<code>deque</code>(bounded deque). 如果绑定的deque满了,
那么从一端加入新元素, 将导致另一端的第一个元素被删除.</p>
<p>下表是list和deque方法对比:</p>
<img src="/7112fecc//Table2_4.png" class width="800" title="Table 2-4 Methods implemented in list and deque">
<p>除了<code>deque</code>,
其他的python标准库里如下一些模块还包括了其他的一些队列类:</p>
<ol type="1">
<li>queue: 这个模块提供了thread-safe的同步类,
包括<code>SimpleQueue</code>, <code>Queue</code>,
<code>LifoQueue</code>, <code>PriorityQueue</code>.
除了<code>SimpleQueue</code>, 其他几个类可以在构建时提供一个最大长度.
但跟<code>deque</code>不同的是, 队列满了之后不会删除元素,
而是会阻塞线程, 直到有其他线程给队列腾出空间.
这对于线程间同步非常有用.</li>
<li>multiprocessing: 这个模块实现了它自己的SimpleQueue和绑定的Queue,
跟模块queue里的很像, 但是是为了进程间交互设计的.
为了任务管理提供了一个特别的<code>multiprocessing.JoinableQueue</code>类.</li>
<li>asyncio: 提供了<code>Queue</code>, <code>LifoQueue</code>,
<code>PriorityQueue</code>, 和<code>JoinableQueue</code>.
跟模块<code>queue</code>里的很像, 但是为了异步编程的任务管理设计.</li>
<li>heapq: 跟前三个模块不同, <code>heapq</code>没有实现队列类,
但是提供了一些像<code>heappush</code>, <code>heappop</code>的函数,
让用户可以像使用heap queue或者priority queue一样使用一个可变队列(mutable
sequence).</li>
</ol>
<h2 id="chapter-3-dictionaries-and-sets">3. Chapter 3 Dictionaries and
Sets</h2>
<p>Python的一些核心基础结构是由内存中的字典结构构成的, 比如:</p>
<ol type="1">
<li>类和实例的属性.</li>
<li>模块名字空间.</li>
<li>函数的keyword参数.</li>
<li><code>__builtins__.__dict__</code>存储所有的内置类型, 对象,
和函数.</li>
</ol>
<p>哈希表(Hash tables)是Python高性能<code>dict</code>的基础引擎.
<code>set</code>, <code>frozenset</code>也是基于哈希表.</p>
<h3 id="modern-dict-syntax">3.1. Modern dict Syntax</h3>
<h4 id="dict-comprehensions">3.1.1. dict Comprehensions</h4>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dial_codes = [</span><br><span class="line"><span class="meta">... </span>    (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> dial_codes&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial</span><br><span class="line">&#123;<span class="string">&#x27;Bangladesh&#x27;</span>: <span class="number">880</span>, <span class="string">&#x27;Brazil&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;China&#x27;</span>: <span class="number">86</span>, <span class="string">&#x27;India&#x27;</span>: <span class="number">91</span>, <span class="string">&#x27;Indonesia&#x27;</span>: <span class="number">62</span>,</span><br><span class="line"><span class="string">&#x27;Japan&#x27;</span>: <span class="number">81</span>, <span class="string">&#x27;Nigeria&#x27;</span>: <span class="number">234</span>, <span class="string">&#x27;Pakistan&#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Russia&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;United States&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code: country.upper()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> country, code <span class="keyword">in</span> <span class="built_in">sorted</span>(country_dial.items())</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> code &lt; <span class="number">70</span>&#125;</span><br><span class="line">&#123;<span class="number">55</span>: <span class="string">&#x27;BRAZIL&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;INDONESIA&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;RUSSIA&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;UNITED STATES&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unpacking-mappings">3.1.2. Unpacking Mappings</h4>
<p>从Python3.5版本开始映射类型的解包(mapping
unpacking)可以用有两种方式的应用:</p>
<ol type="1">
<li>在函数调用的时候, 可以应用<code>**</code>到多个参数上.</li>
<li><code>**</code>可以被用于<code>dict</code>的文本里.</li>
</ol>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">**kwargs</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> kwargs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dump(**&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, y=<span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, **&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="merging-mappings-with">3.1.3. Merging Mappings with
<code>|</code></h4>
<p>Python
3.9版本支持使用<code>|</code>和<code>|=</code>来合并mapping类型.
前者创建一个新的mapping对象, 新对象的类型默认跟左边的操作数相同,
后者更新现存的mapping.</p>
<h3 id="pattern-matching-with-mappings">3.2. Pattern Matching with
Mappings</h3>
<p><code>match/case</code>语句的主语(subject)可以是mapping对象.
Pattern看起来跟mapping文本很像,
可以匹配任何<code>collections.abc.Mapping</code>的子类的实例.</p>
<p>pattern
matching是用来处理嵌套的mappings和sequences的结构化记录非常强大的工具.
比如处理JSON, 半结构化数据库比如MongoDB, EdgeDB, PostgreSQL.</p>
<p>下面是个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">get_creators</span>(<span class="params">record: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">match</span> record:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;api&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;authors&#x27;</span>: [*names]&#125;:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> names</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;api&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;author&#x27;</span>: name&#125;:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [name]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>&#125;:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Invalid &#x27;book&#x27; record: <span class="subst">&#123;record!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;movie&#x27;</span>, <span class="string">&#x27;director&#x27;</span>: name&#125;:  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [name]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">case</span> _:  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Invalid record: <span class="subst">&#123;record!r&#125;</span>&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = <span class="built_in">dict</span>(api=<span class="number">1</span>, author=<span class="string">&#x27;Douglas Hofstadter&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">type</span>=<span class="string">&#x27;book&#x27;</span>, title=<span class="string">&#x27;Gödel, Escher, Bach&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(b1)</span><br><span class="line">[<span class="string">&#x27;Douglas Hofstadter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = OrderedDict(api=<span class="number">2</span>, <span class="built_in">type</span>=<span class="string">&#x27;book&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        title=<span class="string">&#x27;Python in a Nutshell&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>        authors=<span class="string">&#x27;Martelli Ravenscroft Holden&#x27;</span>.split())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(b2)</span><br><span class="line">[<span class="string">&#x27;Martelli&#x27;</span>, <span class="string">&#x27;Ravenscroft&#x27;</span>, <span class="string">&#x27;Holden&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>: <span class="number">770</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> get_creators</span><br><span class="line">ValueError: Invalid <span class="string">&#x27;book&#x27;</span> record: &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>: <span class="number">770</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_creators(<span class="string">&#x27;Spam, spam, spam&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">12</span>, <span class="keyword">in</span> get_creators</span><br><span class="line">ValueError: Invalid record: <span class="string">&#x27;Spam, spam, spam&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的几点是</p>
<ol type="1">
<li>pattern里面key的顺序不会影响匹配,
即便主语是<code>OrderedDict</code>.</li>
<li>跟sequence pattern对比, mapping pattern允许部分匹配.</li>
<li>因为允许部分匹配,
所以不需要用<code>**extra</code>匹配额外的key-value对.
但如果你想要捕获额外的key-value对, 作为一个dict,
最后一个变量可以用双星号变量, 而且不能是<code>**_</code>.</li>
</ol>
<h3 id="standard-api-of-mapping-types">3.3. Standard API of Mapping
Types</h3>
<p><code>dict</code>的接口是由<code>collections.abc</code>模块提供的<code>Mapping</code>和<code>MutableMapping</code>描述的,
见下图:</p>
<img src="/7112fecc//Figure3_1.png" class width="800" title="Figure 3-1 UML class diagram for the MutableMapping">
<p>想要自定义mapping类型, 可以扩展<code>collections.UserDict</code>,
或者通过composition包裹一个<code>dict</code>, 而不是这些ABCs的子类.
<code>collections.UserDict</code>类和标准库中的所有具体mapping类在其实现中都封装了基本dict.
而dict又构建在哈希表上. 因此. 它们都有一个限制.
即键必须是可散列(hashable)的(value不需要是可散列的，只需要key).</p>
<h4 id="what-is-hashable">3.3.1. What is Hashable</h4>
<p>定义: 如果一个对象具有一个哈希值,
并且这个值在对象的整个生命周期内不变(这需要一个<code>__hash__()</code>方法).
并且可以跟其他对象进行比较(这需要一个<code>__eq__()</code>方法),
那么这个对象就是可散列的(hashable).
两个相等的可散列对象必须具有相同的哈希值.</p>
<ul>
<li>可散列对象包括: 数值类型, flat immutable类型(str, bytes),
所有元素都是可散列的的immutable容器(frozenset, tuple if all its items
are hashable).</li>
<li>不可散列对象包括: mutable容器类(list, dict)</li>
</ul>
<p>其他几个知识点:</p>
<ol type="1">
<li>同一个对象的哈希值只有同一个python进程里能确保相等. 在不同的机器,
不同python版本, 不同python的实现, 不同的python进程里都不能确保相同.
其中一个原因是为了安全性的原因(PEP456),
在每个进程计算hash的时候加入一个随机因子(英语里叫撒点盐salt).</li>
<li>用户定义类型默认是hashable,
因为默认他们的哈希值就是他们的<code>id()</code>,
而<code>__eq__()</code>方法继承了根类<code>object</code>,
简单比较对象ID. 如果对象实现了<code>__eq__()</code>方法,
那么它只有实现了<code>__hash__()</code>方法, 并且其每次能返回相同值,
它才是hashable. 所以实践中,
这两个dunder方法仅使用那些在对象生命周期内保持不变的属性.</li>
</ol>
<h4 id="overview-of-common-mapping-methods">3.3.2. Overview of Common
Mapping Methods</h4>
<p>下面这个表给出了<code>dict</code>和它的两个流行的变体<code>defaultdict</code>和<code>OrderedDict</code>.
这两个变体定义在<code>collections</code>模块.</p>
<img src="/7112fecc//Table3_1.png" class width="800" title="Table 3-1. Methods of the mapping types">
<h4 id="inserting-or-updating-mutable-values">3.3.3. Inserting or
Updating Mutable Values</h4>
<p>若<code>dict</code>访问操作<code>d[k]</code>里的k不是一个存在的键,
会报错.
<code>d.get(k, default)</code>比处理<code>KeyError</code>更方便的返回默认值.
如果想要同时取值和更新, 可以使用<code>d.setdefault(key,default)</code>,
这个方法虽然叫set somthing, 但是意思是, 如果key存在就返回d[key],
否则先d[key]=default, 然后再返回d[key]. 这样可以减少一次搜索.</p>
<h3 id="automatic-handling-of-missing-keys">3.4. Automatic Handling of
Missing Keys</h3>
<p>在一个mapping对象搜索一个不存在的key, 对象的行为是可以定制化的.
通常通过两种可能的途径,
一个是用<code>defaultdict</code>代替默认的<code>dict</code>,
另一个是继承dict, 添加<code>__missing__</code>方法来定制行为模式.</p>
<h4 id="defaultdict-another-take-on-missing-keys">3.4.1. defaultdict:
Another Take on Missing Keys</h4>
<p>知识点:</p>
<ol type="1">
<li><code>collections.defaultdict</code>实例初始化的时候,
你需要提供一个可调用对象.</li>
<li>当一个不存在的key被传给<code>__getitem__</code>方法时,
这个可调用对象被调用来产生一个默认值.</li>
<li>这个可调用对象也作为实例的一个叫做<code>default_factory</code>的属性.</li>
<li>d.get(k)将不会触发<code>default_factory</code>被调用.</li>
</ol>
<h4 id="the-__missing__-method">3.4.2. The <code>__missing__</code>
Method</h4>
<p>想要更精确的定制处理不存在key的行为,
需要使用<code>__missing__</code>方法,
<code>dict</code>类没有定义这个方法, 但是如果任何子类提供了这个方法,
当不存在key被访问的时候,
<code>dict.__getitem__</code>会调用这个方法.</p>
<p>知识点:</p>
<ol type="1">
<li>避免出现无限迭代的情况.</li>
<li>为了行为一致性, <code>__contains__</code>方法也需要在子类重写.
因为表达式<code>k in d</code>会调用这个方法,
但继承自<code>dict</code>的<code>__contains__</code>并不会回调<code>__missing__</code>.</li>
</ol>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrKeyDict</span>(collections.UserDict):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, item</span>):</span><br><span class="line">        self.data[<span class="built_in">str</span>(key)] = item</span><br></pre></td></tr></table></figure>
<h4 id="inconsistent-usage-of-__missing__-in-the-standard-library">3.4.3.
Inconsistent Usage of <code>__missing__</code> in the Standard
Library</h4>
<p>几个场景</p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>dict</code>的子类
只实现了<code>__missing__</code></td>
<td style="text-align: left;">那么只有<code>d[k]</code>通过继承自<code>dict</code>的<code>__getitem__</code>
有可能调用<code>__missing__</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>collection.UserDict</code>的子类
只实现了<code>__missing__</code></td>
<td style="text-align: left;">由于继承自<code>UserDict</code>的<code>get</code>方法也调用<code>__getitem__</code>
所以<code>d[k]</code>和<code>d.get(k)</code>都有可能调用<code>__missing__</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>abc.Mapping</code>的子类
实现最简单的<code>__getitem__</code></td>
<td style="text-align: left;"><code>__missing__</code>永远不会被调用,
因为<code>__getitem__</code> 没调用它.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>abc.Mapping</code>的子类
<code>__getitem__</code>调用<code>__missing__</code></td>
<td style="text-align: left;"><code>d[k]</code>, <code>d.get(k)</code>,
<code>k in d</code>都会触发<code>__missing__</code></td>
</tr>
</tbody>
</table>
<p>这四个场景只描绘了最小化的实现,
如果你的子类实现了<code>__getitem__</code>, <code>get</code>,
<code>__contains__</code>,
那么你可以基于你的需求决定这些方法是否使用<code>__missing_</code>.
关键点是标准库中的mappings的默认行为是不一样的, 所以一定要小心使用.</p>
<p>别忘了<code>setdefault</code>和<code>update</code>也受搜索key的影响,
所以你有可能需要实现具有特殊逻辑的<code>__getitem__</code>来避免对象行为的不一致性.</p>
<h3 id="variations-of-dict">3.5. Variations of <code>dict</code></h3>
<p>这一节介绍标准库里除了<code>defaultdict</code>以外的mapping类型.</p>
<h4 id="collections.ordereddict">3.5.1.
<code>collections.OrderedDict</code></h4>
<p>Python 3.6开始, 内建的<code>dict</code>也会保留keys的顺序.
Python文档里列出的<code>dict</code>和<code>OrderedDict</code>的区别如下.</p>
<ol type="1">
<li><code>OrderedDict</code>在判定等号时会检查顺序是否相同.</li>
<li><code>OrderedDict</code>的<code>popitem()</code>方法会接受一个可选参数来指定时LIFO还是FIFO.</li>
<li><code>OrderedDict</code>有一个<code>move_to_end()</code>方法可以有效的把元素挪到队尾.</li>
<li>运算效率上, <code>dict</code>优先mapping操作,
而追踪插入元素的顺序次之.</li>
<li>运算效率上, <code>OrderedDict</code>优先重排序操作, 空间效率,
迭代速度和更新操作次之.</li>
<li>算法上,
<code>OrderedDict</code>比<code>dict</code>更善于处理频繁排序的操作.
因此很适合用于追踪最近访问的操作(比如LRU缓存).</li>
</ol>
<h4 id="collection.chainmap">3.5.2.
<code>collection.ChainMap</code></h4>
<ol type="1">
<li><code>ChainMap</code>实例可以把多个mapping类型对象当作一个列表来检索.
检索操作是按照构建时提供的mapping类型对象的顺序来执行的,
只要找到任何一个存在的key, 就检索成功.</li>
<li>更新和插入操作只影响第一个mapping对象</li>
<li>不拷贝对象, 只保存mapping对象的引用.</li>
<li>特别适合用于语言的嵌套名字哦那空间.</li>
</ol>
<p>例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = <span class="built_in">dict</span>(a=<span class="number">2</span>, b=<span class="number">4</span>, c=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain = ChainMap(d1, d2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain[<span class="string">&#x27;c&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">pylookup = ChainMap(<span class="built_in">locals</span>(), <span class="built_in">globals</span>(), <span class="built_in">vars</span>(builtins))</span><br></pre></td></tr></table></figure></p>
<h4 id="collection.counter">3.5.3. <code>collection.Counter</code></h4>
<ol type="1">
<li>这个对象可以保存每个key的整数计数.</li>
<li>更新对象实际上是在现存计数上加新计数.</li>
<li><code>+</code>和<code>-</code>运算用于合并计数.</li>
<li><code>most_common([n])</code>返回一个有序的list, 元素是tuple,
表示计数最多的前n个元素.</li>
</ol>
<p>例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.update(<span class="string">&#x27;aaaaazzz&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></p>
<h4 id="shelve.shelf">3.5.4. <code>shelve.Shelf</code></h4>
<p>标准库中的<code>shelve</code>模块为从字符串key到用<code>pickle</code>二进制格式序列化的Python对象的mapping提供了一个永久存储的方法.
名字叫<code>shelve</code>, 来自于咸菜(pickle)坛子放在架子(shelve)上.</p>
<p><code>shelve.open</code>函数返回一个<code>shelve.Shelf</code>实例,
这是一个简单的key-value DBM数据库.</p>
<h4 id="subclassing-userdict-instead-of-dict">3.5.5. Subclassing
UserDict Instead of dict</h4>
<p>这段建议大家如果想创建自己的mapping类型,
继承<code>UserDict</code>而不是<code>dict</code>.
主要原因是<code>dict</code>的实现里有一些shortcuts.
这导致一些本来可以直接继承<code>UserDict</code>的方法,
在继承<code>dict</code>时需要重写.</p>
<h3 id="immutable-mappings">3.6. Immutable Mappings</h3>
<p><code>types.MappingProxyType</code>
可以作为mapping类型的一个只读代理来使用.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;B&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="dictionary-views">3.7. Dictionary Views</h3>
<p><code>dict</code>实例的几个方法<code>.keys()</code>,
<code>.values()</code>, <code>.items()</code>返回下面几个类的实例:
<code>dict_keys</code>, <code>dict_values</code>,
<code>dict_items</code>. 这几个是dict实际数据结构的一个只读的投影,
避免了像python2一样的内存占用. 这几个类是<code>dict</code>专用的,
不能用<code>[]</code>进行元素访问, 也不能使用类直接实例化.
只实现了<code>__len__</code>, <code>__iter__</code>,
<code>__reversed__</code>几个特殊方法.</p>
<h3 id="practical-consequences-of-how-dict-works">3.8. Practical
Consequences of How dict Works</h3>
<ol type="1">
<li>Keys必须是hashable的对象.</li>
<li>通过key来访问dict的元素非常的快. 一个dict可能含有上百万个keys,
但python可以直接通过key的哈希值直接定位.</li>
<li>python3.6里key的顺序是更紧凑的内存布局的副作用,
在3.7中称为一个正式的特性.</li>
<li>尽快采用了新的紧缩内存, 依然有额外的内存开销.
而不是像Tuple采用的最紧缩布局 -- 容器是指向对象的引用的数组.
哈希表需要额外的空行来保持效率.</li>
<li>避免在<code>__init__</code>方法以外添加实例属性, 可以节省内存.
原因是python3.3开始, 内部设计是一个类的所有实例可以共享一个公共的哈希表,
通过每个新实例的<code>__dict__</code>.
但如果在<code>__init__</code>之后动态添加一个属性会强迫python为该实例创建一个新的哈希表.
见PEP412.</li>
</ol>
<h3 id="set-theory">3.9. Set Theory</h3>
<p><code>set</code>和<code>frozenset</code>最早作为module出现在python2.3,
后来在python2.6加入built-in类型. 虽然出现得早, 但还是没被充分利用.</p>
<ol type="1">
<li>一个set是unique对象的集合. 一个基本的用法是去除重复对象.
但不能保证顺序. 若想去掉重复还保证顺序, 有一个技巧, 如下.
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>.fromkeys(l).keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(l).keys())</span><br><span class="line">[<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li>set的元素必须是hashable的, 但set本身不是hashable的.
frozenset是hashable的, 可以嵌套进其它set.</li>
<li>set的几个中缀集合运算, 包括 <code>a | b</code>返回合集,
<code>a &amp; b</code>返回交集, <code>a - b</code>返回差集,
<code>a ^ b</code>返回对称差集(symmetric difference, 即(a-b)|(b-a)).
合理使用将使代码即快又有可读性.</li>
</ol>
<h4 id="set-literals">3.9.1 Set Literals</h4>
<ol type="1">
<li><code>set</code> 常量表达式看起来跟数学上的记号没啥区别, 除了一点,
就是没有空集. 表达式<code>&#123;&#125;</code>会返回一个空<code>dict</code>.
正确的空集用<code>set()</code>表示.</li>
<li>对于<code>set</code>类型,
常量表达式<code>&#123;1,2,3&#125;</code>比调用构造函数<code>set([1,2,3])</code>运行得更快.
因为前者直接使用<code>BUILD_SET</code>字节码,
后者还要创建<code>list</code>对象, 搜索构造函数等工作.</li>
<li><code>frozenset</code>只能调用构造函数, 比如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frozenset(range(10))</span><br><span class="line">frozenset(&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="set-comprehensions">3.9.2 Set Comprehensions</h4>
<ol type="1">
<li>跟<code>dict</code>类似, 就是括号中间没有<code>:</code>.
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from unicodedata import name</span><br><span class="line">&gt;&gt;&gt; &#123;chr(i) for i in range(32, 256) if &#x27;SIGN&#x27; in name(chr(i),&#x27;&#x27;)&#125;</span><br><span class="line">&#123;&#x27;§&#x27;, &#x27;=&#x27;, &#x27;¢&#x27;, &#x27;#&#x27;, &#x27;¤&#x27;, &#x27;&lt;&#x27;, &#x27;¥&#x27;, &#x27;μ&#x27;, &#x27;×&#x27;, &#x27;$&#x27;, &#x27;¶&#x27;, &#x27;£&#x27;, &#x27;©&#x27;,</span><br><span class="line">&#x27;°&#x27;, &#x27;+&#x27;, &#x27;÷&#x27;, &#x27;±&#x27;, &#x27;&gt;&#x27;, &#x27;¬&#x27;, &#x27;®&#x27;, &#x27;%&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li>顺序每个process不同, 是因为哈希计算撒盐的原因.</li>
</ol>
<h3 id="practical-consequences-of-how-sets-work">3.10 Practical
Consequences of How Sets Work</h3>
<ol type="1">
<li>元素必须是hashable对象.
实现<code>__hash__</code>和<code>__eq__</code>方法.</li>
<li>验证一个对象是否是元素非常高效, 是通过计算哈希值来确定的.</li>
<li>集合对象使用的内存要比数组对象多.</li>
<li>元素的顺序跟依赖于插入的顺序, 但是不完全可信.</li>
<li>加入新元素到一个集合对象, 有可能改变现存元素的顺序.
原因是一旦哈希表已经占用超过三分之二,
python内部算法可能需要移动和扩展这个哈希表,
这个过程中现有的元素需要被重新插入, 他们的相关顺序有可能会变.</li>
</ol>
<h4 id="set-operations">3.10.1 Set Operations</h4>
<p>注意:</p>
<ol type="1">
<li>下表中的一些运算符或者方法会修改集合对象本身(例如,
<code>&amp;=</code>, <code>difference_update</code>等),
这些方法不会在<code>frozenset</code>中实现.</li>
<li>双元运算符(infix operators)需要两边的操作数都是集合类型.
但是所有其他方法可以以可迭代对象为参数.
例如<code>a.union(b, c, d)</code>中a必须是<code>set</code>类型, 但是b,
c, d可以是可迭代对象.</li>
<li>如果不是更新现存的对象, 而是从4个可迭代对象创建一个新集合对象,
从python3.5以后可以用<code>&#123;*a, *b, *c, *d&#125;</code>这样的表达式.</li>
</ol>
<img src="/7112fecc//Figure3_2.png" class width="800" title="Figure 3-2 Simplified UML class diagram for MutableSet">
<img src="/7112fecc//Table3_2to3_4.png" class width="800" title="Figure 3-2 to 3_4 Set Operator and Methods">
<h3 id="set-operations-on-dict-views">3.11 Set Operations on dict
Views</h3>
<ol type="1">
<li>前面章节说过<code>dict</code>方法<code>.keys()</code>,
<code>.items()</code>会返回视图对象,
这几个对象跟<code>frozenset</code>非常相似.
下面这个表展示了他们的实例方法.</li>
<li>这几个试图对象还支持一些集合运算符, 合集(&amp;), 交集(|), 差集(-),
对称差集(^).</li>
<li><code>dict_ites</code>只有当所有values都是hashable的,
才能像<code>set</code>一样操作.</li>
</ol>
<img src="/7112fecc//Table3_5.png" class width="800" title="Table 3-5 Methods implemented by &#96;frozenset&#96;, &#96;dict_keys&#96; and &#96;dict_items&#96;">
<h2 id="unicode-text-versus-bytes">4. Unicode Text Versus Bytes</h2>
<p>Python3把人类使用的符号的字符串和字节序列明确的区分.
不能像python2一样隐藏转换. 这一章讨论下面几个话题:</p>
<pre><code>* 字符, code points和byte的表示
* 二进制序列:`bytes`, `bytearray`和`memoryview`的特性.
* Unicode的编码和过去的字符集的编码
* 避免和处理编码错误
* 处理text文件的最佳实践
* 默认编码的陷阱和标准I/O的问题
* 规范化的安全的Unicode文本的比较
* 几个用于nomalization, case folding和brute-force的实用函数
* 通过`locale`和`pyuca`库对Unicode文本进行排序
* Unicode数据库的字符元数据
* 处理`str`和`bytes`的双模式API</code></pre>
<div class="note info"><p>字符串和字节串这方面过去搞清楚过, 但是时间长了又忘了.
这里正好捋清楚.</p>
</div>
<h3 id="character-issues">4.1. Character Issues</h3>
<p>几个概念:</p>
<ol type="1">
<li>字节(byte), 一个8比特的整数.</li>
<li>字符(character), Unicode字符, 就是人类使用的各种符号.</li>
<li>字符串(string), 字符的序列</li>
<li>码点(code point), 码点是字符的唯一编号, 范围是从0到1114111.
Unicode标准里用前缀<code>U+</code>加上4到6位十六进制数字表示.</li>
<li>编码(encoding)和解码(decoding),
编码就是一种把码点转换成一个字节序列的算法. 反过来就是解码.</li>
</ol>
<h3 id="byte-essentials">4.2. Byte Essentials</h3>
<p>基础知识:</p>
<ol type="1">
<li>python3里又两个内置类<code>bytes</code>,
<code>bytesarray</code>来表示字节序列, 后者是immutable的.</li>
<li>这两个类实例的每个元素是一个0到255的整数.</li>
<li>对序列进行切片操作返回一个跟原序列相同类型的字节序列.</li>
<li>字节序列的元素访问操作<code>my_bytes[0]</code>返回一个整数,
字符串的元素访问操作返回一个字符串. 这里字符串比较特殊.</li>
</ol>
<p>显示一个字节序列的时候, ASCII通常嵌入到显示中, 这里有4种情况:</p>
<ol type="1">
<li>十进制32-126, 会显示ASCII字符本身.</li>
<li>制表符, 换行符, 回车符, <code>\</code>会用转义符显示,
<code>\t</code>, <code>\n</code>, <code>\r</code>, <code>\\</code>.</li>
<li>如果单双引号都在序列中, 那么显示的时候用单引号当作分隔符,
序列中的单引号用转义符<code>\'</code>表示.</li>
<li>其他所有的字节用一个转义符加x加两位十六进制数字表示,
比如<code>\x00</code>表示null字节.</li>
</ol>
<p>初始化一个<code>bytes</code>可以有以下几个方法:</p>
<ol type="1">
<li><code>bytes</code>的类方法<code>fromhex</code>.</li>
<li>用字符串和编码作为参数的构造函数.</li>
<li>用元素是0-255的值的可迭代对象作为参数的构造函数.</li>
<li>用实现了buffer协议的对象(bytes, bytearray, memoryview,
array.array)作为参数的构造函数. 这样会拷贝源对象的字节序列到新对象.</li>
<li>Python3.5以前可以用一个整数当作参数调用构造函数,
可以创建一个长度是该整数, 全部元素都是null的字节序列.
这个特性在Python3.6时被移除了(PEP-467).</li>
</ol>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe = <span class="built_in">bytes</span>(<span class="string">&#x27;café&#x27;</span>, encoding=<span class="string">&#x27;utf_8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe</span><br><span class="line"><span class="string">b&#x27;caf\xc3\xa9&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe[<span class="number">0</span>]</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe[:<span class="number">1</span>]</span><br><span class="line"><span class="string">b&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_arr = <span class="built_in">bytearray</span>(cafe)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_arr</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;caf\xc3\xa9&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_arr[-<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\xa9&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;31 4B CE A9&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;1K\xce\xa9&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="built_in">bytes</span>(numbers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b&#x27;\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="basic-encodersdecoders">4.3. Basic Encoders/Decoders</h3>
<p>Python支持100多种编码方式(codecs=encoder/decoders).
每个编码方式都有名字像<code>utf_8</code>, 和别名, 比如<code>utf8</code>,
<code>utf-8</code>. python文档里<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/codecs.html#standard-encodings">standard-encodings</a>可以找到这些名字的列表.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for codec in [&#x27;latin_1&#x27;, &#x27;utf_8&#x27;, &#x27;utf_16&#x27;]:</span><br><span class="line">...   print(codec, &#x27;El Niño&#x27;.encode(codec), sep=&#x27;\t&#x27;)</span><br><span class="line">...</span><br><span class="line">latin_1 b&#x27;El Ni\xf1o&#x27;</span><br><span class="line">utf_8 b&#x27;El Ni\xc3\xb1o&#x27;</span><br><span class="line">utf_16 b&#x27;\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="understanding-encodedecode-problems">4.4. Understanding
Encode/Decode Problems</h3>
<h4 id="coping-with-unicodeencodeerror">4.4.1. Coping with
UnicodeEncodeError</h4>
<p>除了UTF编码方式, 其他编码方式只能处理Unicode符号的一个子集.
当把文本转成字节的时候如果符号在指定的编码方式中没有定义,
那么就会抛出UnicodeEncodeError异常, 除非指定的处理方式被传递给编码函数.
例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>city = <span class="string">&#x27;São Paulo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">&#x27;utf_8&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;S\xc3\xa3o Paulo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">&#x27;utf_16&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xff\xfeS\x00\xe3\x00o\x00 \x00P\x00a\x00u\x00l\x00o\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">&#x27;iso8859_1&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;S\xe3o Paulo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">&#x27;cp437&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/.../lib/python3.4/encodings/cp437.py&quot;</span>, line <span class="number">12</span>, <span class="keyword">in</span> encode</span><br><span class="line">    <span class="keyword">return</span> codecs.charmap_encode(<span class="built_in">input</span>,errors,encoding_map)</span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;charmap&#x27;</span> codec can<span class="string">&#x27;t encode character &#x27;</span>\xe3<span class="string">&#x27; in position 1: character maps to &lt;undefined&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; city.encode(&#x27;</span>cp437<span class="string">&#x27;, errors=&#x27;</span>ignore<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;</span>So Paulo<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; city.encode(&#x27;</span>cp437<span class="string">&#x27;, errors=&#x27;</span>replace<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;</span>S?o Paulo<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; city.encode(&#x27;</span>cp437<span class="string">&#x27;, errors=&#x27;</span>xmlcharrefreplace<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;</span>S&amp;<span class="comment">#227;o Paulo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>ASCII是所有编码方式的子集,
用<code>str.isascii()</code>来检查一个文本是否纯ASCII编码方式,
可以避免UnicodeEncodeError异常.</p>
<h4 id="coping-with-unicodedecodeerror">4.4.2. Coping with
UnicodeDecodeError</h4>
<p>如果解码的时候碰到对于该编码方式是无效的字节,
那么会抛出<code>UnicodeEncodeError</code>.有些过去的8比特编码方式(比如<code>cp1252</code>,
<code>iso8859_1</code>)能够解码任何字符流, 所以如果使用这些编码方式,
程序将不会报错, 但是对于错误的字节不会报错, 而是转换成乱码.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="string">b&#x27;Montr\xe9al&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">&#x27;cp1252&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Montréal&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">&#x27;iso8859_7&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Montrιal&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">&#x27;koi8_r&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;MontrИal&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">&#x27;utf_8&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xe9 in position 5: invalid continuation byte</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; octets.decode(&#x27;</span>utf_8<span class="string">&#x27;, errors=&#x27;</span>replace<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<h4 id="syntaxerror-when-loading-modules-with-unexpected-encoding">4.4.3.
SyntaxError When Loading Modules with Unexpected Encoding</h4>
<p>python打开一个文件时默认该文件是用UTF-8进行编码存储的,
如果不是可以在文件开头加如下一行来指定: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># coding: cp1252</span><br></pre></td></tr></table></figure></p>
<h4 id="how-to-discover-the-encoding-of-a-byte-sequence">4.4.4. How to
Discover the Encoding of a Byte Sequence</h4>
<p>如果只有一个字节序列, 怎么能知道用的什么编码方式?
简单答案是你不能知道, 只能是被告知.
但是可以根据某些编码生成的字节序列的特性进行猜测.
<code>Chardet</code>是一个python库可以用来猜测30多种encodings.</p>
<h4 id="bom-a-useful-gremlin">4.4.5. BOM: A Useful Gremlin</h4>
<p>知识点:</p>
<ol type="1">
<li>UTF-16开头有可能有几个字节代表大小尾. 被叫做BOM(byte-order mark).
这个Unicode字符是U+FEFF(ZERO WIDTH NO-BREAK SPACE),
大尾时顺序是<code>b'\xfe\xff'</code>,
小尾是<code>b'\xff\xfe'</code>.</li>
<li>一个变体是UTF-16LE和UTF-16BE. 如果使用这两个BOM就不需要.</li>
<li>如果一个UTF-16格式的文件没有BOM, 根据Unicode标准默认应该是大尾,
但由于Intel x86是小尾芯片,
所以有大量的没有BOM却是小尾存储的UTF-16的文件存在.</li>
<li>大小尾问题之影响多于一个字节代表字符的编码, 比如UTF-16, UTF-32.
UTF-8最大的优势就是编码之后跟大小尾无关. 所以也不需要BOM.
然而一些windows的应用(著名的Notepad)会给UTF-8文件添加BOM.
这种编码被叫做UTF-8-SIG.
字符U+FEFF用UTF-8编码是<code>b'\xef\xbb\xbf'</code>.
所以如果文件开头是这三个字节. 很有可能是带BOM的UTF-8文件.</li>
</ol>
<h3 id="handling-text-files">4.5. Handling Text Files</h3>
<p>处理文本I/O的最佳实践是Unicode三明治模式,
意思是<code>bytes</code>应该尽快解码成<code>str</code>,
然后当作字符串进行处理, 处理完尽量晚的编码为字节序列.</p>
<h4 id="beware-of-encoding-defaults">4.5.1 Beware of Encoding
Defaults</h4>
<p>如果不指定编码格式, 那么在linux/macOS上, 默认都是UTF-8.
在windows上就复杂了:</p>
<ol type="1">
<li>如果打开文件的时候忽略了<code>encoding</code>参数,
默认是用<code>locale.getpreferredencoding()</code>的返回.
(cp1252如果windows地区设置成US)</li>
<li><code>sys.stdout|stdin|stderr</code>使用的编码格式逻辑如下:
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (环境变量PYTHONIOENCOD存在</span><br><span class="line">    and ((Python版本 &lt; 3.6)</span><br><span class="line">        or ((Python版本 &gt;= 3.6)</span><br><span class="line">            and 环境变量PYTHONLEGACYWINDOWSSTDIO存在))) then:</span><br><span class="line">    if 交互环境I/O:</span><br><span class="line">        默认使用UTF-8</span><br><span class="line">    elif I/O被重定向到文件:</span><br><span class="line">        默认使用locale.getpreferredencoding()的返回值作为编码格式.</span><br></pre></td></tr></table></figure></li>
<li>Python内部对bytes和str互相转换的默认编码格式是<code>sys.getdefaultencoding()</code>的返回值.</li>
<li>Python打开操作系统文件时, 传给OS
API的文件名字的默认编码格式是<code>sys.getfilesystemencoding()</code>的返回值.</li>
</ol>
<p>如此复杂, 所以最好的办法就是避免使用默认编码格式,
每次编码解码时都明确指定编码格式.</p>
<h3 id="normalizing-unicode-for-reliable-comparisons">4.6. Normalizing
Unicode for Reliable Comparisons</h3>
<p>由于Unicode允许通过把变音符号(diacritics)添加到其他字符,
实际显示出一个组合字符. 这增加了字符串比较的复杂性.</p>
<p>例子: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">&#x27;café&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;cafe\N&#123;COMBINING ACUTE ACCENT&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1, s2</span><br><span class="line">(<span class="string">&#x27;café&#x27;</span>, <span class="string">&#x27;café&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>解决办法是使用规范化函数<code>unicodedata.normalize()</code>,
这个函数的第一个参数, 可以是'NFC', 'NFD', 'NFCK', 'NFKD'.</p>
<ol type="1">
<li><p>Normalization Form Compose (NFC)会组合码点产生最短的等效字符串.
Normalization Form Decompose (NFD)会把字符扩展成基础字符和附加字符.
键盘输入的默认是NFC类型. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">&#x27;café&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;cafe\N&#123;COMBINING ACUTE ACCENT&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(normalize(<span class="string">&#x27;NFC&#x27;</span>, s1)), <span class="built_in">len</span>(normalize(<span class="string">&#x27;NFC&#x27;</span>, s2))</span><br><span class="line">(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(normalize(<span class="string">&#x27;NFD&#x27;</span>, s1)), <span class="built_in">len</span>(normalize(<span class="string">&#x27;NFD&#x27;</span>, s2))</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">&#x27;NFC&#x27;</span>, s1) == normalize(<span class="string">&#x27;NFC&#x27;</span>, s2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">&#x27;NFD&#x27;</span>, s1) == normalize(<span class="string">&#x27;NFD&#x27;</span>, s2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ohm = <span class="string">&#x27;\u2126&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(ohm)</span><br><span class="line"><span class="string">&#x27;OHM SIGN&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ohm_c = normalize(<span class="string">&#x27;NFC&#x27;</span>, ohm)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(ohm_c)</span><br><span class="line"><span class="string">&#x27;GREEK CAPITAL LETTER OMEGA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ohm == ohm_c</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">&#x27;NFC&#x27;</span>, ohm) == normalize(<span class="string">&#x27;NFC&#x27;</span>, ohm_c)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>NFKC和NFKD, K=compatibility=兼容字符,
兼容字符是只为了兼容其他标准存在的字符. 在这两种类型中,
一个兼容字符可以被拆解为一个或者多个被认为更好表示的其他字符,
虽然这种拆分有可能会丢失格式信息. 但方便搜索和索引操作.
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize, name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = <span class="string">&#x27;\N&#123;VULGAR FRACTION ONE HALF&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line">½</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">&#x27;NFKC&#x27;</span>, half)</span><br><span class="line"><span class="string">&#x27;1⁄2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> normalize(<span class="string">&#x27;NFKC&#x27;</span>, half):</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(char, name(char), sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> DIGIT ONE</span><br><span class="line">⁄ FRACTION SLASH</span><br><span class="line"><span class="number">2</span> DIGIT TWO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>four_squared = <span class="string">&#x27;4²&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">&#x27;NFKC&#x27;</span>, four_squared)</span><br><span class="line"><span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>micro = <span class="string">&#x27;μ&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>micro_kc = normalize(<span class="string">&#x27;NFKC&#x27;</span>, micro)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>micro, micro_kc</span><br><span class="line">(<span class="string">&#x27;μ&#x27;</span>, <span class="string">&#x27;μ&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(micro), <span class="built_in">ord</span>(micro_kc)</span><br><span class="line">(<span class="number">181</span>, <span class="number">956</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(micro), name(micro_kc)</span><br><span class="line">(<span class="string">&#x27;MICRO SIGN&#x27;</span>, <span class="string">&#x27;GREEK SMALL LETTER MU&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="case-folding">4.6.1. Case Folding</h4>
<p>大小写折叠(case folding)本质上就是把所有文本改成小写,
但有一些额外转换. 通过<code>str.casefold()</code>方法实现.
如果字符串所有的字符都是<code>latin1字符, 那么</code>s.casefold()<code>跟</code>s.lower()`产生相同的结果.
只有两个例外</p>
<ol type="1">
<li>micro sign <code>µ</code> 被转成小写希腊字母mu(虽然在大多数字体下,
他们看起来长得一样).</li>
<li>德文字母Eszett也就是'sharp s'(ß)被转成'ss'</li>
<li>大概有300个码点,
<code>str.casefold()</code>和<code>str.lower()</code>返回不同的结果.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(micro_cf)</span><br><span class="line"><span class="string">&#x27;GREEK SMALL LETTER MU&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>micro = <span class="string">&#x27;\N&#123;MICRO SIGN&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(micro)</span><br><span class="line"><span class="string">&#x27;MICRO SIGN&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu = micro.casefold()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(mu)</span><br><span class="line"><span class="string">&#x27;GREEK SMALL LETTER MU&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>micro, mu</span><br><span class="line">(<span class="string">&#x27;µ&#x27;</span>, <span class="string">&#x27;μ&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eszett = <span class="string">&#x27;ß&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name(eszett)</span><br><span class="line"><span class="string">&#x27;LATIN SMALL LETTER SHARP S&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eszett_cf = eszett.casefold()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eszett, eszett_cf</span><br><span class="line">(<span class="string">&#x27;ß&#x27;</span>, <span class="string">&#x27;ss&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div class="note success"><p>我理解大小写折叠的目的还是为了比较,
有些语言里一个大写字母对应多个小写字母,
所以折叠会把所有小写字母转换成统一的唯一小写字母.</p>
</div>
<h4 id="utility-functions-for-normalized-text-matching">4.6.2. Utility
Functions for Normalized Text Matching</h4>
<p>NFC和NFD规范化可以用于安全的比较大小写敏感的字符串.
大小写折叠可以帮助大小写不敏感的字符串. 下面两个是实用函数.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nfc_equal</span>(<span class="params">str1, str2</span>):</span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">&#x27;NFC&#x27;</span>, str1) == normalize(<span class="string">&#x27;NFC&#x27;</span>, str2)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fold_equal</span>(<span class="params">str1, str2</span>):</span><br><span class="line">    <span class="keyword">return</span> (normalize(<span class="string">&#x27;NFC&#x27;</span>, str1).casefold() ==</span><br><span class="line">            normalize(<span class="string">&#x27;NFC&#x27;</span>, str2).casefold())</span><br></pre></td></tr></table></figure>
<h4 id="extreme-normalization-taking-out-diacritics">4.6.3. Extreme
“Normalization”: Taking Out Diacritics</h4>
<ol type="1">
<li>去掉变音符号的的极端规范化, 见下面函数<code>shave_marks</code></li>
<li>只对拉丁字母去掉变音符号,
见下面函数<code>shave_marks_latin</code></li>
<li>更激进的一个步骤是把西方文本的通用符号替换成ASCII的等效字符串,
见下面函数<code>asciize</code></li>
</ol>
<script src="//gist.github.com/accd61035de9a7fd34e074308ff5af3e.js?file=simplify.py"></script>
<h3 id="sorting-unicode-text">4.7. Sorting Unicode Text</h3>
<p>比较字符串默认是比较码点,
但这对于很多非ASCII字符并不是我们期望的结果.
解决方案是<code>locale.strxfrm</code>. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> locale</span><br><span class="line">my_locale = locale.setlocale(locale.LC_COLLATE, <span class="string">&#x27;pt_BR.UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_locale)</span><br><span class="line">fruits = [<span class="string">&#x27;caju&#x27;</span>, <span class="string">&#x27;atemoia&#x27;</span>, <span class="string">&#x27;cajá&#x27;</span>, <span class="string">&#x27;açaí&#x27;</span>, <span class="string">&#x27;acerola&#x27;</span>]</span><br><span class="line">sorted_fruits = <span class="built_in">sorted</span>(fruits, key=locale.strxfrm)</span><br><span class="line"><span class="built_in">print</span>(sorted_fruits)</span><br></pre></td></tr></table></figure></p>
<p>有几点需要注意:</p>
<ol type="1">
<li><code>setlocale</code>是个全局调用, 不建议在库中调用.</li>
<li>相应的locale必须安装在操作系统.</li>
<li>locale名字必须拼写正确.</li>
<li>作者在linux和macOS尝试, 但并不是每次都成功.</li>
</ol>
<h4 id="sorting-with-the-unicode-collation-algorithm">4.7.1. Sorting
with the Unicode Collation Algorithm</h4>
<p>使用module <code>pyuca</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pyuca</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coll = pyuca.Collator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;caju&#x27;</span>, <span class="string">&#x27;atemoia&#x27;</span>, <span class="string">&#x27;cajá&#x27;</span>, <span class="string">&#x27;açaí&#x27;</span>, <span class="string">&#x27;acerola&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_fruits = <span class="built_in">sorted</span>(fruits, key=coll.sort_key)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_fruits</span><br><span class="line">[<span class="string">&#x27;açaí&#x27;</span>, <span class="string">&#x27;acerola&#x27;</span>, <span class="string">&#x27;atemoia&#x27;</span>, <span class="string">&#x27;cajá&#x27;</span>, <span class="string">&#x27;caju&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="the-unicode-database">4.8. The Unicode Database</h3>
<p>Unicode标准提供了一个完整的数据库, 不仅包括码点和字符名子,
还包括字符的元数据. 例如, 一个字符是否是字母, 是否是可打印的,
是否是十进制的数字还是其他数学符号.
这就是<code>str</code>的<code>isalpha</code>, <code>isprintable</code>,
<code>isdecimal</code>, <code>isnumeric</code>等方法的工作原理.
<code>str.casefold</code>也是使用这些信息.</p>
<h4 id="finding-characters-by-name">4.8.1. Finding Characters by
Name</h4>
<p>下面是一个通过名字查找字符的小工具. <script src="//gist.github.com/1f8ef426a845bf2eff0d116846ecebc2.js?file=cf.py"></script></p>
<h4 id="numeric-meaning-of-characters">4.8.2. Numeric Meaning of
Characters</h4>
<p>下面这个例子展示了如何确定一个字符是否是数字的几种方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re_digit = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#x27;</span>)</span><br><span class="line">sample = <span class="string">&#x27;1\xbc\xb2\u0969\u136b\u216b\u2466\u2480\u3285&#x27;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> sample:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;U+<span class="subst">&#123;<span class="built_in">ord</span>(char):04x&#125;</span>&#x27;</span>,</span><br><span class="line">          char.center(<span class="number">6</span>),</span><br><span class="line">          <span class="string">&#x27;re_dig&#x27;</span> <span class="keyword">if</span> re_digit.<span class="keyword">match</span>(char) <span class="keyword">else</span> <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;isdig&#x27;</span> <span class="keyword">if</span> char.isdigit() <span class="keyword">else</span> <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;isnum&#x27;</span> <span class="keyword">if</span> char.isnumeric() <span class="keyword">else</span> <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">          <span class="string">f&#x27;<span class="subst">&#123;unicodedata.numeric(char):<span class="number">5.2</span>f&#125;</span>&#x27;</span>,</span><br><span class="line">          unicodedata.name(char),</span><br><span class="line">          sep=<span class="string">&#x27;\t&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>下面就是输出结果.</p>
<img src="/7112fecc//Figure4_7.png" class width="800" title="macOS terminal showing numeric characters and metadata about them">
<h3 id="dual-mode-str-and-bytes-apis">4.9. Dual-Mode str and bytes
APIs</h3>
<p>有些标准库有函数可以接收<code>str</code>和<code>bytes</code>参数,
然后根据不同类型的参数做不同的处理.
主要是在<code>re</code>和<code>os</code>模块.</p>
<h4 id="str-versus-bytes-in-regular-expressions">4.9.1 str Versus bytes
in Regular Expressions</h4>
<ol type="1">
<li>正则表达式可以被用在<code>str</code>和<code>bytes</code>上,
但是如果用在<code>bytes</code>上, ASCII以外的字节, 既不被认为是数字,
也不被认为是文字.</li>
<li>对于<code>str</code>, 可以用re.ASCII标志使, , , , .</li>
</ol>
<h4 id="str-versus-bytes-in-os-functions">4.9.2 str Versus bytes in os
Functions</h4>
<p>所有跟os的函数都接受<code>str</code>或者<code>bytes</code>类型的文件名作为参数.
如果输入时<code>str</code>类型,
会根据<code>sys.getfilesystemencoding()</code>对输入字符串进行编码.
返回的也会是<code>str</code>类型.</p>
<p>如果输入<code>bytes</code>类型的文件名,
则返回的也是<code>bytes</code>.</p>
<h2 id="chapter-5.-data-class-builders">5. Chapter 5. Data Class
Builders</h2>
<p>Python提供了几个方式可以创建作为域(field)的集合的简单类.
这种模式的类被叫做"数据类"(data class).
这一章会介绍3个不同的构造数据类的方式:</p>
<ol type="1">
<li><code>collections.namedtuple</code>, 最简单的方式,
Python2.6引入.</li>
<li><code>typing.NamedTuple</code>, 需要类型提示(type hint)的另一个方式,
python3.5引入, python3.6增加了一些语法.</li>
<li><span class="citation" data-cites="dataclass.dataclass">@dataclass.dataclass</span>,
一个类装饰器, 可定制性加强, 增加了很选项和可能的复杂度.
Python3.7引入.</li>
</ol>
<p>这章大概看了看, 不是很感兴趣, 没啥难度, 不做笔记了,
需要用的时候再来翻阅.</p>
<h2 id="chapter-6.-object-references-mutability-and-recycling">6.
Chapter 6. Object References, Mutability, and Recycling</h2>
<p>本章新内容很少, 浏览了一下, 不写笔记了.</p>
<h1 id="part-ii.-functions-as-objects">Part II. Functions as
Objects</h1>
<h2 id="chapter-7.-functions-as-first-class-objects">7. Chapter 7.
Functions as First-Class Objects</h2>
<p>程序语言里, First-class被定义为:</p>
<ol type="1">
<li>运行时创建</li>
<li>可以被赋值给一个数据结构里的变量</li>
<li>可以作为参数传给一个函数</li>
<li>可以作为一个结果从一个函数返回</li>
</ol>
<h3 id="treating-a-function-like-an-object">7.1. Treating a Function
Like an Object</h3>
<p>几个无用的知识点:</p>
<ol type="1">
<li>运行时定义的语法</li>
<li><code>__doc__</code></li>
<li>type(fun)可以看出fun是一个<code>funciton</code>类的实例</li>
</ol>
<h3 id="higher-order-functions">7.2. Higher-Order Functions</h3>
<p>以函数为参数的函数, 或者以函数作为返回值的函数,
可以被称作高阶函数(Higher-Order Functions)</p>
<p>介绍了几个built-in的高阶函数:</p>
<ol type="1">
<li><code>sorted(iterable, /, *, key=None, reverse=False)</code>,
其中key是接收一个参数的函数, 其返回值值作为排序的关键字.</li>
<li><code>map(function, iterable, *iterables)</code>,
第一个参数是目标函数,
作用是以后面的可迭代对象的每一个元素作为参数来调用这个目标函数,
返回一个以目标函数的返回值为元素的可迭代对象.
如果有额外的可迭代对象作为<code>map</code>的参数,
那么目标函数必须接受跟所有可迭代对象数量相等的位置参数,
每次执行迭代的时候取每个参数的一个元素为目标函数的参数.
当任何一个可迭代对象执行完所有元素时, 停止迭代.</li>
<li><code>filter(function, iterable)</code>,
过滤出可迭代对象里让目标函数为真的元素组成一个新的可迭代函数.
<code>itertools.filterfalse()</code>过滤出使目标函数返回假的元素.</li>
<li><code>functools.reduce(function, iterable[, initializer])</code>,
基本上等于下面的逻辑. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce</span>(<span class="params">function, iterable, initializer=<span class="literal">None</span></span>):</span><br><span class="line">    it = <span class="built_in">iter</span>(iterable)</span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        value = <span class="built_in">next</span>(it)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = initializer</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        value = function(value, element)</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li>
</ol>
<p>自从引入了list推导式(comprehensions)和生成器表达式(generator
expressions)</p>
<h3 id="anonymous-functions">7.3 Anonymous Functions</h3>
<p><code>lamda</code>表达式可以用一个表达式(expression)创建一个匿名函数.
这里的限制就是无法使用语句(statement).
最佳的使用匿名函数的地方就是在高阶函数的参数列表中使用.</p>
<p>如果您发现一段代码因为lambda而难以理解, Fredrik
Lundh建议采用以下重构过程：</p>
<ol type="1">
<li>写一条comment解释lambda到底做了什么.</li>
<li>研究一下comment, 想出一个能描述comment本质的名字.</li>
<li>使用该名称将<code>lambda</code>转换为<code>def</code>语句.</li>
<li>删除评论.</li>
</ol>
<p>这些步骤引用自必读的"函数式编程指南".</p>
<h3 id="the-nine-flavors-of-callable-objects">7.4 The Nine Flavors of
Callable Objects</h3>
<p>9个可调用对象</p>
<ol type="1">
<li>User-defined functions:
<code>def</code>语句和<code>lambda</code>表达式</li>
<li>Built-in functions</li>
<li>Built-in methods</li>
<li>Methods: 定义在class语句内的函数</li>
<li>Classes: 当被调用时,
一个类先执行<code>__new__</code>方法创建一个实例对象,
然后调用<code>__init__</code>初始化这个对象. Python没有new操作符,
所以调用一个类就跟调用一个函数一样</li>
<li>Class instance: 如果一个类定义了<code>__call__</code>方法,
那么类实例可以像函数一样调用.</li>
<li>Generator functions:
在函数体内使用了<code>yield</code>关键字的函数或方法,
在调用时返回一个生成器(generator).</li>
<li>Native coroutine function: 函数或方法用<code>async def</code>定义的,
当调用的时候返回一个协程(coroutine). Python3.5加入.</li>
<li>Asynchronous generator functions:
函数或方法用<code>async def</code>定义, 并且函数体使用了yield语句.
当被调用时生成一个异步生成器. 可以用于<code>async for</code>语句.
Python3.6加入.</li>
</ol>
<p>生成器在17章讨论, 协程和异步生成器在21章讨论.
判断一个对象是否可调用使用内置的<code>callable</code>.</p>
<h3 id="user-defined-callable-types">7.5. User-Defined Callable
Types</h3>
<p>跳过, 无笔记</p>
<h3 id="from-positional-to-keyword-only-parameters">7.6. From Positional
to Keyword-Only Parameters</h3>
<p>例子: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fun(a,b,/,c,d,*,e,f)</span><br></pre></td></tr></table></figure></p>
<p>'/'前的参数只能是位置参数, '*'后的参数只能是关键字参数,
中间的两者都可以是.</p>
<h3 id="packages-for-functional-programming">7.7. Packages for
Functional Programming</h3>
<h4 id="the-operator-module">7.7.1. The operator Module</h4>
<p>Operator模块, 提供了函数编程的各种运算符, 其中两个比较特殊,
一个是取元素, 一个是属性访问.</p>
<ol type="1">
<li><p><code>itemgetter</code>, <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">After f = itemgetter(2), the call f(r) returns r[2].</span><br><span class="line">After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]).</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>attrgetter</code>, <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">After f = attrgetter(&#x27;name&#x27;), the call f(b) returns b.name.</span><br><span class="line">After f = attrgetter(&#x27;name&#x27;, &#x27;date&#x27;), the call f(b) returns (b.name, b.date).</span><br><span class="line">After f = attrgetter(&#x27;name.first&#x27;, &#x27;name.last&#x27;), the call f(b) returns (b.name.first, b.name.last).</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="freezing-arguments-with-functools.partial">7.7.2. Freezing
Arguments with functools.partial</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">functools.partial(func, /, *args, **keywords)</span><br><span class="line">functools.partialmethod(func, /, *args, **keywords)</span><br></pre></td></tr></table></figure>
<p>可以锁定函数或者方法的部分参数. 等效的逻辑差不多如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partial</span>(<span class="params">func, /, *args, **keywords</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">newfunc</span>(<span class="params">*fargs, **fkeywords</span>):</span><br><span class="line">        newkeywords = &#123;**keywords, **fkeywords&#125;</span><br><span class="line">        <span class="keyword">return</span> func(*args, *fargs, **newkeywords)</span><br><span class="line">    newfunc.func = func</span><br><span class="line">    newfunc.args = args</span><br><span class="line">    newfunc.keywords = keywords</span><br><span class="line">    <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure>
<h2 id="chapter-8.-type-hints-in-functions">8. Chapter 8. Type Hints in
Functions</h2>
<p>作者认为类型提示(Type Hint)是自2001年来Python最大的变化.
但类型提示是可选的. PEP-484提供了从语法(syntax)和语义(semantics)上,
明确定义变量的类型, 包括函数参数, 返回值, 和其他变量.
目标是帮助开发工具通过对代码的静态分析发现bugs.</p>
<h3 id="about-gradual-typing">8.1. About Gradual Typing</h3>
<p>PEP-484给python引进了一个类型系统 gradual type system(不好翻译,
就叫渐近类型吧). 其他使用渐近类型系统的语言包括Microsoft TypeScript,
Dart, Hack.</p>
<p>一个渐近类型系统:</p>
<ol type="1">
<li>是可选的</li>
<li>不在运行时获取类型错误</li>
<li>不增强性能</li>
</ol>
<h3 id="types-are-defined-by-supported-operations">8.2. Types Are
Defined by Supported Operations</h3>
<p>以下内容来自于PEP-483得翻译:</p>
<ol type="1">
<li>类型(Type)就是一些值得集合, 以及一些能够应用这些值得函数得集合.</li>
<li>子类型(Subtype)关系, b类型的值<span class="math inline">\(\subset\)</span>a类型的值, a类型的函数<span class="math inline">\(\subset\)</span>b类型的函数,
称b类型是a类型的子类型. 此时赋值语句"a类型的变量 =
b类型的变量"是安全的.</li>
<li>一致性(consistent)关系:
<ul>
<li>类型t1是类型t2的子类型, 那么t1跟t2是一致的. (反过来不成立)</li>
<li><code>Any</code>跟任何类型都是一致的.</li>
<li>任何类型跟<code>Any</code>都是一致的.</li>
</ul></li>
<li>类(class)是通过<code>class</code>语句定义的对象工厂,
并由内置函数<code>type(obj)</code>返回. 类是一个动态的运行时概念.</li>
</ol>
<p>未完待续</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/reading-note/" rel="tag"># reading note</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/df491dd4/" rel="prev" title="python decorator(装饰器)">
                  <i class="fa fa-chevron-left"></i> python decorator(装饰器)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/9432bb75/" rel="next" title="中国农历是如何计算的">
                  中国农历是如何计算的 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mingjian</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"retzzz","repo":"gitment-comments","client_id":"6a068ba17921ccef5727","client_secret":"f6a9f87e75e82d68a9988a1803eaf0ba021c2864","admin_user":"retzzz","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"1075cd4416d854d7e03c80d9d1eb4b66"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
